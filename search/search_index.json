{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Distgen","text":"<p>Distgen is a particle generator for accelerator physics applications. Distgen supports nearly arbitrary generation of 6D + time particle coordinates.</p>"},{"location":"installation/","title":"Installing Distgen","text":""},{"location":"installation/#using-conda","title":"Using conda","text":"<pre><code>conda install -c conda-forge pytao\n</code></pre>"},{"location":"installation/#using-setuptools","title":"Using setuptools","text":"<pre><code>python setup.py install\n</code></pre>"},{"location":"installation/#developers","title":"Developers","text":"<p>Clone this repository: <pre><code>git clone https://github.com/ColwynGulliford/distgen.git\n</code></pre></p> <p>Create an environment <code>distgen-dev</code> with all the dependencies: <pre><code>conda env create -f environment-dev.yml\n</code></pre></p> <p>Install as editable: <pre><code>conda activate distgen-dev\npip install --no-dependencies -e .\n</code></pre></p> <p>Create documentation: <pre><code>mkdocs serve\n</code></pre></p>"},{"location":"examples/basic/","title":"Distgen basic usage","text":"In\u00a0[1]: Copied! <pre># Useful for debugging\n%load_ext autoreload\n%autoreload 2\n%config InlineBackend.figure_format = 'retina'\n\nimport os\nimport yaml\n</pre> # Useful for debugging %load_ext autoreload %autoreload 2 %config InlineBackend.figure_format = 'retina'  import os import yaml <p>Distgen supports nearly arbitrary generation of 6D + time particle coordinates.</p> <p>Generator class defines the main object that creates a beam distribution.  Typical usage is to supply the <code>Generator.__init__(input, verbose)</code> with an input file name and a verbose integer value to control the level of output printed to the user.  Input file types can be either json or YAML. The user may also supply a dictionary as the input argument.</p> In\u00a0[2]: Copied! <pre>from distgen import Generator\n\ngen = Generator('data/rad.gaussian.in.yaml', verbose=0)\n</pre> from distgen import Generator  gen = Generator('data/rad.gaussian.in.yaml', verbose=0)  <p>Printing a Generator object displays the basic input data read from a distgen input file:</p> In\u00a0[3]: Copied! <pre>print(gen)\n</pre> print(gen) <pre>&lt;disgten.Generator with input: \nn_particle: 200000\noutput:\n  file: rad.gaussian.out.txt\n  type: gpt\nr_dist:\n  sigma_xy:\n    units: millimeter\n    value: 2\n  type: radial_gaussian\nrandom:\n  type: hammersley\nstart:\n  MTE:\n    units: millielectron_volt\n    value: 150\n  type: cathode\nt_dist:\n  max_t:\n    units: picosecond\n    value: 2\n  min_t:\n    units: picosecond\n    value: -2\n  type: uniform\ntotal_charge:\n  units: picocoulomb\n  value: 10\ntransforms: null\n\n&gt;\n</pre> <p>This data is stored internally in fully parsed form.  To get this structure it, use the convenience property <code>Generator.input</code>.  Note: there is no setter.</p> In\u00a0[4]: Copied! <pre>gen.input\n</pre> gen.input Out[4]: <pre>{'n_particle': 200000,\n 'output': {'file': 'rad.gaussian.out.txt', 'type': 'gpt'},\n 'r_dist': {'sigma_xy': {'value': 2, 'units': 'millimeter'},\n  'type': 'radial_gaussian'},\n 'random': {'type': 'hammersley'},\n 'start': {'MTE': {'value': 150, 'units': 'millielectron_volt'},\n  'type': 'cathode'},\n 't_dist': {'max_t': {'value': 2, 'units': 'picosecond'},\n  'min_t': {'value': -2, 'units': 'picosecond'},\n  'type': 'uniform'},\n 'total_charge': {'value': 10, 'units': 'picocoulomb'},\n 'transforms': None}</pre> <p>The input structure allows for four top levels: generator, beam, {variable}_dists, transforms, and output.  Any other input will throw an exception when attempting to create the beam:</p> In\u00a0[5]: Copied! <pre>try:\n    gen['foo']='bar'\nexcept Exception as ex:\n    print(ex)\n</pre> try:     gen['foo']='bar' except Exception as ex:     print(ex) <pre>Unexpected distgen input parameter: foo\n</pre> <p>Distgen generator.input is a nested dictionary by design.  While this logically organizes the input, it can be somewhat cumbersome for changing input.  Thus the generator.input dictionary can be accessed with pure strings via the [...] method with a flattened dictionary (nested keys separated by ':'):</p> In\u00a0[6]: Copied! <pre>gen['start']\n</pre> gen['start'] Out[6]: <pre>{'MTE': {'value': 150, 'units': 'millielectron_volt'}, 'type': 'cathode'}</pre> In\u00a0[7]: Copied! <pre>gen['start:MTE']\n</pre> gen['start:MTE'] Out[7]: <pre>{'value': 150, 'units': 'millielectron_volt'}</pre> <p>Brackets can also be used to set parameters.  When setting a parameter that has associated units, one must either specify whether setting the value or units, or pass in only the value:</p> In\u00a0[8]: Copied! <pre>gen['start:MTE:value']=120\nprint('New MTE setting:', gen['start:MTE'])\n</pre> gen['start:MTE:value']=120 print('New MTE setting:', gen['start:MTE']) <pre>New MTE setting: {'value': 120, 'units': 'millielectron_volt'}\n</pre> In\u00a0[9]: Copied! <pre>gen['start:MTE:units']='eV'\nprint('New MTE setting:', gen['start:MTE'])\n</pre> gen['start:MTE:units']='eV' print('New MTE setting:', gen['start:MTE']) <pre>New MTE setting: {'value': 120, 'units': 'electron_volt'}\n</pre> In\u00a0[10]: Copied! <pre>gen['start:MTE']=100\nprint('New MTE setting:', gen['start:MTE'])\n</pre> gen['start:MTE']=100 print('New MTE setting:', gen['start:MTE']) <pre>New MTE setting: {'value': 100, 'units': 'electron_volt'}\n</pre> <p>To create a distribution, run <code>Generator.beam()</code>:</p> In\u00a0[11]: Copied! <pre>gen = Generator('data/rad.gaussian.in.yaml', verbose=1) \nbeam = gen.beam()\n</pre> gen = Generator('data/rad.gaussian.in.yaml', verbose=1)  beam = gen.beam() <pre>Distribution format: gpt\nOutput file: rad.gaussian.out.txt\n\nCreating beam distribution....\n   Beam starting from: cathode\n   Total charge: 10 pC.\n   Number of macroparticles: 200000.\n   Assuming cylindrical symmetry...\n   r distribution: radial Gaussian\n   theta distribution: uniform theta\n      min_theta = 0 rad, max_theta = 6.28319 rad\n   t distribution: uniform\n      min_t = -2 ps, max_t = 2 ps\n   px distribution: Gaussian\n      avg_px = 0 eV/c, sigma_px = 276.857 eV/c\n   py distribution: Gaussian\n      avg_py = 0 eV/c, sigma_py = 276.857 eV/c\n   pz distribution: Gaussian\n      avg_pz = 0 eV/c, sigma_pz = 276.857 eV/c\n   Shifting avg_x = -7.82345E-05 mm -&gt; 0 mm\n   Scaling sigma_x = 1.99984 mm -&gt; 2 mm\n   Shifting avg_y = -1.09911E-05 mm -&gt; 0 mm\n   Scaling sigma_y = 1.99994 mm -&gt; 2 mm\n   Shifting avg_px = -0.0212516 eV/c -&gt; 0 eV/c\n   Scaling sigma_px = 276.849 eV/c -&gt; 276.857 eV/c\n   Shifting avg_py = -0.0259627 eV/c -&gt; 0 eV/c\n   Scaling sigma_py = 276.844 eV/c -&gt; 276.857 eV/c\n   Shifting avg_pz = -0.0372953 eV/c -&gt; 0 eV/c\n   Scaling sigma_pz = 276.843 eV/c -&gt; 276.857 eV/c\n   Shifting avg_t = -4.90022E-05 ps -&gt; 0 ps\n   Scaling sigma_t = 1.1547 ps -&gt; 1.1547 ps\n   Cathode start: fixing pz momenta to forward hemisphere\n      avg_pz -&gt; 220.904 eV/c, sigma_pz -&gt; 166.887 eV/c\n...done. Time Elapsed: 1.90499 s.\n\n</pre> <p>Alternatively, call <code>.run()</code>, which creates an openPMD-beamphysics style ParticleGroup</p> In\u00a0[12]: Copied! <pre>gen.verbose=False\ngen.run()\ngen.particles\n</pre> gen.verbose=False gen.run() gen.particles Out[12]: <pre>&lt;ParticleGroup with 200000 particles at 0x7fd7805cbcd0&gt;</pre> <p>The particle coordinates created by the Generator class are stored in a beam obect.  The main underlying coordinates are the 6D phase space coordinates $x$, $y$, $z$, $p_x$, $p_y$, $p_z$, and time $t$.  These can be accessed via the [...] operator.  The bunch charge is given by beam.q.</p> In\u00a0[13]: Copied! <pre>gen = Generator('data/rad.gaussian.in.yaml', verbose=0) \nbeam = gen.beam()\nprint(\"X coordinates:\", beam['x'])\nprint(\"Bunch charge:\", beam['q'])\n</pre> gen = Generator('data/rad.gaussian.in.yaml', verbose=0)  beam = gen.beam() print(\"X coordinates:\", beam['x']) print(\"Bunch charge:\", beam['q']) <pre>X coordinates: [1.289022452108133 3.050762686067514 2.1456876750642953 ... 2.6094886627111644 1.7667918315956421 3.722370619054455] millimeter\nBunch charge: 10 picocoulomb\n</pre> <p>Currently, the code assumes one particle species (default: electrons) per beam object.  The bunch contains an array of particle weights (currently uniform) for use with averaging.  The particle weights $w$ are normalized $\\sum_i{w_i}=1$ and are used for computing expectation values over the particle ensemble.</p> <p>Simple examples include beam.avg: $\\langle\\mathcal{O}\\rangle = \\sum_i w_i\\mathcal{O}_i$ and beam.std(): $\\sigma_{\\mathcal{O}} = \\sqrt{\\sum_i{w_i(\\mathcal{O}_i-\\langle\\mathcal{O}\\rangle)^2}}$.</p> <p>Other examples include the normalized and geometric emittance and the twiss parameters $\\beta$ and $\\alpha$  (See the distgen.beam.py).</p> In\u00a0[14]: Copied! <pre>import numpy as np\nprint(\"Beam species:\",beam.species)\nprint(\"Weights:\",beam[\"w\"])\nprint(\"Normalization sum(weights): \",np.sum(beam[\"w\"]))\nprint(f'Avgerage of X: {beam.avg(\"x\"):G~P}')\nprint(f'Standard Deviation of X: {beam.std(\"x\",desired_units=\"mm\"):G~P}')\n</pre> import numpy as np print(\"Beam species:\",beam.species) print(\"Weights:\",beam[\"w\"]) print(\"Normalization sum(weights): \",np.sum(beam[\"w\"])) print(f'Avgerage of X: {beam.avg(\"x\"):G~P}') print(f'Standard Deviation of X: {beam.std(\"x\",desired_units=\"mm\"):G~P}') <pre>Beam species: electron\nWeights: [5e-06 5e-06 5e-06 ... 5e-06 5e-06 5e-06] dimensionless\nNormalization sum(weights):  1.0 dimensionless\nAvgerage of X: -3.46945E-17 mm\nStandard Deviation of X: 2 mm\n</pre> In\u00a0[15]: Copied! <pre>gen.run()\npg = gen.particles\npg.plot('x', 'px')\n</pre> gen.run() pg = gen.particles pg.plot('x', 'px') In\u00a0[16]: Copied! <pre>gen = Generator('data/rad.gaussian.in.yaml', verbose=0) \ntry:\n    gen['r_dist:foo']='bar' \n    gen.beam()\nexcept Exception as ex:\n    print(ex)\n</pre> gen = Generator('data/rad.gaussian.in.yaml', verbose=0)  try:     gen['r_dist:foo']='bar'      gen.beam() except Exception as ex:     print(ex) <pre>Incorrect param given to NormRad.__init__(**kwargs): foo\nAllowed params: ['sigma_xy', 'truncation_fraction', 'truncation_radius_left', 'truncation_radius_right', 'n_sigma_cutoff_left', 'n_sigma_cutoff_left', 'n_sigma_cutoff', 'truncation_radius', 'truncation_radius_left', 'truncation_radius_right', 'verbose', 'type', 'indent']\n</pre> <p>As will missing required parameters:</p> In\u00a0[17]: Copied! <pre>gen = Generator('data/beer.can.in.yaml', verbose=0) \ntry:\n    gen['r_dist']={}\n    gen.beam()   \nexcept Exception as ex:\n    print(ex)\n</pre> gen = Generator('data/beer.can.in.yaml', verbose=0)  try:     gen['r_dist']={}     gen.beam()    except Exception as ex:     print(ex) <pre>/usr/share/miniconda/envs/distgen-dev/lib/python3.9/site-packages/distgen/generator.py:237: UserWarning: Input variable n_particle was a float, expected int.\n  warnings.warn('Input variable n_particle was a float, expected int.')\n</pre> <pre>No distribution type for r specified.\n</pre> In\u00a0[18]: Copied! <pre>from distgen.writers import writer\n\ngen = Generator('data/beer.can.in.yaml', verbose=0) \nbeam = gen.beam()\n\n# Typically the user can just call the general write function and specify the desired format:\nwriter(\"gpt\", beam, \"gpt.out.txt\", verbose=1)\nwriter(\"astra\", beam, \"astra.out.txt\", verbose=1)\nwriter(\"openPMD\", beam, \"openPMD.out.h5\", verbose=1)\n</pre> from distgen.writers import writer  gen = Generator('data/beer.can.in.yaml', verbose=0)  beam = gen.beam()  # Typically the user can just call the general write function and specify the desired format: writer(\"gpt\", beam, \"gpt.out.txt\", verbose=1) writer(\"astra\", beam, \"astra.out.txt\", verbose=1) writer(\"openPMD\", beam, \"openPMD.out.h5\", verbose=1) <pre>Printing 200000 particles to \"gpt.out.txt\": done. Time ellapsed: 2.08547 s.\nPrinting 200000 particles to \"astra.out.txt\": done. Time ellapsed: 2.32505 s.\nPrinting 200000)+\" particles to \"openPMD.out.h5\": done. Time ellapsed: 23.5305 ms.\n</pre> In\u00a0[19]: Copied! <pre># The distgen module has some basic plotting routines\nfrom distgen.plot import *\n\nunits = {'x':'mm','y':'mm','z':'mm', 'r':'mm', \n         'px':'keV/c','py':'keV/c','pz':'keV/c',\n         't':'ps','q':'pC','thetax':'mrad','I':'A'}\n\ngen = Generator('data/beer.can.in.yaml', verbose=0) \nbeam = gen.beam()\n\nfig=plt.figure(1)\n# X-Y Plot\nplot_dist2d(beam, \n            'x', units['x'],\n            'y', units['y'],\n            style='scatter_hist2d',\n            nbins=100,\n            axis='equal',\n            title_on=True);\n</pre> # The distgen module has some basic plotting routines from distgen.plot import *  units = {'x':'mm','y':'mm','z':'mm', 'r':'mm',           'px':'keV/c','py':'keV/c','pz':'keV/c',          't':'ps','q':'pC','thetax':'mrad','I':'A'}  gen = Generator('data/beer.can.in.yaml', verbose=0)  beam = gen.beam()  fig=plt.figure(1) # X-Y Plot plot_dist2d(beam,              'x', units['x'],             'y', units['y'],             style='scatter_hist2d',             nbins=100,             axis='equal',             title_on=True); <p>For plotting the histogram of the radial coordinate $r$, use <code>plot_radial_dist</code>:</p> In\u00a0[20]: Copied! <pre>gen = Generator('data/beer.can.in.yaml', verbose=0) \nbeam = gen.beam()\n\nplot_radial_dist(beam, units['r'], scale='charge', nbins=100, title_on=True);\n</pre> gen = Generator('data/beer.can.in.yaml', verbose=0)  beam = gen.beam()  plot_radial_dist(beam, units['r'], scale='charge', nbins=100, title_on=True); <p>For plotting 1D projections of the beam distribution, use <code>plot_dist1d</code>:</p> In\u00a0[21]: Copied! <pre>gen = Generator('data/beer.can.in.yaml', verbose=0) \nbeam = gen.beam()\n\nplot_dist1d(beam, 'x', units['x'], scale='number', nbins=50, title_on=True)\n</pre> gen = Generator('data/beer.can.in.yaml', verbose=0)  beam = gen.beam()  plot_dist1d(beam, 'x', units['x'], scale='number', nbins=50, title_on=True) <p>For plotting the current profile, use <code>plot_current_profile</code>:</p> In\u00a0[22]: Copied! <pre>gen = Generator('data/beer.can.in.yaml', verbose=0) \nbeam = gen.beam()\n\nplot_current_profile(beam, units['t'], units['I'], title_on=True, nbins=100);\n</pre> gen = Generator('data/beer.can.in.yaml', verbose=0)  beam = gen.beam()  plot_current_profile(beam, units['t'], units['I'], title_on=True, nbins=100); In\u00a0[23]: Copied! <pre>from distgen.drivers import run_distgen\n\nwith open('data/rad.gaussian.in.yaml') as fid:\n    p = yaml.safe_load(fid)\n\nbeam = run_distgen(inputs=p, verbose=1)\n</pre> from distgen.drivers import run_distgen  with open('data/rad.gaussian.in.yaml') as fid:     p = yaml.safe_load(fid)  beam = run_distgen(inputs=p, verbose=1) <pre>Distribution format: gpt\nOutput file: /home/runner/work/distgen/distgen/docs/examples/rad.gaussian.out.txt\n\nCreating beam distribution....\n   Beam starting from: cathode\n   Total charge: 10 pC.\n   Number of macroparticles: 200000.\n   Assuming cylindrical symmetry...\n   r distribution: radial Gaussian\n   theta distribution: uniform theta\n      min_theta = 0 rad, max_theta = 6.28319 rad\n   t distribution: uniform\n      min_t = -2 ps, max_t = 2 ps\n   px distribution: Gaussian\n      avg_px = 0 eV/c, sigma_px = 276.857 eV/c\n   py distribution: Gaussian\n      avg_py = 0 eV/c, sigma_py = 276.857 eV/c\n   pz distribution: Gaussian\n      avg_pz = 0 eV/c, sigma_pz = 276.857 eV/c\n   Shifting avg_x = -7.82345E-05 mm -&gt; 0 mm\n   Scaling sigma_x = 1.99984 mm -&gt; 2 mm\n   Shifting avg_y = -1.09911E-05 mm -&gt; 0 mm\n   Scaling sigma_y = 1.99994 mm -&gt; 2 mm\n   Shifting avg_px = -0.0212516 eV/c -&gt; 0 eV/c\n   Scaling sigma_px = 276.849 eV/c -&gt; 276.857 eV/c\n   Shifting avg_py = -0.0259627 eV/c -&gt; 0 eV/c\n   Scaling sigma_py = 276.844 eV/c -&gt; 276.857 eV/c\n   Shifting avg_pz = -0.0372953 eV/c -&gt; 0 eV/c\n   Scaling sigma_pz = 276.843 eV/c -&gt; 276.857 eV/c\n   Shifting avg_t = -4.90022E-05 ps -&gt; 0 ps\n   Scaling sigma_t = 1.1547 ps -&gt; 1.1547 ps\n   Cathode start: fixing pz momenta to forward hemisphere\n      avg_pz -&gt; 220.904 eV/c, sigma_pz -&gt; 166.887 eV/c\n...done. Time Elapsed: 1.77263 s.\n\nPrinting 200000 particles to \"/home/runner/work/distgen/distgen/docs/examples/rad.gaussian.out.txt\": done. Time ellapsed: 2.03944 s.\n\nBeam stats:\n   avg_x = 0 mm, sigma_x = 2 mm\n   avg_y = 2.06253E-16 mm, sigma_y = 2 mm\n   avg_z = 0 mm, sigma_z = 0 mm\n   avg_px = -5.88382E-16 eV/c, sigma_px = 276.857 eV/c\n   avg_py = -6.79683E-15 eV/c, sigma_py = 276.857 eV/c\n   avg_pz = 220.904 eV/c, sigma_pz = 166.887 eV/c\n   avg_t = -2.04087E-17 ps, sigma_t = 1.1547 ps\n</pre> <p>Below the function is called with 'inputs' pointing to an input file.  The function can also take  accept a flattened settings dict, which updates inputs:</p> In\u00a0[24]: Copied! <pre>new_settings = {'start:MTE:value':0.1}\nbeam = run_distgen(settings=new_settings, inputs=p, verbose=1)\n</pre> new_settings = {'start:MTE:value':0.1} beam = run_distgen(settings=new_settings, inputs=p, verbose=1) <pre>Replacing parameter start:MTE:value with value 0.1.\nDistribution format: gpt\nOutput file: /home/runner/work/distgen/distgen/docs/examples/rad.gaussian.out.txt\n\nCreating beam distribution....\n   Beam starting from: cathode\n   Total charge: 10 pC.\n   Number of macroparticles: 200000.\n   Assuming cylindrical symmetry...\n   r distribution: radial Gaussian\n   theta distribution: uniform theta\n      min_theta = 0 rad, max_theta = 6.28319 rad\n   t distribution: uniform\n      min_t = -2 ps, max_t = 2 ps\n   px distribution: Gaussian\n      avg_px = 0 eV/c, sigma_px = 7.148 eV/c\n   py distribution: Gaussian\n      avg_py = 0 eV/c, sigma_py = 7.148 eV/c\n   pz distribution: Gaussian\n      avg_pz = 0 eV/c, sigma_pz = 7.148 eV/c\n   Shifting avg_x = -7.82345E-05 mm -&gt; 0 mm\n   Scaling sigma_x = 1.99984 mm -&gt; 2 mm\n   Shifting avg_y = -1.09911E-05 mm -&gt; 0 mm\n   Scaling sigma_y = 1.99994 mm -&gt; 2 mm\n   Shifting avg_px = -0.000548713 eV/c -&gt; 0 eV/c\n   Scaling sigma_px = 7.14822 eV/c -&gt; 7.14842 eV/c\n   Shifting avg_py = -0.000670353 eV/c -&gt; 0 eV/c\n   Scaling sigma_py = 7.14809 eV/c -&gt; 7.14842 eV/c\n   Shifting avg_pz = -0.000962959 eV/c -&gt; 0 eV/c\n   Scaling sigma_pz = 7.14807 eV/c -&gt; 7.14842 eV/c\n   Shifting avg_t = -4.90022E-05 ps -&gt; 0 ps\n   Scaling sigma_t = 1.1547 ps -&gt; 1.1547 ps\n   Cathode start: fixing pz momenta to forward hemisphere\n      avg_pz -&gt; 5.70372 eV/c, sigma_pz -&gt; 4.309 eV/c\n...done. Time Elapsed: 1.81873 s.\n\nPrinting 200000 particles to \"/home/runner/work/distgen/distgen/docs/examples/rad.gaussian.out.txt\": done. Time ellapsed: 2.16481 s.\n\nBeam stats:\n   avg_x = 0 mm, sigma_x = 2 mm\n   avg_y = 2.06253E-16 mm, sigma_y = 2 mm\n   avg_z = 0 mm, sigma_z = 0 mm\n   avg_px = -1.11537E-16 eV/c, sigma_px = 7.14842 eV/c\n   avg_py = -8.59643E-17 eV/c, sigma_py = 7.14842 eV/c\n   avg_pz = 5.70372 eV/c, sigma_pz = 4.309 eV/c\n   avg_t = -2.04087E-17 ps, sigma_t = 1.1547 ps\n</pre> <p>Finally, is also possible to run distgen as an executible script using <code>/bin/DistGen.py</code></p> In\u00a0[25]: Copied! <pre>import subprocess\noutput=subprocess.check_output(['Distgen','-f','data/rad.gaussian.in.yaml','-v','2'])\noutput=str(output.decode('utf-8')).split(\"\\n\")\nfor line in output:\n    print(line)\n</pre> import subprocess output=subprocess.check_output(['Distgen','-f','data/rad.gaussian.in.yaml','-v','2']) output=str(output.decode('utf-8')).split(\"\\n\") for line in output:     print(line) <pre>Distribution format: gpt\nOutput file: rad.gaussian.out.txt\n\nCreating beam distribution....\n   Beam starting from: cathode\n   Total charge: 10 pC.\n   Number of macroparticles: 200000.\n   Assuming cylindrical symmetry...\n   r distribution: radial Gaussian\n   theta distribution: uniform theta\n      min_theta = 0 rad, max_theta = 6.28319 rad\n   t distribution: uniform\n      min_t = -2 ps, max_t = 2 ps\n   px distribution: Gaussian\n      avg_px = 0 eV/c, sigma_px = 276.857 eV/c\n   py distribution: Gaussian\n      avg_py = 0 eV/c, sigma_py = 276.857 eV/c\n   pz distribution: Gaussian\n      avg_pz = 0 eV/c, sigma_pz = 276.857 eV/c\n   Shifting avg_x = -7.82345E-05 mm -&gt; 0 mm\n   Scaling sigma_x = 1.99984 mm -&gt; 2 mm\n   Shifting avg_y = -1.09911E-05 mm -&gt; 0 mm\n   Scaling sigma_y = 1.99994 mm -&gt; 2 mm\n   Shifting avg_px = -0.0212516 eV/c -&gt; 0 eV/c\n   Scaling sigma_px = 276.849 eV/c -&gt; 276.857 eV/c\n   Shifting avg_py = -0.0259627 eV/c -&gt; 0 eV/c\n   Scaling sigma_py = 276.844 eV/c -&gt; 276.857 eV/c\n   Shifting avg_pz = -0.0372953 eV/c -&gt; 0 eV/c\n   Scaling sigma_pz = 276.843 eV/c -&gt; 276.857 eV/c\n   Shifting avg_t = -4.90022E-05 ps -&gt; 0 ps\n   Scaling sigma_t = 1.1547 ps -&gt; 1.1547 ps\n   Cathode start: fixing pz momenta to forward hemisphere\n      avg_pz -&gt; 220.904 eV/c, sigma_pz -&gt; 166.887 eV/c\n...done. Time Elapsed: 1.82036 s.\n\nPrinting 200000 particles to \"rad.gaussian.out.txt\": done. Time ellapsed: 1.98334 s.\n\nBeam stats:\n   avg_x = 0 mm, sigma_x = 2 mm\n   avg_y = 2.06253E-16 mm, sigma_y = 2 mm\n   avg_z = 0 mm, sigma_z = 0 mm\n   avg_px = -5.88382E-16 eV/c, sigma_px = 276.857 eV/c\n   avg_py = -6.79683E-15 eV/c, sigma_py = 276.857 eV/c\n   avg_pz = 220.904 eV/c, sigma_pz = 166.887 eV/c\n   avg_t = -2.04087E-17 ps, sigma_t = 1.1547 ps\n\n</pre> <p>Currently Distgen supports a single emission model.  Particles emitted from a cathode are assumed to have a Maxwell-Boltzmann distribution for their total mometnum $p$ parameterized by an energy scale denoted $MTE$:</p> <p>$\\rho_p(p) = \\left(\\frac{1}{2\\pi mMTE}\\right)^{3/2} 4\\pi p^2 \\exp\\left(-\\frac{p^2}{2m MTE}\\right)$, with $\\int\\rho_p(p)dp = 1$.</p> <p>Assuming spherical symmetry, it is easy to show the corresponding PDF for the components of the momenta is given by:</p> <p>$\\rho(p_x,p_y,p_z) = \\left(\\frac{1}{2\\pi mMTE}\\right)^{3/2}\\exp\\left(-\\frac{p_x^2+p_y^2+p_z^2}{2m MTE}\\right)$, with $\\int\\rho(p_x,p_y,p_z) d^3p=1$.</p> <p>From the equipartition theorem the average energy $\\frac{3}{2}MTE$ is divided equally among each direction and thus the energy scale $MTE$ can be identified as the Mean Transverse Energy: $MTE=\\frac{\\langle p_x^2\\rangle}{2m} + \\frac{\\langle p_y^2\\rangle}{2m}$.</p> <p>This expression can be used to relate the MTE to the initial cathode emittance:</p> <p>$\\epsilon_{n,x} = \\sigma_{x}\\sqrt{ \\frac{MTE}{mc^2} }$</p> <p>assuming there is no distinction between the $p_x$ and $p_y$ distributions inherent to the emission process.  To account for the fact that particles with $p_z&lt;0$ are not emitted from the cathode, distgen takes $p_z = |p_z|$.</p> <p>So far, all of the examples shown above describes beam distributions emitted from a cathode.  The input required for cathode start is shown below:</p> In\u00a0[26]: Copied! <pre>from distgen import Generator\ninput_file = \"data/rad.gaussian.in.yaml\"\n\ngen = Generator(input_file=input_file,verbose=1)\nprint('start', '=', gen.input['start'])\nprint('start:MTE:', '=', gen.input['start']['MTE'])\n</pre> from distgen import Generator input_file = \"data/rad.gaussian.in.yaml\"  gen = Generator(input_file=input_file,verbose=1) print('start', '=', gen.input['start']) print('start:MTE:', '=', gen.input['start']['MTE']) <pre>start = {'MTE': {'value': 150, 'units': 'millielectron_volt'}, 'type': 'cathode'}\nstart:MTE: = {'value': 150, 'units': 'millielectron_volt'}\n</pre> <p>Running the <code>Generator.beam()</code> function with <code>verbose</code> &gt;=1 will show the stats for generation of the momenta. Note the absolute value of the $p_z$ components is taken.</p> In\u00a0[27]: Copied! <pre>beam = gen.beam()\n</pre> beam = gen.beam() <pre>Distribution format: gpt\nOutput file: rad.gaussian.out.txt\n\nCreating beam distribution....\n   Beam starting from: cathode\n   Total charge: 10 pC.\n   Number of macroparticles: 200000.\n   Assuming cylindrical symmetry...\n   r distribution: radial Gaussian\n   theta distribution: uniform theta\n      min_theta = 0 rad, max_theta = 6.28319 rad\n   t distribution: uniform\n      min_t = -2 ps, max_t = 2 ps\n   px distribution: Gaussian\n      avg_px = 0 eV/c, sigma_px = 276.857 eV/c\n   py distribution: Gaussian\n      avg_py = 0 eV/c, sigma_py = 276.857 eV/c\n   pz distribution: Gaussian\n      avg_pz = 0 eV/c, sigma_pz = 276.857 eV/c\n   Shifting avg_x = -7.82345E-05 mm -&gt; 0 mm\n   Scaling sigma_x = 1.99984 mm -&gt; 2 mm\n   Shifting avg_y = -1.09911E-05 mm -&gt; 0 mm\n   Scaling sigma_y = 1.99994 mm -&gt; 2 mm\n   Shifting avg_px = -0.0212516 eV/c -&gt; 0 eV/c\n   Scaling sigma_px = 276.849 eV/c -&gt; 276.857 eV/c\n   Shifting avg_py = -0.0259627 eV/c -&gt; 0 eV/c\n   Scaling sigma_py = 276.844 eV/c -&gt; 276.857 eV/c\n   Shifting avg_pz = -0.0372953 eV/c -&gt; 0 eV/c\n   Scaling sigma_pz = 276.843 eV/c -&gt; 276.857 eV/c\n   Shifting avg_t = -4.90022E-05 ps -&gt; 0 ps\n   Scaling sigma_t = 1.1547 ps -&gt; 1.1547 ps\n   Cathode start: fixing pz momenta to forward hemisphere\n      avg_pz -&gt; 220.904 eV/c, sigma_pz -&gt; 166.887 eV/c\n...done. Time Elapsed: 1.68958 s.\n\n</pre> <p>The time coordinate in this case effectively respresents the emission time of the particle from the cathode, and thus the time distribution should be set by the user.  The plots below show the corresponding horizontal and longitudinal phase spaces:</p> In\u00a0[28]: Copied! <pre>fig, ax = plt.subplots(1, 2, sharex='col',constrained_layout=True)\n\nplot_dist2d(beam, 'x', units['x'], 'px', units['px'], ax=ax[0]);\nax[0].set_title('x-Px Phase Space')\n\nplot_dist2d(beam, 't', units['t'], 'pz', units['pz'], ax=ax[1]);\nax[1].set_title('t-Pz Phase Space');\n</pre> fig, ax = plt.subplots(1, 2, sharex='col',constrained_layout=True)  plot_dist2d(beam, 'x', units['x'], 'px', units['px'], ax=ax[0]); ax[0].set_title('x-Px Phase Space')  plot_dist2d(beam, 't', units['t'], 'pz', units['pz'], ax=ax[1]); ax[1].set_title('t-Pz Phase Space'); <p>Distgen also allows the user to start a beam at an arbitrary time.  In this case, distgen will ignore any user distribution settings for the time coordinate of the beam particles.  The beam has some initial Gaussian momentum.  To make this more interesting, the beam is boosted to 1 GeV, the Twiss Parameters set, and a cosine like energy spread applied:</p> In\u00a0[29]: Copied! <pre>from distgen.physical_constants import unit_registry, pi, c\n\ngen = Generator(\"data/gaussian.in.yaml\", verbose=0) \n\nf = 1.3*unit_registry('GHz')\nw = 2*pi*f/c\n\nlinac_params = {\n    'type':'cosine z:pz',\n    'amplitude':{'value':1,'units':'GeV/c'},\n    'omega':{'value':w.magnitude, 'units':str(w.units)},\n    'phase':{'value':-1, 'units':'deg'}\n}\n\nxbeta_params = {\n    'type':'set_twiss x',\n    'beta': {'value':12.5, 'units':'m'},\n    'alpha':{'value':-1, 'units':''},\n    'emittance':  {'value':2,'units':'nm'},\n}\nybeta_params = {\n    'type':'set_twiss y',\n    'beta': {'value':12.5, 'units':'m'},\n    'alpha':{'value':-1, 'units':''},\n    'emittance':  {'value':2,'units':'nm'},\n}\n\ngen['transforms']={'t1':linac_params, 't2':xbeta_params, 't3':ybeta_params, 'order':['t1','t2','t3']}\n  \nbeam = gen.beam()\n\nprint('YAML transforms input\\n', yaml.dump(gen.input['transforms']))\n\nprint('\\nFinal Horizontal Twiss params:')\nprint(f'beta: {beam.Beta(\"x\"):G~P}, alpha: {beam.Alpha(\"x\"):G~P}, eps: {beam.emitt(\"x\",\"geometric\").to(\"nm\"):G~P}')\n#print(f'beta: {beam.Beta(\"x\"):G~P}, alpha: {beam.Alpha(\"x\"):G~P}, eps: {beam.emitt(\"x\",\"geometric\").to(\"nm\"):Gf~P}')\n\nprint('\\nFinal Vertical Twiss params:')\nprint(f'beta: {beam.Beta(\"y\"):G~P}, alpha: {beam.Alpha(\"y\"):G~P}, eps: {beam.emitt(\"y\",\"geometric\").to(\"nm\"):G~P}')\n</pre> from distgen.physical_constants import unit_registry, pi, c  gen = Generator(\"data/gaussian.in.yaml\", verbose=0)   f = 1.3*unit_registry('GHz') w = 2*pi*f/c  linac_params = {     'type':'cosine z:pz',     'amplitude':{'value':1,'units':'GeV/c'},     'omega':{'value':w.magnitude, 'units':str(w.units)},     'phase':{'value':-1, 'units':'deg'} }  xbeta_params = {     'type':'set_twiss x',     'beta': {'value':12.5, 'units':'m'},     'alpha':{'value':-1, 'units':''},     'emittance':  {'value':2,'units':'nm'}, } ybeta_params = {     'type':'set_twiss y',     'beta': {'value':12.5, 'units':'m'},     'alpha':{'value':-1, 'units':''},     'emittance':  {'value':2,'units':'nm'}, }  gen['transforms']={'t1':linac_params, 't2':xbeta_params, 't3':ybeta_params, 'order':['t1','t2','t3']}    beam = gen.beam()  print('YAML transforms input\\n', yaml.dump(gen.input['transforms']))  print('\\nFinal Horizontal Twiss params:') print(f'beta: {beam.Beta(\"x\"):G~P}, alpha: {beam.Alpha(\"x\"):G~P}, eps: {beam.emitt(\"x\",\"geometric\").to(\"nm\"):G~P}') #print(f'beta: {beam.Beta(\"x\"):G~P}, alpha: {beam.Alpha(\"x\"):G~P}, eps: {beam.emitt(\"x\",\"geometric\").to(\"nm\"):Gf~P}')  print('\\nFinal Vertical Twiss params:') print(f'beta: {beam.Beta(\"y\"):G~P}, alpha: {beam.Alpha(\"y\"):G~P}, eps: {beam.emitt(\"y\",\"geometric\").to(\"nm\"):G~P}') <pre>YAML transforms input\n order:\n- t1\n- t2\n- t3\nt1:\n  amplitude:\n    units: gigaelectron_volt / speed_of_light\n    value: 1.0\n  omega:\n    units: gigahertz * radian * second / meter\n    value: 2.724598528537186e-08\n  phase:\n    units: degree\n    value: -1.0\n  type: cosine z:pz\nt2:\n  alpha:\n    units: dimensionless\n    value: -1.0\n  beta:\n    units: meter\n    value: 12.5\n  emittance:\n    units: nanometer\n    value: 2.0\n  type: set_twiss x\nt3:\n  alpha:\n    units: dimensionless\n    value: -1.0\n  beta:\n    units: meter\n    value: 12.5\n  emittance:\n    units: nanometer\n    value: 2.0\n  type: set_twiss y\n\n\nFinal Horizontal Twiss params:\nbeta: 12500 mm, alpha: -1, eps: 2 nm\n\nFinal Vertical Twiss params:\nbeta: 12500 mm, alpha: -1, eps: 2 nm\n</pre> In\u00a0[30]: Copied! <pre>fig, ax = plt.subplots(1, 3, constrained_layout=True)\nplot_dist2d(beam, 'x', units['x'], 'y', units['y'], axis='equal', ax=ax[0]);\nplot_dist2d(beam, 'x', units['x'], 'thetax', units['thetax'], ax=ax[1]);\nplot_dist2d(beam, 'z', units['z'],  'pz','GeV/c', ax=ax[2]);\n</pre> fig, ax = plt.subplots(1, 3, constrained_layout=True) plot_dist2d(beam, 'x', units['x'], 'y', units['y'], axis='equal', ax=ax[0]); plot_dist2d(beam, 'x', units['x'], 'thetax', units['thetax'], ax=ax[1]); plot_dist2d(beam, 'z', units['z'],  'pz','GeV/c', ax=ax[2]); In\u00a0[31]: Copied! <pre>filename = \"data/gaussian.in.yaml\"\ngen = Generator(filename, verbose=0) \n\ngen['pz_dist:avg_pz'] = 1  # Set beam 1 at pz = 1 GeV\ngen['z_dist:avg_z'] = -10  # Set beam 1 at z = -10 mmm\n\nxbeta_params = {\n    'type':'set_twiss x',\n    'beta': {'value':12.5, 'units':'m'},\n    'alpha':{'value':-1, 'units':''},\n    'emittance':  {'value':2,'units':'nm'},\n}\n\nybeta_params = {\n    'type':'set_twiss y',\n    'beta': {'value':12.5, 'units':'m'},\n    'alpha':{'value':-1, 'units':''},\n    'emittance':  {'value':2,'units':'nm'},\n}\n\ngen['transforms']={'t1':xbeta_params, 't2':ybeta_params, 'order':['t1','t2']}\n\npg1 = gen.run()\n</pre> filename = \"data/gaussian.in.yaml\" gen = Generator(filename, verbose=0)   gen['pz_dist:avg_pz'] = 1  # Set beam 1 at pz = 1 GeV gen['z_dist:avg_z'] = -10  # Set beam 1 at z = -10 mmm  xbeta_params = {     'type':'set_twiss x',     'beta': {'value':12.5, 'units':'m'},     'alpha':{'value':-1, 'units':''},     'emittance':  {'value':2,'units':'nm'}, }  ybeta_params = {     'type':'set_twiss y',     'beta': {'value':12.5, 'units':'m'},     'alpha':{'value':-1, 'units':''},     'emittance':  {'value':2,'units':'nm'}, }  gen['transforms']={'t1':xbeta_params, 't2':ybeta_params, 'order':['t1','t2']}  pg1 = gen.run() In\u00a0[32]: Copied! <pre>pg1.plot('x', 'px')\n</pre> pg1.plot('x', 'px') In\u00a0[33]: Copied! <pre>pg1.plot('z')\n</pre> pg1.plot('z') <p>Next, make second beam.  Here shift the z position of the beam and change the $\\alpha$ Twiss parameter's sign to create a different momenta distribution:</p> In\u00a0[34]: Copied! <pre>gen['z_dist:avg_z'] = 10   # Set beam 1 at z = +10 mmm\n\nxbeta_params['alpha']['value'], ybeta_params['alpha']['value'] = +1, +1\n\ngen['transforms']={'t1':xbeta_params, 't2':ybeta_params, 'order':['t1','t2']}\n\npg2 = gen.run()\n</pre> gen['z_dist:avg_z'] = 10   # Set beam 1 at z = +10 mmm  xbeta_params['alpha']['value'], ybeta_params['alpha']['value'] = +1, +1  gen['transforms']={'t1':xbeta_params, 't2':ybeta_params, 'order':['t1','t2']}  pg2 = gen.run()  <p>The particle group objects support addition:</p> In\u00a0[35]: Copied! <pre>pg = pg1 + pg2\n</pre> pg = pg1 + pg2 In\u00a0[36]: Copied! <pre>pg.plot('x','px')\n</pre> pg.plot('x','px') In\u00a0[37]: Copied! <pre>pg.plot('z')\n</pre> pg.plot('z') <p>It is also possible to superimpose built in distgen particle distributions.  Please see the <code>examples_dists.ipynb</code> for details on how to use this functionality.</p> In\u00a0[38]: Copied! <pre>gen = Generator(input_file, verbose=0) \ngen.run()\n</pre> gen = Generator(input_file, verbose=0)  gen.run() Out[38]: <pre>&lt;ParticleGroup with 200000 particles at 0x7fd7464830d0&gt;</pre> <p>If no filename is given, a unique one will be written based on <code>.input</code></p> In\u00a0[39]: Copied! <pre>afile = gen.archive()\nafile\n</pre> afile = gen.archive() afile Out[39]: <pre>'distgen_1041309f622d77d5842c7bbf367ed45f.h5'</pre> <p>Loading into a new object</p> In\u00a0[40]: Copied! <pre>G2 = Generator(verbose=True)\nG2.load_archive(afile)\n</pre> G2 = Generator(verbose=True) G2.load_archive(afile) <pre>   Reading group ./ from archive file distgen_1041309f622d77d5842c7bbf367ed45f.h5</pre> <p>open h5 handles can also be written to, using the same routine.</p> In\u00a0[41]: Copied! <pre>import h5py\n\nwith h5py.File('archive.h5', 'w') as h5:\n    G2.archive(h5)\n</pre> import h5py  with h5py.File('archive.h5', 'w') as h5:     G2.archive(h5) In\u00a0[42]: Copied! <pre>os.remove('rad.gaussian.out.txt')\nos.remove('gpt.out.txt')\nos.remove('astra.out.txt')\nos.remove('openPMD.out.h5')\n#os.remove('beer.can.out.txt')\nos.remove(afile)\nos.remove('archive.h5')\n</pre> os.remove('rad.gaussian.out.txt') os.remove('gpt.out.txt') os.remove('astra.out.txt') os.remove('openPMD.out.h5') #os.remove('beer.can.out.txt') os.remove(afile) os.remove('archive.h5') In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/basic/#distgen-basic-usage","title":"Distgen basic usage\u00b6","text":""},{"location":"examples/basic/#generator","title":"Generator\u00b6","text":""},{"location":"examples/basic/#beam-object","title":"Beam Object\u00b6","text":""},{"location":"examples/basic/#generating-openpmd-beamphysics-particle-group-objects","title":"Generating OpenPMD-beamphysics Particle Group objects\u00b6","text":"<p>Distgen supports direct creation of OpenPMD beam physics particle group objects, a very useful object for handling beam distribitions and writing them to various codes.  Please see https://github.com/ChristopherMayes/openPMD-beamphysics for details.  To generate a OpenPMD-beamphysics particle group, use the <code>run()</code> command. The resulting ParticleGroup is saved as <code>Generator.particles</code>:</p>"},{"location":"examples/basic/#distribution-objects","title":"Distribution Objects\u00b6","text":"<p>Distgen handles distirbutions using classes controlled by Generator.  Currently there are three types supported: 1D distributions (Dist1d), radial distributions for the $r$ coordinate, and 2D distributions.  Each distribution type keeps an internal list of the required and optional parameters that must be passed to the object.  When a distribution object is initialized, the input parameters are checked against this list. Unexpected inputs will throw exceptions:</p>"},{"location":"examples/basic/#output-writer-functionality","title":"Output writer functionality\u00b6","text":"<p>Distgen supports writer functions for various output formats/codes.  Currently these include GPT and ASTRA, and the openPMD specification.  To write to a file, use distgen.writers.writer with appropriate code type specified as well as the beam object and desired output file.  The writer function accepts additional parameters required for any code dependent output.</p>"},{"location":"examples/basic/#plotting","title":"Plotting\u00b6","text":"<p>Distgen provides the user with some basic plotting routines for help in visualizing the beam coordinates.  The most common plot types include <code>plot_dist2d</code>, <code>plot_dist1d</code>, <code>plot_radial_dist</code>, and <code>plot_current_profile</code>.  Below shows an example of how to plot 2 coordinates, in this case $x$ and $y$.  The coloring scheme is a scatter histogram.</p>"},{"location":"examples/basic/#running-distgen-with-driver-functions","title":"Running Distgen with driver functions\u00b6","text":"<p>The main in python driver function for distgen is <code>distgen.drivers.run_distgen()</code>.  The function creates its own Generator object and returns a beam object.  Inputs can either be an inputfile or a parsed distgen supported input dictionary.  Here the function is run with an input dictionary created above.</p>"},{"location":"examples/basic/#scalingrotatingshifting-coordinates","title":"Scaling/Rotating/Shifting Coordinates\u00b6","text":"<p>The distgen module allows the user with several options for applying coordinate transformations.  Some of the basic operations include: shifting, scaling, and rotating coordinates.  See the transform.ipynb for a detailed description of this functionality.</p>"},{"location":"examples/basic/#cathode-start","title":"Cathode Start\u00b6","text":""},{"location":"examples/basic/#time-start","title":"Time Start\u00b6","text":""},{"location":"examples/basic/#combining-beams","title":"Combining Beams\u00b6","text":"<p>Currently distgen supports combining beams in to ways.  The first makes use of the OpenPMD-beamphysics Particle Group's addition property.  This is achieved by making two separate beams:</p>"},{"location":"examples/basic/#archiving","title":"Archiving\u00b6","text":"<p>All input and output can be saved and loaded to an hdf5 file using <code>.archive()</code> and <code>.load_archive</code> functions.</p> <p>Input is archived as a flattended dict, with keys separated by <code>:</code></p> <p>Particlces are archived as openPMD-beamphysics, but only if they are created with the <code>run()</code> command.</p>"},{"location":"examples/basic/#clean-up","title":"Clean up\u00b6","text":""},{"location":"examples/conversion_examples/","title":"Examples on converting to other formats","text":"In\u00a0[1]: Copied! <pre># Useful for debugging\n%load_ext autoreload\n%autoreload 2\n</pre> # Useful for debugging %load_ext autoreload %autoreload 2 In\u00a0[2]: Copied! <pre>from distgen.drivers import run_distgen\n\nimport os\n</pre> from distgen.drivers import run_distgen  import os In\u00a0[3]: Copied! <pre>beam = run_distgen(inputs='data/rad.gaussian.in.yaml', verbose=1)\n</pre> beam = run_distgen(inputs='data/rad.gaussian.in.yaml', verbose=1) <pre>Distribution format: gpt\nOutput file: rad.gaussian.out.txt\n\nCreating beam distribution....\n   Beam starting from: cathode\n   Total charge: 10 pC.\n   Number of macroparticles: 200000.\n   Assuming cylindrical symmetry...\n   r distribution: radial Gaussian\n   theta distribution: uniform theta\n      min_theta = 0 rad, max_theta = 6.28319 rad\n   t distribution: uniform\n      min_t = -2 ps, max_t = 2 ps\n   px distribution: Gaussian\n      avg_px = 0 eV/c, sigma_px = 276.857 eV/c\n   py distribution: Gaussian\n      avg_py = 0 eV/c, sigma_py = 276.857 eV/c\n   pz distribution: Gaussian\n      avg_pz = 0 eV/c, sigma_pz = 276.857 eV/c\n   Shifting avg_x = -7.82345E-05 mm -&gt; 0 mm\n   Scaling sigma_x = 1.99984 mm -&gt; 2 mm\n   Shifting avg_y = -1.09911E-05 mm -&gt; 0 mm\n   Scaling sigma_y = 1.99994 mm -&gt; 2 mm\n   Shifting avg_px = -0.0212516 eV/c -&gt; 0 eV/c\n   Scaling sigma_px = 276.849 eV/c -&gt; 276.857 eV/c\n   Shifting avg_py = -0.0259627 eV/c -&gt; 0 eV/c\n   Scaling sigma_py = 276.844 eV/c -&gt; 276.857 eV/c\n   Shifting avg_pz = -0.0372953 eV/c -&gt; 0 eV/c\n   Scaling sigma_pz = 276.843 eV/c -&gt; 276.857 eV/c\n   Shifting avg_t = -4.90022E-05 ps -&gt; 0 ps\n   Scaling sigma_t = 1.1547 ps -&gt; 1.1547 ps\n   Cathode start: fixing pz momenta to forward hemisphere\n      avg_pz -&gt; 220.904 eV/c, sigma_pz -&gt; 166.887 eV/c\n...done. Time Elapsed: 1.72217 s.\n\nPrinting 200000 particles to \"rad.gaussian.out.txt\": done. Time ellapsed: 1.93262 s.\n\nBeam stats:\n   avg_x = 0 mm, sigma_x = 2 mm\n   avg_y = 2.06253E-16 mm, sigma_y = 2 mm\n   avg_z = 0 mm, sigma_z = 0 mm\n   avg_px = -5.88382E-16 eV/c, sigma_px = 276.857 eV/c\n   avg_py = -6.79683E-15 eV/c, sigma_py = 276.857 eV/c\n   avg_pz = 220.904 eV/c, sigma_pz = 166.887 eV/c\n   avg_t = -2.04087E-17 ps, sigma_t = 1.1547 ps\n</pre> In\u00a0[4]: Copied! <pre># convert to simple data\nbeam.data()\n</pre> # convert to simple data beam.data() Out[4]: <pre>{'n_particle': 200000,\n 'species': 'electron',\n 'weight': array([5.e-17, 5.e-17, 5.e-17, ..., 5.e-17, 5.e-17, 5.e-17]),\n 'status': array([1, 1, 1, ..., 1, 1, 1]),\n 'x': array([0.00128902, 0.00305076, 0.00214569, ..., 0.00260949, 0.00176679,\n        0.00372237]),\n 'y': array([ 5.14825056e-08,  2.02660913e-07,  2.13199098e-07, ...,\n        -2.34926147e-07, -1.00008370e-07, -1.05941416e-07]),\n 'z': array([0., 0., 0., ..., 0., 0., 0.]),\n 'px': array([ -13.86451651,  129.51065025,  325.33389514, ...,  275.67822102,\n        -388.46055125, -161.11136234]),\n 'py': array([ 173.64325013,  321.97896692, -482.08502038, ...,  250.89066801,\n         486.05742377, -320.26104161]),\n 'pz': array([356.09464955, 242.9422157 , 160.51948115, ..., 162.23391877,\n        245.05703821, 359.35728695]),\n 't': array([-1.40736274e-12, -7.40252999e-14,  1.25931214e-12, ...,\n         9.71015844e-13, -1.25121322e-12,  8.21242174e-14])}</pre> In\u00a0[5]: Copied! <pre>from pmd_beamphysics import ParticleGroup\n</pre> from pmd_beamphysics import ParticleGroup In\u00a0[6]: Copied! <pre>P = ParticleGroup(data = beam.data())\n</pre> P = ParticleGroup(data = beam.data()) In\u00a0[7]: Copied! <pre>P.plot('x', 'y')\n</pre> P.plot('x', 'y') In\u00a0[8]: Copied! <pre># Resample to fewer particles\nP2 = P.resample(10000)\n</pre> # Resample to fewer particles P2 = P.resample(10000) In\u00a0[9]: Copied! <pre>P2.plot('x', 'y')\n</pre> P2.plot('x', 'y') In\u00a0[10]: Copied! <pre># Use the ParticleGroup to write to h5\nP2.write('distgen_particles.h5')\n</pre> # Use the ParticleGroup to write to h5 P2.write('distgen_particles.h5') In\u00a0[11]: Copied! <pre>P2.gamma\n</pre> P2.gamma Out[11]: <pre>array([1.00000003, 1.00000021, 1.00000052, ..., 1.00000056, 1.00000024,\n       1.00000008])</pre> In\u00a0[12]: Copied! <pre>from h5py import File\nwith File('distgen_particles.h5', 'r') as h5:\n    P3 = ParticleGroup(h5)\n</pre> from h5py import File with File('distgen_particles.h5', 'r') as h5:     P3 = ParticleGroup(h5) In\u00a0[13]: Copied! <pre>P3.gamma\n</pre> P3.gamma Out[13]: <pre>array([1.00000003, 1.00000021, 1.00000052, ..., 1.00000056, 1.00000024,\n       1.00000008])</pre> In\u00a0[14]: Copied! <pre># Cleanup\nos.remove('distgen_particles.h5')\nos.remove('rad.gaussian.out.txt')\n</pre> # Cleanup os.remove('distgen_particles.h5') os.remove('rad.gaussian.out.txt') In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/conversion_examples/#examples-on-converting-to-other-formats","title":"Examples on converting to other formats\u00b6","text":""},{"location":"examples/conversion_examples/#openpmd-beamphysics-data","title":"openPMD beamphysics data\u00b6","text":""},{"location":"examples/dist/","title":"Distributions","text":"In\u00a0[1]: Copied! <pre>%load_ext autoreload\n%autoreload 2\n%config InlineBackend.figure_format = 'retina'\n</pre> %load_ext autoreload %autoreload 2 %config InlineBackend.figure_format = 'retina' In\u00a0[2]: Copied! <pre>from distgen.physical_constants import unit_registry\nimport numpy as np\nfrom matplotlib import pyplot as plt\n</pre> from distgen.physical_constants import unit_registry import numpy as np from matplotlib import pyplot as plt <p>To sample various distributions requires generating random numbers and supplying them to the $CDF^{-1}$ functions for each corresponding distribution.  Currently, this is handled using</p> <p><code>distgen.dist.random_generator(shape, sequence, **params)</code>.</p> <p>Here <code>shape = (n_dimension, n_particle)</code> determines the shape of the random numbers returned.  The keyword 'sequence' can be used to set the sequence to Hammerlsey for quasi-random numbers.</p> <p>The difference is shown below:</p> In\u00a0[3]: Copied! <pre>from distgen.dist import random_generator\n\nshape = (2, 100)\n\np1 = random_generator(shape, 'hammersley')\np2 = random_generator(shape, 'pseudo')\n\nfig, ax = plt.subplots(1, 2, constrained_layout=True)\n\nax[0].plot(p1[0,:],p1[1,:],'.');\nax[0].set(xlabel='rx', ylabel='ry', title='hammersley');\n\nax[1].plot(p2[0,:],p2[1,:],'*');\nax[1].set(xlabel='rx', ylabel='ry', title='random.rand');\n</pre> from distgen.dist import random_generator  shape = (2, 100)  p1 = random_generator(shape, 'hammersley') p2 = random_generator(shape, 'pseudo')  fig, ax = plt.subplots(1, 2, constrained_layout=True)  ax[0].plot(p1[0,:],p1[1,:],'.'); ax[0].set(xlabel='rx', ylabel='ry', title='hammersley');  ax[1].plot(p2[0,:],p2[1,:],'*'); ax[1].set(xlabel='rx', ylabel='ry', title='random.rand'); <p>When using pseudo random numbers via NumPy, it is possible to set the generator seed:</p> In\u00a0[4]: Copied! <pre>fig, ax = plt.subplots(1, 1, constrained_layout=True)\n\np2 = random_generator(shape, 'pseudo', seed=0)\np3 = random_generator(shape, 'pseudo', seed=0)\n\nax.plot(p2[0,:],p2[1,:],'*');\nax.plot(p3[0,:],p3[1,:],'.');\nax.set(xlabel='rx', ylabel='ry', title='random.rand');\n</pre> fig, ax = plt.subplots(1, 1, constrained_layout=True)  p2 = random_generator(shape, 'pseudo', seed=0) p3 = random_generator(shape, 'pseudo', seed=0)  ax.plot(p2[0,:],p2[1,:],'*'); ax.plot(p3[0,:],p3[1,:],'.'); ax.set(xlabel='rx', ylabel='ry', title='random.rand'); In\u00a0[5]: Copied! <pre>from distgen import Generator\n</pre> from distgen import Generator In\u00a0[6]: Copied! <pre>gen = Generator('data/jpeg.image.in.rand.yaml', verbose=0)\ngen.input\n</pre> gen = Generator('data/jpeg.image.in.rand.yaml', verbose=0) gen.input Out[6]: <pre>{'n_particle': 1000000,\n 'random': {'type': 'hammersley'},\n 'start': {'MTE': {'value': 150.0, 'units': 'millielectron_volt'},\n  'type': 'cathode'},\n 'total_charge': {'value': 10.0, 'units': 'picocoulomb'},\n 'xy_dist': {'file': '/home/runner/work/distgen/distgen/docs/examples/data/seaturtle.jpeg',\n  'max_x': {'value': 1.0, 'units': 'millimeter'},\n  'max_y': {'value': 1.0, 'units': 'millimeter'},\n  'min_x': {'value': -1.0, 'units': 'millimeter'},\n  'min_y': {'value': -1.0, 'units': 'millimeter'},\n  'threshold': 0.0,\n  'type': 'file2d'},\n 'output': {'type': None},\n 'transforms': None}</pre> In\u00a0[7]: Copied! <pre>gen.run().plot('x', 'y')\n</pre> gen.run().plot('x', 'y') In\u00a0[8]: Copied! <pre>inputs = gen.input.copy()\ninputs['random']={'type': 'pseudo', 'seed':0}\n\ngen = Generator(inputs, verbose=0)\ngen.run().plot('x', 'y')\n</pre> inputs = gen.input.copy() inputs['random']={'type': 'pseudo', 'seed':0}  gen = Generator(inputs, verbose=0) gen.run().plot('x', 'y') In\u00a0[9]: Copied! <pre>from distgen.dist import Uniform\nvar = 'x'\nverbose=1\nparams={'min_x':2*unit_registry('mm'),'max_x':4*unit_registry('mm')}\nuniform = Uniform(var,verbose=verbose,**params)\nuniform.plot_pdf()\nuniform.plot_cdf()\nuniform.test_sampling()\n</pre> from distgen.dist import Uniform var = 'x' verbose=1 params={'min_x':2*unit_registry('mm'),'max_x':4*unit_registry('mm')} uniform = Uniform(var,verbose=verbose,**params) uniform.plot_pdf() uniform.plot_cdf() uniform.test_sampling() <pre>uniform\n      min_x = 2 mm, max_x = 4 mm\n</pre> In\u00a0[10]: Copied! <pre>from distgen.dist import Norm\nvar = 'x'\nverbose=1\nparams={'sigma_x':2*unit_registry('mm'),'avg_x':-1*unit_registry('mm')}\nnorm = Norm(var,verbose=verbose,**params)\nnorm.plot_pdf()\nnorm.plot_cdf()\nnorm.test_sampling()\n</pre> from distgen.dist import Norm var = 'x' verbose=1 params={'sigma_x':2*unit_registry('mm'),'avg_x':-1*unit_registry('mm')} norm = Norm(var,verbose=verbose,**params) norm.plot_pdf() norm.plot_cdf() norm.test_sampling() <pre>Gaussian\n      avg_x = -1 mm, sigma_x = 2.000 mm\n</pre> <p>Below the $N_{\\text{cutoff}}$ parameter is set to cut the distribution symmetrically:</p> In\u00a0[11]: Copied! <pre>from distgen.dist import Norm\nvar = 'x'\nverbose=1\nparams={'sigma_x':2*unit_registry('mm'),'avg_x':0*unit_registry('mm'), 'n_sigma_cutoff':2}\nnorm = Norm(var,verbose=verbose,**params)\nnorm.plot_pdf()\nnorm.plot_cdf()\nnorm.test_sampling()\n</pre> from distgen.dist import Norm var = 'x' verbose=1 params={'sigma_x':2*unit_registry('mm'),'avg_x':0*unit_registry('mm'), 'n_sigma_cutoff':2} norm = Norm(var,verbose=verbose,**params) norm.plot_pdf() norm.plot_cdf() norm.test_sampling() <pre>Gaussian\n      avg_x = 0 mm, sigma_x = 2.000 mm\n      Left n_sigma_cutoff = 2, Right n_sigma_cutoff = -2\n</pre> <p>The distribution can be truncated asymmetrically using the $N_{\\text{cutoff},R}$ and $N_{\\text{cutoff},L}$ parameters, as shown below.  Note in this case, it is only required that $N_{\\text{cutoff},L} &lt; N_{\\text{cutoff},R}$, allowing for completley arbtitray location of the truncation points.  This requires a minus sign for the cut off parameters for truncation values less than zero.</p> In\u00a0[12]: Copied! <pre>from distgen.dist import Norm\nparams={'sigma_x':2*unit_registry('mm'),\n        'avg_x':0*unit_registry('mm'), \n        'n_sigma_cutoff_left':-1.5,\n        'n_sigma_cutoff_right':1}\n\nnorm = Norm('x',verbose=1,**params)\nnorm.plot_pdf()\nnorm.plot_cdf()\nnorm.test_sampling()\n</pre> from distgen.dist import Norm params={'sigma_x':2*unit_registry('mm'),         'avg_x':0*unit_registry('mm'),          'n_sigma_cutoff_left':-1.5,         'n_sigma_cutoff_right':1}  norm = Norm('x',verbose=1,**params) norm.plot_pdf() norm.plot_cdf() norm.test_sampling() <pre>Gaussian\n      avg_x = 0 mm, sigma_x = 2.000 mm\n      Left n_sigma_cutoff = 1, Right n_sigma_cutoff = -1.5\n</pre> In\u00a0[13]: Copied! <pre>from distgen.dist import SuperGaussian\n\nps = [0.5, 1 , 5, float('Inf')]\nalphas = [0, 0.25, 0.5, 1]\n\nfig, (ax1, ax2) = plt.subplots(1, 2,\n                               sharex='col',\n                               figsize=(12,4),\n                               constrained_layout=True)\n\nplegs = ['p = '+str(p) for p in ps]\nalegs = ['$\\\\alpha$ = '+str(a) for a in alphas]\n\nfor ii,p in enumerate(ps):\n    pparams = {'lambda':2*unit_registry('mm'),\n              'p':p*unit_registry('dimensionless'),}\n    \n    supG = SuperGaussian('x',verbose=0,**pparams)\n    x = supG.get_x_pts(1000)\n    rho = supG.pdf(x)\n    ax1.plot(x,rho);\n    \n    a=alphas[ii]\n    aparams = {'lambda':2*unit_registry('mm'),\n              'alpha':a*unit_registry('dimensionless'),}\n    \n    x = np.linspace(-3*aparams['lambda'], 3*aparams['lambda'],100)\n    supG = SuperGaussian('x',verbose=0,**aparams)\n    rho = supG.pdf(x)\n    ax2.plot(x,rho);\n    \nax1.set_xlabel('x (mm)');    ax2.set_xlabel('x (mm)');\nax1.set_ylabel('pdf (1/mm)');ax2.set_ylabel('pdf (1/mm)');\nax1.legend(plegs);           ax2.legend(alegs);\n</pre> from distgen.dist import SuperGaussian  ps = [0.5, 1 , 5, float('Inf')] alphas = [0, 0.25, 0.5, 1]  fig, (ax1, ax2) = plt.subplots(1, 2,                                sharex='col',                                figsize=(12,4),                                constrained_layout=True)  plegs = ['p = '+str(p) for p in ps] alegs = ['$\\\\alpha$ = '+str(a) for a in alphas]  for ii,p in enumerate(ps):     pparams = {'lambda':2*unit_registry('mm'),               'p':p*unit_registry('dimensionless'),}          supG = SuperGaussian('x',verbose=0,**pparams)     x = supG.get_x_pts(1000)     rho = supG.pdf(x)     ax1.plot(x,rho);          a=alphas[ii]     aparams = {'lambda':2*unit_registry('mm'),               'alpha':a*unit_registry('dimensionless'),}          x = np.linspace(-3*aparams['lambda'], 3*aparams['lambda'],100)     supG = SuperGaussian('x',verbose=0,**aparams)     rho = supG.pdf(x)     ax2.plot(x,rho);      ax1.set_xlabel('x (mm)');    ax2.set_xlabel('x (mm)'); ax1.set_ylabel('pdf (1/mm)');ax2.set_ylabel('pdf (1/mm)'); ax1.legend(plegs);           ax2.legend(alegs); <p>To set the length scale of the distribution, the user must either supply 'sigma_[var]' or 'lambda'. See usage below:</p> In\u00a0[14]: Copied! <pre>params = {'sigma_x':2*unit_registry('mm'),\n          #'alpha': 0.75*unit_registry('dimensionless'),\n           'alpha': 0.003*unit_registry('dimensionless'),\n          'avg_x':0.25*unit_registry('mm')}\n\nsupG = SuperGaussian('x',verbose=1,**params)\nsupG.plot_pdf()\nsupG.plot_cdf()\nsupG.test_sampling()\n</pre> params = {'sigma_x':2*unit_registry('mm'),           #'alpha': 0.75*unit_registry('dimensionless'),            'alpha': 0.003*unit_registry('dimensionless'),           'avg_x':0.25*unit_registry('mm')}  supG = SuperGaussian('x',verbose=1,**params) supG.plot_pdf() supG.plot_cdf() supG.test_sampling() <pre>Super Gaussian\n      sigma_x = 2 mm, power = 333.333\n</pre> <p>Disgten supports importing a 1D PDF saved in column form in.  The input form of the file should have space separated headers such as $x$ and $Px$, with corresponding column data below it.  The PDF is normalized numerically using the numpy.trapz numerical integration routine. The CDF is computed using the scipy.cumtrapz cumulative numerical intgration routine.</p> <p>The following example shows a gaussian PDF with cuts added to it.</p> In\u00a0[15]: Copied! <pre>from distgen.dist import File1d\nvar = 't'\nverbose=1\nparams={'file':'../examples/data/cutgauss.1d.txt','units':'ps'}\nfile1d = File1d(var,verbose=verbose,**params)\nfile1d.plot_pdf()\nfile1d.plot_cdf()\nfile1d.test_sampling()\n</pre> from distgen.dist import File1d var = 't' verbose=1 params={'file':'../examples/data/cutgauss.1d.txt','units':'ps'} file1d = File1d(var,verbose=verbose,**params) file1d.plot_pdf() file1d.plot_cdf() file1d.test_sampling() <pre>t-distribution file: \"../examples/data/cutgauss.1d.txt\"\n</pre> In\u00a0[16]: Copied! <pre>from distgen.dist import TemporalLaserPulseStacking\nverbose=1\nparams={'crystal_length_1': 15.096*unit_registry('mm'),\n        'crystal_length_2': 7.548*unit_registry('mm'), \n        'crystal_length_3': 3.774*unit_registry('mm'), \n        'crystal_length_4': 1.887*unit_registry('mm'), \n        'crystal_angle_1':  0.6*unit_registry('deg'), \n        'crystal_angle_2':  1.8*unit_registry('deg'), \n        'crystal_angle_3': -0.9*unit_registry('deg'),  \n        'crystal_angle_4': -0.5*unit_registry('deg'), }\n    \nlaser_pulse = TemporalLaserPulseStacking(verbose=verbose,**params)\nlaser_pulse.plot_pdf()\nlaser_pulse.plot_cdf()\nlaser_pulse.test_sampling()\n</pre> from distgen.dist import TemporalLaserPulseStacking verbose=1 params={'crystal_length_1': 15.096*unit_registry('mm'),         'crystal_length_2': 7.548*unit_registry('mm'),          'crystal_length_3': 3.774*unit_registry('mm'),          'crystal_length_4': 1.887*unit_registry('mm'),          'crystal_angle_1':  0.6*unit_registry('deg'),          'crystal_angle_2':  1.8*unit_registry('deg'),          'crystal_angle_3': -0.9*unit_registry('deg'),           'crystal_angle_4': -0.5*unit_registry('deg'), }      laser_pulse = TemporalLaserPulseStacking(verbose=verbose,**params) laser_pulse.plot_pdf() laser_pulse.plot_cdf() laser_pulse.test_sampling() <pre>crystal temporal laser shaping\n      crystal 1 length = 15.096 mm, angle = 0.6 deg\n      crystal 2 length = 7.548 mm, angle = 1.8 deg\n      crystal 3 length = 3.774 mm, angle = -0.9 deg\n      crystal 4 length = 1.887 mm, angle = -0.5 deg\n      Pulses propagated: min t = -23.9053 ps, max t = 23.9053 ps\n</pre> In\u00a0[17]: Copied! <pre>from distgen.dist import Tukey\nvar = 'y'\nverbose=1\nparams={'length':2*unit_registry('mm'),'ratio':0.75*unit_registry('dimensionless')}\ntukey = Tukey(var,verbose=1,**params)\ntukey.plot_pdf()\ntukey.plot_cdf()\ntukey.test_sampling()\n</pre> from distgen.dist import Tukey var = 'y' verbose=1 params={'length':2*unit_registry('mm'),'ratio':0.75*unit_registry('dimensionless')} tukey = Tukey(var,verbose=1,**params) tukey.plot_pdf() tukey.plot_cdf() tukey.test_sampling() <pre>Tukey\n      length = 2 mm, ratio = 0.75\n</pre> In\u00a0[18]: Copied! <pre>from distgen.dist import Superposition\n\nparams = {\n    'dists':{\n        'd1':{\n            'avg_z':-1*unit_registry('mm'),\n            'sigma_z':1*unit_registry('mm'),\n            'type': 'gaussian'\n        } ,\n        'd2':{\n            'avg_z':+1*unit_registry('mm'),\n            'sigma_z':1*unit_registry('mm'),\n            'type': 'gaussian'\n        } \n    }\n}\n\nsup = Superposition('z', 1, **params)\nsup.plot_pdf()\nsup.plot_cdf()\nsup.test_sampling()\n</pre> from distgen.dist import Superposition  params = {     'dists':{         'd1':{             'avg_z':-1*unit_registry('mm'),             'sigma_z':1*unit_registry('mm'),             'type': 'gaussian'         } ,         'd2':{             'avg_z':+1*unit_registry('mm'),             'sigma_z':1*unit_registry('mm'),             'type': 'gaussian'         }      } }  sup = Superposition('z', 1, **params) sup.plot_pdf() sup.plot_cdf() sup.test_sampling() <pre>superpostion\n      1. distribution name: d1, type: Gaussian\n         avg_z = -1 mm, sigma_z = 1.000 mm\n      2. distribution name: d2, type: Gaussian\n         avg_z = 1 mm, sigma_z = 1.000 mm\n</pre> In\u00a0[19]: Copied! <pre>from distgen.dist import MaxwellBoltzmannDist\n\nparams = {'scale_p': 10*unit_registry('eV/c')}\n\nmb = MaxwellBoltzmannDist('p', verbose=0, **params)\n\nmb.plot_pdf()\nmb.plot_cdf()\nmb.test_sampling()\n</pre> from distgen.dist import MaxwellBoltzmannDist  params = {'scale_p': 10*unit_registry('eV/c')}  mb = MaxwellBoltzmannDist('p', verbose=0, **params)  mb.plot_pdf() mb.plot_cdf() mb.test_sampling() In\u00a0[20]: Copied! <pre>from distgen.dist import UniformRad\nverbose=1\nparams={'min_r':1*unit_registry('mm'),'max_r':2*unit_registry('mm')}\nurad = UniformRad(verbose=1,**params)\nurad.plot_pdf()\nurad.plot_cdf()\nurad.test_sampling()\n</pre> from distgen.dist import UniformRad verbose=1 params={'min_r':1*unit_registry('mm'),'max_r':2*unit_registry('mm')} urad = UniformRad(verbose=1,**params) urad.plot_pdf() urad.plot_cdf() urad.test_sampling() <pre>radial uniform\n      min_r = 1 mm, max_r = 2 mm\n</pre> In\u00a0[21]: Copied! <pre>from distgen.dist import NormRad\nverbose=1\nparams={'sigma_xy':1*unit_registry('mm')}\nnrad = NormRad(verbose=1,**params)\nnrad.plot_pdf()\nnrad.plot_cdf()\nnrad.test_sampling()\n</pre> from distgen.dist import NormRad verbose=1 params={'sigma_xy':1*unit_registry('mm')} nrad = NormRad(verbose=1,**params) nrad.plot_pdf() nrad.plot_cdf() nrad.test_sampling() <pre>radial Gaussian\n</pre> <p>For laser scientists it can be convenient to to work with a pinhole radius and a fraction of the laser intensity to clip a transverse normal laser mode at.  In this case the user can supply a truncation radius ($=r_R$) and a truncation fraction $f = \\exp\\left(-\\frac{r_R^2}{2\\sigma}\\right)$ from which distgen determines the underlying $\\sigma$.  The example below demonstrates this usage:</p> In\u00a0[22]: Copied! <pre>from distgen.dist import NormRad\nverbose=1\nparams={'truncation_radius':1*unit_registry('mm'),'truncation_fraction':0.5*unit_registry('dimensionless')}\nnrad = NormRad(verbose=1,**params)\nnrad.plot_pdf()\nnrad.plot_cdf()\nnrad.test_sampling()\n</pre> from distgen.dist import NormRad verbose=1 params={'truncation_radius':1*unit_registry('mm'),'truncation_fraction':0.5*unit_registry('dimensionless')} nrad = NormRad(verbose=1,**params) nrad.plot_pdf() nrad.plot_cdf() nrad.test_sampling() <pre>radial Gaussian\n</pre> In\u00a0[23]: Copied! <pre>from distgen.dist import NormRad\nverbose=1\nparams={'sigma_xy':2*unit_registry('mm'),'n_sigma_cutoff':1}\nnrad = NormRad(verbose=1,**params)\nnrad.plot_pdf()\nnrad.plot_cdf()\nnrad.test_sampling()\n</pre> from distgen.dist import NormRad verbose=1 params={'sigma_xy':2*unit_registry('mm'),'n_sigma_cutoff':1} nrad = NormRad(verbose=1,**params) nrad.plot_pdf() nrad.plot_cdf() nrad.test_sampling() <pre>radial Gaussian\n</pre> In\u00a0[24]: Copied! <pre>from distgen.dist import TukeyRad\nverbose=1\nparams={'length':1*unit_registry('mm'),'ratio':0.75*unit_registry('dimensionless')}\nrtukey = TukeyRad(verbose=1,**params)\nrtukey.plot_pdf()\nrtukey.plot_cdf()\nrtukey.test_sampling()\n</pre> from distgen.dist import TukeyRad verbose=1 params={'length':1*unit_registry('mm'),'ratio':0.75*unit_registry('dimensionless')} rtukey = TukeyRad(verbose=1,**params) rtukey.plot_pdf() rtukey.plot_cdf() rtukey.test_sampling() <pre>TukeyRad\n      legnth = 1.000 mm, ratio = 0.750\n</pre> In\u00a0[25]: Copied! <pre>from distgen.dist import SuperGaussianRad\nverbose=1\nparams={'sigma_xy':1*unit_registry('mm'),\n        'alpha':0.50*unit_registry('dimensionless')}\nsupG = SuperGaussianRad(verbose=1,**params)\nsupG.plot_pdf()\nsupG.plot_cdf()\nsupG.test_sampling()\n</pre> from distgen.dist import SuperGaussianRad verbose=1 params={'sigma_xy':1*unit_registry('mm'),         'alpha':0.50*unit_registry('dimensionless')} supG = SuperGaussianRad(verbose=1,**params) supG.plot_pdf() supG.plot_cdf() supG.test_sampling() <pre>SuperGaussianRad\n      lambda = 1.33134 mm, power = 2\n</pre> In\u00a0[26]: Copied! <pre>from distgen.dist import RadFile\n\nparams = {'file':'../examples/data/cutgauss.rad.txt','units':'mm'}\n\nrfd = RadFile(verbose=1, **params)\nrfd.plot_pdf()\nrfd.plot_cdf()\nrfd.test_sampling()\n</pre> from distgen.dist import RadFile  params = {'file':'../examples/data/cutgauss.rad.txt','units':'mm'}  rfd = RadFile(verbose=1, **params) rfd.plot_pdf() rfd.plot_cdf() rfd.test_sampling() <pre>radial file\n      r-dist file: \"../examples/data/cutgauss.rad.txt\"\n</pre>"},{"location":"examples/dist/#distributions","title":"Distributions\u00b6","text":""},{"location":"examples/dist/#random-number-generation","title":"Random Number Generation\u00b6","text":""},{"location":"examples/dist/#1d-distributions","title":"1D Distributions\u00b6","text":"<p>Distgen supports several one dimensional distribution types.</p>"},{"location":"examples/dist/#uniform-1d","title":"Uniform 1D\u00b6","text":"<p>The uniform distirbuition is defined by a probability distribution function:</p> <p>$\\rho(x) = \\frac{1}{b-a}$ for $a\\leq x\\leq b$ and zero elsewhere.</p> <p>The corresponding CDF is</p> <p>$P(x) = \\frac{x-a}{b-a}$ for $a\\leq x\\leq b$ and zero elsewhere.</p> <p>The first and second moments of this distribution are:</p> <p>$\\langle x \\rangle = \\frac{1}{2}(a+b)$ and $\\sigma_x = \\frac{b-a}{\\sqrt{12}}$</p>"},{"location":"examples/dist/#normal-distribution-including-truncation","title":"Normal Distribution (including truncation)\u00b6","text":"<p>The general form of a normal distribution PDF with truncation is given by</p> <p>$\\rho(x) = \\frac{1}{\\sigma}\\frac{\\phi\\left(\\frac{x-\\mu}{\\sigma}\\right)}{\\Phi\\left(\\frac{b-\\mu}{\\sigma}\\right)-\\Phi\\left(\\frac{a-\\mu}{\\sigma}\\right)}$.</p> <p>In this expression $\\phi(\\xi) = \\frac{1}{\\sqrt{2\\pi}}e^{-\\frac{1}{2}\\xi^2}$ is the canonical normal distribution, $\\Phi(\\xi) = \\frac{1}{2}\\left[1 + \\text{erf}\\left(\\frac{\\xi}{\\sqrt{2}}\\right) \\right]$ is the canonical normal CDF, and $a=-N_{\\text{cutoff}}\\cdot\\sigma$ and $b=-N_{\\text{cutoff}}\\cdot\\sigma$ are the left and right truncation points.  The CDF if given by</p> <p>$P(x) = \\frac{\\Phi\\left(\\frac{x-\\mu}{\\sigma}\\right) - \\Phi\\left(\\frac{a-\\mu}{\\sigma}\\right)}{\\Phi\\left(\\frac{b-\\mu}{\\sigma}\\right)-\\Phi\\left(\\frac{a-\\mu}{\\sigma}\\right)}$.</p> <p>Defining $\\alpha = \\frac{a-\\mu}{\\sigma}$ and $\\beta = \\frac{b-\\mu}{\\sigma}$, the first and second moments of the distribution are:</p> <p>$\\langle x\\rangle = \\mu + \\frac{\\phi\\left(\\alpha\\right) - \\phi\\left(\\beta\\right)}{\\Phi\\left(\\beta\\right)-\\Phi\\left(\\alpha\\right)}\\sigma$ and $\\sigma_x = \\sigma \\left\\{1 + \\frac{\\alpha\\phi\\left(\\alpha\\right) - \\beta\\phi(\\beta) }{\\Phi(\\beta) - \\Phi(\\alpha)} - \\left(\\frac{\\phi\\left(\\alpha\\right) - \\phi(\\beta)}{\\Phi(\\beta) - \\Phi(\\alpha)}\\right)^{2} \\right\\}^{1/2} $.</p> <p>When using this distribution, if the $N_{\\text{cutoff}}$ is not set then the distribution reduces to an infinite range normal distribution, as first shown below:</p>"},{"location":"examples/dist/#super-gaussian","title":"Super Gaussian\u00b6","text":"<p>In additional to the regular Gaussian function, it is also possible to sample a super-Gaussian distribution defined by</p> <p>$\\rho(x; \\lambda, p) = \\frac{1}{2\\sqrt{2}\\Gamma\\left(1+\\frac{1}{2p}\\right)\\lambda } \\exp\\left[-\\left(\\frac{(x-\\mu)^2 }{2\\lambda^2}\\right)^{p}\\right]$</p> <p>Here $\\sigma_1$ is the length scale and $p$ is the power of the super-Gaussian. Note when $p=1$ reduces to a Normal distirbution, in which case $\\sigma_x=\\lambda$.  As $p\\rightarrow\\infty$ the distribution reduces to a flat-top (uniform). The full range of powers is given by $p\\in\\left(0,\\infty\\right]$.</p> <p>The first and second moments of the distribution are given by:</p> <p>$\\langle x\\rangle = \\mu$, and $\\sigma_x = \\left(\\frac{2\\Gamma\\left(1+\\frac{3}{2p}\\right)}{3\\Gamma\\left(1+\\frac{1}{2p}\\right)}\\right)^{1/2}\\lambda$.</p> <p>Often, it is convenient to scan the distribution from the uniform limit to the Gaussian limit.  To do some, the input $p$ can be parameterized by $\\alpha\\in[0,1]$ where $p = 1/\\alpha$.  Here $\\alpha=0$ corresponds to a flat-top (uniform) and $\\alpha=1$ corresponds to a Gaussian.  Examples of both types of usage are shown below.</p>"},{"location":"examples/dist/#1d-pdf-from-a-file","title":"1D PDF from a file\u00b6","text":""},{"location":"examples/dist/#laser-pulse-stacking","title":"Laser pulse stacking\u00b6","text":""},{"location":"examples/dist/#tukey-1d","title":"Tukey 1D\u00b6","text":""},{"location":"examples/dist/#superposition-1d","title":"Superposition 1D\u00b6","text":""},{"location":"examples/dist/#maxwell-boltzmann-distribution","title":"Maxwell-Boltzmann Distribution\u00b6","text":""},{"location":"examples/dist/#radial-distributions","title":"Radial Distributions\u00b6","text":""},{"location":"examples/dist/#radial-normal-distribution-with-truncation","title":"Radial Normal Distribution (with truncation)\u00b6","text":"<p>The radial normal distribution including truncation(s) has a probability function given by</p> <p>$\\rho_r(r) = \\frac{1}{\\sigma^2}\\frac{\\phi(r/\\sigma)}{\\phi\\left(\\frac{r_L}{\\sigma}\\right)-\\phi\\left(\\frac{r_R}{\\sigma}\\right)} $ for $0 \\leq r_L \\leq r \\leq r_R$ and zero everywhere else.</p> <p>In this expresion $\\phi(\\xi) = \\frac{1}{2\\pi}\\exp\\left(-\\xi^2/2\\right)$ is the canonical raidial normal distirbution (no truncation), and the scale parameter $\\sigma$ follows from the product of two normal distributions in $x$ and $y$ when $\\sigma=\\sigma_x=\\sigma_y$.  The corresponding CDF is given by</p> <p>$P(r)= \\frac{\\phi\\left(\\frac{r_L}{\\sigma}\\right)-\\phi\\left(\\frac{r}{\\sigma}\\right)}{\\phi\\left(\\frac{r_L}{\\sigma}\\right)-\\phi\\left(\\frac{r_R}{\\sigma}\\right)} $ for $0 \\leq r_L \\leq r$.</p> <p>The corresponding first and second moments are:</p> <p>$\\langle r\\rangle = \\frac{\\frac{r_L}{\\sigma}\\phi\\left(\\frac{r_L}{\\sigma}\\right) -\\frac{r_R}{\\sigma}\\phi\\left(\\frac{r_R}{\\sigma}\\right) +\\frac{1}{2\\sqrt{2\\pi}}\\left( \\text{erf}\\left(\\frac{r_R}{\\sigma\\sqrt{2}}\\right) - \\text{erf}\\left(\\frac{r_L}{\\sigma\\sqrt{2}}\\right) \\right)  } {\\phi\\left(\\frac{r_L}{\\sigma}\\right)-\\phi\\left(\\frac{r_R}{\\sigma}\\right)}$,</p> <p>$r_{rms} = \\sqrt{ 2\\sigma^2 + r_L^2 - \\frac{(r_R^2-r_L^2)\\phi(r_R/\\sigma)}{\\phi\\left(\\frac{r_L}{\\sigma}\\right)-\\phi\\left(\\frac{r_R}{\\sigma}\\right)} }$.</p> <p>Note that in the limits $r_L\\rightarrow 0$ and $r_R -&gt; \\infty$ the above expressions reduce to the underlying radial normal distribution:</p> <p>$\\rho_r(r)\\rightarrow \\frac{\\phi\\left(\\frac{r}{\\sigma}\\right)}{\\sigma^2}$, $P(r)\\rightarrow 1 - \\phi\\left(\\frac{r}{\\sigma}\\right)$, $\\langle r\\rangle\\rightarrow \\sqrt{\\frac{\\pi}{2}}\\sigma$, and $r_{rms}\\rightarrow \\sqrt{2}\\sigma$.  This limiting case is shown first below.</p>"},{"location":"examples/dist/#radial-tukey","title":"Radial Tukey\u00b6","text":""},{"location":"examples/dist/#radial-super-gaussian","title":"Radial Super Gaussian\u00b6","text":"<p>This implements a radial version of the Super Gaussian function discussed above.  Here the radial function takes the form:</p> <p>$2\\pi\\rho(r;\\lambda,p) = \\frac{1}{\\Gamma\\left(1+\\frac{1}{p}\\right)\\lambda^2} \\exp\\left[-\\left(\\frac{r^2}{2\\lambda^2}\\right)^p\\right]$. The corrsponding CDF is: ?</p> <p>The first and (rms) second moment of the distribution are given by:</p> <p>$\\langle r\\rangle = \\frac{2\\sqrt{2}}{3}\\frac{\\Gamma\\left(1+\\frac{3}{2p}\\right)}{\\Gamma\\left(1+\\frac{1}{p}\\right)}\\lambda$,</p> <p>$r_{\\text{rms}} = \\sqrt{\\frac{\\Gamma\\left(1+\\frac{2}{p}\\right)}{\\Gamma\\left(1+\\frac{1}{p}\\right)}}\\lambda$.</p>"},{"location":"examples/dist/#radial-file-distribution","title":"Radial File Distribution\u00b6","text":""},{"location":"examples/dist/#angular-distributions-todo","title":"Angular Distributions (TODO)\u00b6","text":"<p>Angular distributions define one dimensional probability functions for the cylindrical variable $\\theta$.</p>"},{"location":"examples/example_dists/","title":"Radial Distributions","text":"In\u00a0[1]: Copied! <pre># Useful for debugging\n%load_ext autoreload\n%autoreload 2\n%config InlineBackend.figure_format = 'retina'\n</pre> # Useful for debugging %load_ext autoreload %autoreload 2 %config InlineBackend.figure_format = 'retina' In\u00a0[2]: Copied! <pre>from distgen import Generator\nfrom distgen.plot import plot_dist2d, plot_dist1d, plot_current_profile\nfrom distgen.physical_constants import unit_registry\n\nfrom matplotlib import pyplot as plt\nimport os\nimport yaml\n\nfrom pprint import pprint\n</pre> from distgen import Generator from distgen.plot import plot_dist2d, plot_dist1d, plot_current_profile from distgen.physical_constants import unit_registry  from matplotlib import pyplot as plt import os import yaml  from pprint import pprint In\u00a0[3]: Copied! <pre>gen = Generator(verbose=0) \nunits = {'x':'mm', 'y':'mm', 'z':'mm', 'px':'keV/c', 'py':'keV/c', 't':'ps', 'q':'pC', 'I':'A'}\n</pre> gen = Generator(verbose=0)  units = {'x':'mm', 'y':'mm', 'z':'mm', 'px':'keV/c', 'py':'keV/c', 't':'ps', 'q':'pC', 'I':'A'} In\u00a0[4]: Copied! <pre>gen=Generator('data/rad.uniform.in.yaml',verbose=0)\ngen['r_dist:min_r']=0\nprint('\\nYAML input:')\nprint(yaml.dump({'r_dist':gen.input['r_dist']}))\n\nplot_dist2d(gen.beam(), 'x', units['x'], 'y', units['y'], axis='equal', title_on=True);\n</pre> gen=Generator('data/rad.uniform.in.yaml',verbose=0) gen['r_dist:min_r']=0 print('\\nYAML input:') print(yaml.dump({'r_dist':gen.input['r_dist']}))  plot_dist2d(gen.beam(), 'x', units['x'], 'y', units['y'], axis='equal', title_on=True); <pre>\nYAML input:\nr_dist:\n  max_r:\n    units: millimeter\n    value: 2\n  min_r:\n    units: millimeter\n    value: 0\n  type: radial_uniform\n\n</pre> In\u00a0[5]: Copied! <pre>gen=Generator('data/rad.uniform.in.yaml', verbose=0)\n\nprint('\\nYAML input:')\nprint(yaml.dump({'r_dist':gen.input['r_dist']}))\n\nplot_dist2d(gen.beam(), 'x', units['x'], 'y', units['y'], axis='equal', title_on=True);\n</pre> gen=Generator('data/rad.uniform.in.yaml', verbose=0)  print('\\nYAML input:') print(yaml.dump({'r_dist':gen.input['r_dist']}))  plot_dist2d(gen.beam(), 'x', units['x'], 'y', units['y'], axis='equal', title_on=True); <pre>\nYAML input:\nr_dist:\n  max_r:\n    units: millimeter\n    value: 2\n  min_r:\n    units: millimeter\n    value: 1\n  type: radial_uniform\n\n</pre> In\u00a0[6]: Copied! <pre># Radial gaussian distribution with sigma_xy 2 mm\ngen=Generator('data/rad.gaussian.in.yaml',verbose=0)\n\nprint('\\nYAML input:')\nprint(yaml.dump({'r_dist':gen.input['r_dist']}))\n\n# X-Y Plot\nplot_dist2d(gen.beam(), 'x', units['x'], 'y', units['y'], axis='equal', title_on=True);\n</pre> # Radial gaussian distribution with sigma_xy 2 mm gen=Generator('data/rad.gaussian.in.yaml',verbose=0)  print('\\nYAML input:') print(yaml.dump({'r_dist':gen.input['r_dist']}))  # X-Y Plot plot_dist2d(gen.beam(), 'x', units['x'], 'y', units['y'], axis='equal', title_on=True); <pre>\nYAML input:\nr_dist:\n  sigma_xy:\n    units: millimeter\n    value: 2\n  type: radial_gaussian\n\n</pre> <p>Example 2: Truncated Gaussian with a pinhole radius of 1 mm, clipped at 50% intensity</p> In\u00a0[7]: Copied! <pre># Truncated radial gaussian distribution with pihole diameter of 2 mm, gaussian clipped at 50% intensity\ngen=Generator('data/rad.trunc.gaussian.in.yaml',verbose=0)\n\nprint('\\nYAML input:')\nprint(yaml.dump({'r_dist':gen.input['r_dist']}))\n\n# X-Y Plot\nplot_dist2d(gen.beam(), 'x', units['x'], 'y',units['y'], axis='equal', title_on=True);\n</pre> # Truncated radial gaussian distribution with pihole diameter of 2 mm, gaussian clipped at 50% intensity gen=Generator('data/rad.trunc.gaussian.in.yaml',verbose=0)  print('\\nYAML input:') print(yaml.dump({'r_dist':gen.input['r_dist']}))  # X-Y Plot plot_dist2d(gen.beam(), 'x', units['x'], 'y',units['y'], axis='equal', title_on=True); <pre>\nYAML input:\nr_dist:\n  truncation_fraction:\n    units: dimensionless\n    value: 0.5\n  truncation_radius:\n    units: millimeter\n    value: 1\n  type: rg\n\n</pre> <p>Example 3: truncated Gaussian using underlying $\\sigma_{x,y}$ = 2 mm and n_sigma_cutoff = 1</p> In\u00a0[8]: Copied! <pre># Radial gaussian distribution with cut using n_sigma_cutoff\ngen=Generator('data/rad.gaussian.in.yaml', verbose=0)\ngen['r_dist:n_sigma_cutoff']=1\n\nprint(\"\\nYAML input:\")\nprint(yaml.dump({'r_dist':gen.input['r_dist']}))\n\n# X-Y Plot\nplot_dist2d(gen.beam(), 'x', units['x'], 'y', units['y'], axis='equal', title_on=True);\n</pre> # Radial gaussian distribution with cut using n_sigma_cutoff gen=Generator('data/rad.gaussian.in.yaml', verbose=0) gen['r_dist:n_sigma_cutoff']=1  print(\"\\nYAML input:\") print(yaml.dump({'r_dist':gen.input['r_dist']}))  # X-Y Plot plot_dist2d(gen.beam(), 'x', units['x'], 'y', units['y'], axis='equal', title_on=True); <pre>\nYAML input:\nr_dist:\n  n_sigma_cutoff: 1\n  sigma_xy:\n    units: millimeter\n    value: 2\n  type: radial_gaussian\n\n</pre> In\u00a0[9]: Copied! <pre># Radial distribution file: a radial gaussian with cuts in it\ngen=Generator('data/rad.file.in.yaml', verbose=0)\n\nprint('\\nYAML input:')\nprint(yaml.dump({'r_dist':gen.input['r_dist']}))\n\n# X-Y Plot\nplot_dist2d(gen.beam(), 'x', units['x'], 'y', units['y'], axis='equal');\n</pre> # Radial distribution file: a radial gaussian with cuts in it gen=Generator('data/rad.file.in.yaml', verbose=0)  print('\\nYAML input:') print(yaml.dump({'r_dist':gen.input['r_dist']}))  # X-Y Plot plot_dist2d(gen.beam(), 'x', units['x'], 'y', units['y'], axis='equal'); <pre>\nYAML input:\nr_dist:\n  file: /home/runner/work/distgen/distgen/docs/examples/data/cutgauss.rad.txt\n  type: radfile\n  units: mm\n\n</pre> In\u00a0[10]: Copied! <pre># Radial Tukey distribution\ngen=Generator('data/tukey.beer.can.in.yaml',verbose=0)\n\nprint('\\nYAML Input:')\nprint(yaml.dump({'r_dist':gen.input['r_dist']}))\n\nplot_dist2d(gen.beam(), 'x', units['x'], 'y', units['y'], axis='equal', title_on=True);\n</pre> # Radial Tukey distribution gen=Generator('data/tukey.beer.can.in.yaml',verbose=0)  print('\\nYAML Input:') print(yaml.dump({'r_dist':gen.input['r_dist']}))  plot_dist2d(gen.beam(), 'x', units['x'], 'y', units['y'], axis='equal', title_on=True); <pre>\nYAML Input:\nr_dist:\n  length:\n    units: millimeter\n    value: 5\n  ratio:\n    units: dimensionless\n    value: 0.25\n  type: radial_tukey\n\n</pre> In\u00a0[11]: Copied! <pre>gen=Generator('data/SG.beer.can.in.yaml',verbose=0)\n\nprint(\"\\nYAML Input:\")\nprint(yaml.dump({'r_dist':gen.input['r_dist']}))\n\nplot_dist2d(gen.beam(), 'x', units['x'], 'y', units['y'], axis='equal', title_on=True);\n</pre> gen=Generator('data/SG.beer.can.in.yaml',verbose=0)  print(\"\\nYAML Input:\") print(yaml.dump({'r_dist':gen.input['r_dist']}))  plot_dist2d(gen.beam(), 'x', units['x'], 'y', units['y'], axis='equal', title_on=True); <pre>\nYAML Input:\nr_dist:\n  alpha:\n    units: dimensionless\n    value: 0\n  sigma_xy:\n    units: millimeter\n    value: 1\n  type: rsg\n\n</pre> <p>Example 2: Gaussian limit (power = 1): $\\sigma_{x,y}$ = 1 mm</p> In\u00a0[12]: Copied! <pre>gen=Generator('data/SG.beer.can.in.yaml',verbose=0)\ngen['r_dist:alpha']=1.0\n\nprint('\\nYAML Input:')\nprint(yaml.dump({'r_dist':gen.input['r_dist']}))\n\nplot_dist2d(gen.beam(), 'x', units['x'], 'y', units['y'], axis='equal', title_on=True);\n</pre> gen=Generator('data/SG.beer.can.in.yaml',verbose=0) gen['r_dist:alpha']=1.0  print('\\nYAML Input:') print(yaml.dump({'r_dist':gen.input['r_dist']}))  plot_dist2d(gen.beam(), 'x', units['x'], 'y', units['y'], axis='equal', title_on=True); <pre>\nYAML Input:\nr_dist:\n  alpha:\n    units: dimensionless\n    value: 1.0\n  sigma_xy:\n    units: millimeter\n    value: 1\n  type: rsg\n\n</pre> <p>Example 3: sub-Gaussian (power &lt; 1): $\\sigma_{x,y} = 1$ mm, $p$ = 0.5</p> In\u00a0[13]: Copied! <pre>with open('data/SG.beer.can.in.yaml', 'r') as fid:\n    inputs = yaml.safe_load(fid)\n    \ndel inputs['r_dist']['alpha']\ninputs['r_dist']['p'] = {'value':0.5,'units':''}\n    \ngen=Generator(inputs, verbose=0)\n\nprint(\"\\nYAML Input:\")\nprint(yaml.dump({'r_dist':gen.input[\"r_dist\"]}))\n\nplot_dist2d(gen.beam(), 'x', units['x'], 'y', units['y'], axis=\"equal\", title_on=True);\n</pre> with open('data/SG.beer.can.in.yaml', 'r') as fid:     inputs = yaml.safe_load(fid)      del inputs['r_dist']['alpha'] inputs['r_dist']['p'] = {'value':0.5,'units':''}      gen=Generator(inputs, verbose=0)  print(\"\\nYAML Input:\") print(yaml.dump({'r_dist':gen.input[\"r_dist\"]}))  plot_dist2d(gen.beam(), 'x', units['x'], 'y', units['y'], axis=\"equal\", title_on=True); <pre>\nYAML Input:\nr_dist:\n  p:\n    units: dimensionless\n    value: 0.5\n  sigma_xy:\n    units: millimeter\n    value: 1\n  type: rsg\n\n</pre> In\u00a0[14]: Copied! <pre>gen=Generator('data/deformable.in.yaml',verbose=0)\n\nprint(\"\\nYAML Input:\")\nprint(yaml.dump({'r_dist':gen.input[\"r_dist\"]}))\n\nplot_dist2d(gen.beam(), 'x', units['x'], 'y', units['y'], axis=\"equal\", title_on=True);\n</pre> gen=Generator('data/deformable.in.yaml',verbose=0)  print(\"\\nYAML Input:\") print(yaml.dump({'r_dist':gen.input[\"r_dist\"]}))  plot_dist2d(gen.beam(), 'x', units['x'], 'y', units['y'], axis=\"equal\", title_on=True); <pre>\nYAML Input:\nr_dist:\n  alpha:\n    units: dimensionless\n    value: 0.1\n  sigma_xy:\n    units: millimeter\n    value: 1\n  slope_fraction:\n    units: dimensionless\n    value: -1\n  type: dr\n\n</pre> In\u00a0[15]: Copied! <pre>gen=Generator('data/interp_ex.yaml',verbose=0)\nprint(\"\\nYAML Input:\")\nprint(yaml.dump({'r_dist':gen.input[\"r_dist\"]}))\nPG = gen.run()\n</pre> gen=Generator('data/interp_ex.yaml',verbose=0) print(\"\\nYAML Input:\") print(yaml.dump({'r_dist':gen.input[\"r_dist\"]})) PG = gen.run() <pre>\nYAML Input:\nr_dist:\n  Pr:\n    pt01: 0.0\n    pt02: 1.1\n    pt03: 3.2\n    pt04: 8.0\n    pt05: 9.0\n    pt06: 8.0\n    pt07: 12.0\n    pt08: 3.0\n    pt09: 2.0\n    pt10: 3.0\n    pt11: 5.0\n    pt12: 1.0\n  method: spline\n  type: radial_interpolation\n\n</pre> In\u00a0[16]: Copied! <pre>PG.plot('r')\n</pre> PG.plot('r') In\u00a0[17]: Copied! <pre>PG.plot('x', 'y')\n</pre> PG.plot('x', 'y') In\u00a0[18]: Copied! <pre>PG['sigma_x'], PG['sigma_y']\n</pre> PG['sigma_x'], PG['sigma_y'] Out[18]: <pre>(0.0012, 0.0012)</pre> In\u00a0[19]: Copied! <pre>from distgen.tools import SUPPORTED_IMAGE_EXTENSIONS\n</pre> from distgen.tools import SUPPORTED_IMAGE_EXTENSIONS In\u00a0[20]: Copied! <pre>SUPPORTED_IMAGE_EXTENSIONS\n</pre> SUPPORTED_IMAGE_EXTENSIONS Out[20]: <pre>['.dicom', '.dcm', '.jpeg', '.jpg', '.png', '.tiff']</pre> <p>The example below uses <code>.jpeg</code>.</p> In\u00a0[21]: Copied! <pre>gen=Generator('data/jpeg.image.in.yaml',verbose=0)\ngen.run()\n\nprint('\\nYAML input:')\nprint(yaml.dump({'xy_dist':gen.input['xy_dist']}))\n\ngen.particles.plot('x','y')\n</pre> gen=Generator('data/jpeg.image.in.yaml',verbose=0) gen.run()  print('\\nYAML input:') print(yaml.dump({'xy_dist':gen.input['xy_dist']}))  gen.particles.plot('x','y') <pre>\nYAML input:\nxy_dist:\n  file: /home/runner/work/distgen/distgen/docs/examples/data/seaturtle.jpeg\n  max_x:\n    units: millimeter\n    value: 1\n  max_y:\n    units: millimeter\n    value: 1\n  min_x:\n    units: millimeter\n    value: -1\n  min_y:\n    units: millimeter\n    value: -1\n  threshold: 0.0\n  type: file2d\n\n</pre> In\u00a0[22]: Copied! <pre>gen=Generator('data/dcm.image.in.yaml',verbose=0)\ngen.run()\n\nprint('\\nYAML input:')\nprint(yaml.dump({'xy_dist':gen.input['xy_dist']}))\n\ngen.particles.plot('x','y')\n</pre> gen=Generator('data/dcm.image.in.yaml',verbose=0) gen.run()  print('\\nYAML input:') print(yaml.dump({'xy_dist':gen.input['xy_dist']}))  gen.particles.plot('x','y') <pre>\nYAML input:\nxy_dist:\n  file: /home/runner/work/distgen/distgen/docs/examples/data/image-00319.dcm\n  max_x:\n    units: millimeter\n    value: 1\n  max_y:\n    units: millimeter\n    value: 1\n  min_x:\n    units: millimeter\n    value: -1\n  min_y:\n    units: millimeter\n    value: -1\n  threshold: 0.0\n  type: file2d\n\n</pre> <p>In addition to handling these standard images, distgen also supports the legacy ascii format from the original version of the code.  The example below makes use of this legacy format:</p> In\u00a0[23]: Copied! <pre># 2D XY distribution: Lase Image Example\n# Real laser spot image - using 1 million particles \ngen=Generator('data/laser.image.in.yaml',verbose=0)\n\nprint('\\nYAML input:')\nprint(yaml.dump({'xy_dist':gen.input['xy_dist']}))\n\n# X-Y Plot\nplot_dist2d(gen.beam(), 'x', units['x'], 'y', units['y'], nbins=100, axis='equal');\n</pre> # 2D XY distribution: Lase Image Example # Real laser spot image - using 1 million particles  gen=Generator('data/laser.image.in.yaml',verbose=0)  print('\\nYAML input:') print(yaml.dump({'xy_dist':gen.input['xy_dist']}))  # X-Y Plot plot_dist2d(gen.beam(), 'x', units['x'], 'y', units['y'], nbins=100, axis='equal'); <pre>\nYAML input:\nxy_dist:\n  file: /home/runner/work/distgen/distgen/docs/examples/data/laser.image.txt\n  type: file2d\n\n</pre> In\u00a0[24]: Copied! <pre>from distgen.tools import read_2d_file\n\nxs, ys, Pxy, xstr, ystr = read_2d_file('data/laser.image.txt')\ninputs={\n    \n    'n_particle': 200000,\n    'total_charge': {'value':1, 'units':'pC'},\n    'random_type': 'hammersley',\n    'start': {\n        'MTE':{'units': 'meV', 'value': 150}, \n        'type': 'cathode'\n    },\n    'xy_dist':{\n        'type' : 'image2d',\n        'min_x': {'value':-2.0, 'units':'mm'},\n        'max_x': {'value':+2.0, 'units':'mm'},\n        'min_y': {'value':-2.0, 'units':'mm'},\n        'max_y': {'value':+2.0, 'units':'mm'},\n        'P':Pxy\n    }\n}\n\ngen=Generator(inputs, verbose=0)\nplot_dist2d(gen.beam(), 'x', units['x'], 'y', units['y'], nbins=100, axis='equal');\n</pre> from distgen.tools import read_2d_file  xs, ys, Pxy, xstr, ystr = read_2d_file('data/laser.image.txt') inputs={          'n_particle': 200000,     'total_charge': {'value':1, 'units':'pC'},     'random_type': 'hammersley',     'start': {         'MTE':{'units': 'meV', 'value': 150},          'type': 'cathode'     },     'xy_dist':{         'type' : 'image2d',         'min_x': {'value':-2.0, 'units':'mm'},         'max_x': {'value':+2.0, 'units':'mm'},         'min_y': {'value':-2.0, 'units':'mm'},         'max_y': {'value':+2.0, 'units':'mm'},         'P':Pxy     } }  gen=Generator(inputs, verbose=0) plot_dist2d(gen.beam(), 'x', units['x'], 'y', units['y'], nbins=100, axis='equal'); <p>Note that this allows the user to manipulate the 2d distribution and length scales:</p> In\u00a0[25]: Copied! <pre>gen=Generator(inputs, verbose=0)\n\nP2 = Pxy.magnitude\nP2 = P2.transpose()\n\n# Cut out a rectangle in the center\nP2[236-50:225+50, 236-50:225+50] = 0  \n\ngen['xy_dist:P']=P2\ngen['xy_dist:min_x:value'], gen['xy_dist:max_x:value']= -5000, +5000\ngen['xy_dist:min_x:units'], gen['xy_dist:max_x:units']= 'um', 'um'\ngen['xy_dist:min_y:units'], gen['xy_dist:max_y:units']= 'mm', 'mm'\n\nplot_dist2d(gen.beam(), 'x', units['x'], 'y', units['y'], nbins=100, axis='equal');\n</pre> gen=Generator(inputs, verbose=0)  P2 = Pxy.magnitude P2 = P2.transpose()  # Cut out a rectangle in the center P2[236-50:225+50, 236-50:225+50] = 0    gen['xy_dist:P']=P2 gen['xy_dist:min_x:value'], gen['xy_dist:max_x:value']= -5000, +5000 gen['xy_dist:min_x:units'], gen['xy_dist:max_x:units']= 'um', 'um' gen['xy_dist:min_y:units'], gen['xy_dist:max_y:units']= 'mm', 'mm'  plot_dist2d(gen.beam(), 'x', units['x'], 'y', units['y'], nbins=100, axis='equal'); In\u00a0[26]: Copied! <pre>import numpy as np\nfrom matplotlib import pyplot as plt\n\nmask = np.kron([[1, 0] * 4, [0, 1] * 4] * 4, np.ones((50, 50)));\n\nys = np.linspace(-4, +4, mask.shape[0])\nxs = np.linspace(-2, +2, mask.shape[1])\n\nfig, ax = plt.subplots(1,3, constrained_layout=True, figsize=(8,4))\n\nax[0].imshow(mask, extent=[xs.min(),xs.max(), ys.min(), ys.max()]);\nax[0].set_aspect('equal',  adjustable='box')\nax[0].set_title('QE Map');\nax[0].set_xlabel('x (mm)');\nax[0].set_ylabel('y (mm)');\n\nlaser_inputs={\n    \n    'n_particle': 200000,\n    'total_charge': {'value':1, 'units':'pC'},\n    'random_type': 'hammersley',\n    'start': {\n        'MTE':{'units': 'meV', 'value': 150}, \n        'type': 'cathode'},\n    \n    'r_dist': {\n        'type': 'rg',\n        'truncation_fraction': {'units': 'dimensionless', 'value': 0.5},\n        'truncation_radius': {'units': 'mm', 'value': 2}\n    },\n        \n}\n\ngen = Generator(laser_inputs)\nbeam1 = gen.beam()\n\nqe_and_laser_inputs={\n    \n    'n_particle': 200000,\n    'total_charge': {'value':1, 'units':'pC'},\n    'random_type': 'hammersley',\n    'start': {\n        'MTE':{'units': 'meV', 'value': 150}, \n        'type': 'cathode'},\n    \n    'xy_dist':{\n        'type': 'product',\n        'dists': {\n            \n            'QE': {\n                'type': 'image2d',\n                'x':{'value':xs, 'units':'mm'},\n                'y':{'value':ys, 'units':'mm'},\n                'P':mask\n            \n            },\n            \n            'Laser':{\n                'type': 'rg',\n                'truncation_fraction': {'units': 'dimensionless', 'value': 0.5},\n                'truncation_radius': {'units': 'mm', 'value': 2}},\n        }\n    }\n}\n\ngen = Generator(qe_and_laser_inputs)\nbeam2 = gen.beam()\n\nplot_dist2d(beam1, 'x', units['x'], 'y', units['y'], nbins=100, axis='equal', ax=ax[1]);\nax[1].set_title('Laser Profile');\n\nplot_dist2d(beam2, 'x', units['x'], 'y', units['y'], nbins=100, axis='equal', ax=ax[2]);\nax[2].set_title('Laser &amp; QE Profile');\n</pre> import numpy as np from matplotlib import pyplot as plt  mask = np.kron([[1, 0] * 4, [0, 1] * 4] * 4, np.ones((50, 50)));  ys = np.linspace(-4, +4, mask.shape[0]) xs = np.linspace(-2, +2, mask.shape[1])  fig, ax = plt.subplots(1,3, constrained_layout=True, figsize=(8,4))  ax[0].imshow(mask, extent=[xs.min(),xs.max(), ys.min(), ys.max()]); ax[0].set_aspect('equal',  adjustable='box') ax[0].set_title('QE Map'); ax[0].set_xlabel('x (mm)'); ax[0].set_ylabel('y (mm)');  laser_inputs={          'n_particle': 200000,     'total_charge': {'value':1, 'units':'pC'},     'random_type': 'hammersley',     'start': {         'MTE':{'units': 'meV', 'value': 150},          'type': 'cathode'},          'r_dist': {         'type': 'rg',         'truncation_fraction': {'units': 'dimensionless', 'value': 0.5},         'truncation_radius': {'units': 'mm', 'value': 2}     },          }  gen = Generator(laser_inputs) beam1 = gen.beam()  qe_and_laser_inputs={          'n_particle': 200000,     'total_charge': {'value':1, 'units':'pC'},     'random_type': 'hammersley',     'start': {         'MTE':{'units': 'meV', 'value': 150},          'type': 'cathode'},          'xy_dist':{         'type': 'product',         'dists': {                          'QE': {                 'type': 'image2d',                 'x':{'value':xs, 'units':'mm'},                 'y':{'value':ys, 'units':'mm'},                 'P':mask                          },                          'Laser':{                 'type': 'rg',                 'truncation_fraction': {'units': 'dimensionless', 'value': 0.5},                 'truncation_radius': {'units': 'mm', 'value': 2}},         }     } }  gen = Generator(qe_and_laser_inputs) beam2 = gen.beam()  plot_dist2d(beam1, 'x', units['x'], 'y', units['y'], nbins=100, axis='equal', ax=ax[1]); ax[1].set_title('Laser Profile');  plot_dist2d(beam2, 'x', units['x'], 'y', units['y'], nbins=100, axis='equal', ax=ax[2]); ax[2].set_title('Laser &amp; QE Profile'); In\u00a0[27]: Copied! <pre>gen=Generator('data/x.uniform.y.file.t.gaussian.in.yaml',verbose=0)\n\nprint('\\nYAML Input:')\nprint(yaml.dump({'x_dist':gen.input['x_dist']}))\n\nplot_dist1d(gen.beam(), 'x', units['y'], nbins=100, title_on=True)\n</pre> gen=Generator('data/x.uniform.y.file.t.gaussian.in.yaml',verbose=0)  print('\\nYAML Input:') print(yaml.dump({'x_dist':gen.input['x_dist']}))  plot_dist1d(gen.beam(), 'x', units['y'], nbins=100, title_on=True) <pre>\nYAML Input:\nx_dist:\n  max_x:\n    units: millimeter\n    value: 2\n  min_x:\n    units: millimeter\n    value: -1\n  type: uniform\n\n</pre> <p>The user may also specify the distribution using the <code>sigma_{var}</code> and <code>avg_{var}</code> input params:</p> In\u00a0[28]: Copied! <pre>import numpy as np\ngen.input['t_dist']={\n    'type': 'uniform',\n    'sigma_t':{'value': float(1/np.sqrt(12)), 'units':'ps'},\n    'avg_t': '2 ps'\n}\n\ngen = Generator(gen.input, verbose=0)\n\nprint('\\nYAML Input:')\nprint(yaml.dump({'t_dist':gen.input['t_dist']}))\n\nplot_dist1d(gen.beam(), 't', units['t'], nbins=100, title_on=True)\n</pre> import numpy as np gen.input['t_dist']={     'type': 'uniform',     'sigma_t':{'value': float(1/np.sqrt(12)), 'units':'ps'},     'avg_t': '2 ps' }  gen = Generator(gen.input, verbose=0)  print('\\nYAML Input:') print(yaml.dump({'t_dist':gen.input['t_dist']}))  plot_dist1d(gen.beam(), 't', units['t'], nbins=100, title_on=True) <pre>\nYAML Input:\nt_dist:\n  avg_t:\n    units: picosecond\n    value: -0.5\n  sigma_t:\n    units: picosecond\n    value: 1.0\n  type: gaussian\n\n</pre> In\u00a0[29]: Copied! <pre>gen=Generator('data/x.uniform.y.file.t.gaussian.in.yaml',verbose=0)\n\nprint('\\nYAML Input:')\nprint(yaml.dump({'y_dist':gen.input['y_dist']}))\nplot_dist1d(gen.beam(), 'y', units['y'], nbins=1000)\n</pre> gen=Generator('data/x.uniform.y.file.t.gaussian.in.yaml',verbose=0)  print('\\nYAML Input:') print(yaml.dump({'y_dist':gen.input['y_dist']})) plot_dist1d(gen.beam(), 'y', units['y'], nbins=1000) <pre>\nYAML Input:\ny_dist:\n  file: /home/runner/work/distgen/distgen/docs/examples/data/cutgauss.1d.txt\n  type: file1d\n  units: mm\n\n</pre> <p>If not specified, the Gaussian is truncated at $\\mu\\pm5\\sigma$:</p> In\u00a0[30]: Copied! <pre>gen=Generator('data/x.uniform.y.file.t.gaussian.in.yaml',verbose=0)\n\nprint('\\nYAML Input:')\nprint(yaml.dump({'t_dist':gen.input['t_dist']}))\n\nplot_dist1d(gen.beam(), 't', units['t'], nbins=1000)\n</pre> gen=Generator('data/x.uniform.y.file.t.gaussian.in.yaml',verbose=0)  print('\\nYAML Input:') print(yaml.dump({'t_dist':gen.input['t_dist']}))  plot_dist1d(gen.beam(), 't', units['t'], nbins=1000) <pre>\nYAML Input:\nt_dist:\n  avg_t:\n    units: picosecond\n    value: -0.5\n  sigma_t:\n    units: picosecond\n    value: 1\n  type: gaussian\n\n</pre> <p>The user can specify <code>n_sigma_cutoff</code> to symmetrically truncate at $ \\mu\\pm N_{\\sigma~\\text{cutoff}}\\times\\sigma$:</p> In\u00a0[31]: Copied! <pre>gen=Generator('data/x.uniform.y.file.t.gaussian.in.yaml', verbose=0)\ngen['t_dist:avg_t']=1\ngen['t_dist:n_sigma_cutoff']=2\n\nprint('\\nYAML Input:')\nprint(yaml.dump({'t_dist':gen.input['t_dist']}))\n\nplot_dist1d(gen.beam(), 't', units['t'], nbins=1000)\n</pre> gen=Generator('data/x.uniform.y.file.t.gaussian.in.yaml', verbose=0) gen['t_dist:avg_t']=1 gen['t_dist:n_sigma_cutoff']=2  print('\\nYAML Input:') print(yaml.dump({'t_dist':gen.input['t_dist']}))  plot_dist1d(gen.beam(), 't', units['t'], nbins=1000) <pre>\nYAML Input:\nt_dist:\n  avg_t:\n    units: picosecond\n    value: 1\n  n_sigma_cutoff: 2\n  sigma_t:\n    units: picosecond\n    value: 1\n  type: gaussian\n\n</pre> In\u00a0[32]: Copied! <pre># Super Gaussian distribution\ngen=Generator('data/SG.beer.can.in.yaml', verbose=0)\n\nprint('\\nYAML Input:')\nprint(yaml.dump({'t_dist':gen.input['t_dist']}))\n\nplot_current_profile(gen.beam(), units['t'], units['I'], title_on=True)\n</pre> # Super Gaussian distribution gen=Generator('data/SG.beer.can.in.yaml', verbose=0)  print('\\nYAML Input:') print(yaml.dump({'t_dist':gen.input['t_dist']}))  plot_current_profile(gen.beam(), units['t'], units['I'], title_on=True) <pre>\nYAML Input:\nt_dist:\n  alpha:\n    units: dimensionless\n    value: 0.5\n  sigma_t:\n    units: picosecond\n    value: 8\n  type: sg\n\n</pre> In\u00a0[33]: Copied! <pre># Tukey distribution\ngen=Generator('data/tukey.beer.can.in.yaml', verbose=0)\n\nprint('\\nYAML Input:')\nprint(yaml.dump({'t_dist':gen.input['t_dist']}))\n\nplot_current_profile(gen.beam(), units['t'], units['I'], nbins=500, title_on=True)\n</pre> # Tukey distribution gen=Generator('data/tukey.beer.can.in.yaml', verbose=0)  print('\\nYAML Input:') print(yaml.dump({'t_dist':gen.input['t_dist']}))  plot_current_profile(gen.beam(), units['t'], units['I'], nbins=500, title_on=True) <pre>\nYAML Input:\nt_dist:\n  length:\n    units: picosecond\n    value: 5.0\n  ratio:\n    units: dimensionless\n    value: 0.75\n  type: tukey\n\n</pre> In\u00a0[34]: Copied! <pre>gen=Generator('data/multi.gaussian.in.yaml', verbose=0)\nprint('\\nYAML Input:')\nprint(yaml.dump({'z_dist':gen.input['z_dist']}))\nplot_dist1d(gen.beam(), 'z', units['z'] ,title_on=True)\nprint(gen['z_dist:weights'])\n</pre> gen=Generator('data/multi.gaussian.in.yaml', verbose=0) print('\\nYAML Input:') print(yaml.dump({'z_dist':gen.input['z_dist']})) plot_dist1d(gen.beam(), 'z', units['z'] ,title_on=True) print(gen['z_dist:weights']) <pre>\nYAML Input:\nz_dist:\n  dists:\n    d1:\n      avg_z:\n        units: millimeter\n        value: -2\n      sigma_z:\n        units: millimeter\n        value: 1.0\n      type: gaussian\n    d2:\n      avg_z:\n        units: millimeter\n        value: 2\n      sigma_z:\n        units: millimeter\n        value: 1\n      type: gaussian\n  type: superposition\n  weights:\n    d1: 1\n    d2: 1\n\n{'d1': 1, 'd2': 1}\n</pre> <p>Example 2: with user specified weighting:</p> In\u00a0[35]: Copied! <pre>gen['z_dist:weights']={'d1':2, 'd2':1}\nprint('\\nYAML Input:')\nprint(yaml.dump({'z_dist':gen.input['z_dist']}))\nplot_dist1d(gen.beam(), 'z', units['z'] ,title_on=True)\n</pre> gen['z_dist:weights']={'d1':2, 'd2':1} print('\\nYAML Input:') print(yaml.dump({'z_dist':gen.input['z_dist']})) plot_dist1d(gen.beam(), 'z', units['z'] ,title_on=True) <pre>\nYAML Input:\nz_dist:\n  dists:\n    d1:\n      avg_z:\n        units: millimeter\n        value: -2\n      sigma_z:\n        units: millimeter\n        value: 1.0\n      type: gaussian\n    d2:\n      avg_z:\n        units: millimeter\n        value: 2\n      sigma_z:\n        units: millimeter\n        value: 1\n      type: gaussian\n  type: superposition\n  weights:\n    d1: 2\n    d2: 1\n\n</pre> In\u00a0[36]: Copied! <pre>gen=Generator('data/product.gaussian.in.yaml', verbose=0)\nprint('\\nYAML Input:')\nprint(yaml.dump({'z_dist':gen.input['z_dist']}))\nplot_dist1d(gen.beam(), 'z', units['z'] ,title_on=True)\n</pre> gen=Generator('data/product.gaussian.in.yaml', verbose=0) print('\\nYAML Input:') print(yaml.dump({'z_dist':gen.input['z_dist']})) plot_dist1d(gen.beam(), 'z', units['z'] ,title_on=True) <pre>\nYAML Input:\nz_dist:\n  dists:\n    d1:\n      max_z:\n        units: millimeter\n        value: 3\n      min_z:\n        units: millimeter\n        value: -3\n      type: uniform\n    d2:\n      avg_z:\n        units: millimeter\n        value: 0\n      sigma_z:\n        units: millimeter\n        value: 2\n      type: gaussian\n  type: product\n\n</pre> In\u00a0[37]: Copied! <pre>gen=Generator('data/deformable.in.yaml', verbose=0)\nprint('\\nYAML Input:')\nprint(yaml.dump({'t_dist':gen.input['t_dist']}))\nplot_current_profile(gen.beam(), units['t'], units['I'] ,title_on=True)\n</pre> gen=Generator('data/deformable.in.yaml', verbose=0) print('\\nYAML Input:') print(yaml.dump({'t_dist':gen.input['t_dist']})) plot_current_profile(gen.beam(), units['t'], units['I'] ,title_on=True) <pre>\nYAML Input:\nt_dist:\n  alpha:\n    units: dimensionless\n    value: 0.25\n  avg_t:\n    units: picosecond\n    value: 0\n  sigma_t:\n    units: picosecond\n    value: 1\n  slope_fraction:\n    units: dimensionless\n    value: 1\n  type: deformable\n\n</pre> In\u00a0[38]: Copied! <pre>gen = Generator('data/interp_ex.yaml')\nprint('\\nYAML Input:')\nprint(yaml.dump({'t_dist':gen.input['t_dist']}))\n</pre> gen = Generator('data/interp_ex.yaml') print('\\nYAML Input:') print(yaml.dump({'t_dist':gen.input['t_dist']})) <pre>\nYAML Input:\nt_dist:\n  Pt:\n    pt01: 0.1\n    pt02: 0.3\n    pt03: 4.0\n    pt04: 2.9\n    pt05: 8.5\n    pt06: 2.0\n    pt07: 0.1\n    pt08: 1.0\n    pt09: 5.0\n    pt10: 10.0\n    pt11: 6.0\n    pt12: 1.0\n  avg_t:\n    units: nanosecond\n    value: 0.0\n  method: spline\n  sigma_t:\n    units: nanosecond\n    value: 0.08287285705\n  type: interp\n\n</pre> In\u00a0[39]: Copied! <pre>ax = plot_dist1d(gen.beam(), 't', units['t'] ,title_on=True)\n</pre> ax = plot_dist1d(gen.beam(), 't', units['t'] ,title_on=True) In\u00a0[40]: Copied! <pre>gen=Generator('data/t.crystals.in.yaml',verbose=0)\nprint('\\nYAML Input:')\nprint(yaml.dump({'t_dist':gen.input['t_dist']}))\nplot_current_profile(gen.beam(), units['t'], units['I'] ,title_on=True)\n</pre> gen=Generator('data/t.crystals.in.yaml',verbose=0) print('\\nYAML Input:') print(yaml.dump({'t_dist':gen.input['t_dist']})) plot_current_profile(gen.beam(), units['t'], units['I'] ,title_on=True) <pre>\nYAML Input:\nt_dist:\n  crystal_angle_1:\n    units: degree\n    value: 0.6\n  crystal_angle_2:\n    units: degree\n    value: 1.8\n  crystal_angle_3:\n    units: degree\n    value: -0.9\n  crystal_angle_4:\n    units: degree\n    value: -0.5\n  crystal_length_1:\n    units: millimeter\n    value: 15.096\n  crystal_length_2:\n    units: millimeter\n    value: 7.548\n  crystal_length_3:\n    units: millimeter\n    value: 3.774\n  crystal_length_4:\n    units: millimeter\n    value: 1.887\n  type: crystals\n\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/example_dists/#radial-distributions","title":"Radial Distributions\u00b6","text":""},{"location":"examples/example_dists/#radial-uniform","title":"Radial Uniform\u00b6","text":"<p>The radial uniform distribution is given by</p> <p>$\\rho_r(r)=\\frac{2}{r_R^2-r_L^2}$ for $0 \\leq r_L &lt; r &lt; r_R$ and zero otherewise.</p> <p>Typical usage is shown below for a uniformly filled beam as well as a ring:</p>"},{"location":"examples/example_dists/#radial-gaussian-with-truncation","title":"Radial Gaussian (with Truncation)\u00b6","text":"<p>The radial normal distribution including truncation(s) has a probability function given by</p> <p>$\\rho_r(r) = \\frac{1}{\\sigma^2}\\frac{\\phi(r/\\sigma)}{\\phi\\left(\\frac{r_L}{\\sigma}\\right)-\\phi\\left(\\frac{r_R}{\\sigma}\\right)} $ for $0 \\leq r_L \\leq r \\leq r_R$ and zero everywhere else.</p> <p>In this expresion $\\phi(\\xi) = \\frac{1}{2\\pi}\\exp\\left(-\\xi^2/2\\right)$ is the canonical raidial normal distirbution (no truncation), and the scale parameter $\\sigma$ follows from the product of two normal distributions in $x$ and $y$ when $\\sigma=\\sigma_x=\\sigma_y$.  The corresponding CDF is given by</p> <p>$P(r)= \\frac{\\phi\\left(\\frac{r_L}{\\sigma}\\right)-\\phi\\left(\\frac{r}{\\sigma}\\right)}{\\phi\\left(\\frac{r_L}{\\sigma}\\right)-\\phi\\left(\\frac{r_R}{\\sigma}\\right)} $ for $0 \\leq r_L \\leq r$.</p> <p>The corresponding first and second moments are:</p> <p>$\\langle r\\rangle = \\frac{\\frac{r_L}{\\sigma}\\phi\\left(\\frac{r_L}{\\sigma}\\right) -\\frac{r_R}{\\sigma}\\phi\\left(\\frac{r_R}{\\sigma}\\right) +\\frac{1}{2\\sqrt{2\\pi}}\\left( \\text{erf}\\left(\\frac{r_R}{\\sigma\\sqrt{2}}\\right) - \\text{erf}\\left(\\frac{r_L}{\\sigma\\sqrt{2}}\\right) \\right)  } {\\phi\\left(\\frac{r_L}{\\sigma}\\right)-\\phi\\left(\\frac{r_R}{\\sigma}\\right)}$,</p> <p>$r_{rms} = \\sqrt{ 2\\sigma^2 + r_L^2 - \\frac{(r_R^2-r_L^2)\\phi(r_R/\\sigma)}{\\phi\\left(\\frac{r_L}{\\sigma}\\right)-\\phi\\left(\\frac{r_R}{\\sigma}\\right)} }$.</p> <p>Note that in the limits $r_L\\rightarrow 0$ and $r_R -&gt; \\infty$ the above expressions reduce to the underlying radial normal distribution:</p> <p>$\\rho_r(r)\\rightarrow \\frac{\\phi\\left(\\frac{r}{\\sigma}\\right)}{\\sigma^2}$, $P(r)\\rightarrow 1 - \\phi\\left(\\frac{r}{\\sigma}\\right)$, $\\langle r\\rangle\\rightarrow \\sqrt{\\frac{\\pi}{2}}\\sigma$, and $r_{rms}\\rightarrow \\sqrt{2}\\sigma$.  This limiting case is shown first below.</p> <p>Here three examples are provided: a non-truncated Gaussian with $\\sigma_{x,y}$ = 2 mm, followed by a truncated Gaussian using a truncation fraction to specify the maximal radial cut, followed by a truncated Gaussian using n_sigma_cutoff to specify the radial cut.</p> <p>Example 1: canonical Gaussian with $\\sigma_{x,y}$ = 2mm</p>"},{"location":"examples/example_dists/#radial-file","title":"Radial File\u00b6","text":""},{"location":"examples/example_dists/#radial-tukey","title":"Radial Tukey\u00b6","text":""},{"location":"examples/example_dists/#radial-super-gaussian","title":"Radial Super Gaussian\u00b6","text":"<p>This implements a radial version of the Super Gaussian function.  Here the radial function takes the form:</p> <p>$2\\pi\\rho(r;\\lambda,p) = \\frac{1}{\\Gamma\\left(1+\\frac{1}{p}\\right)\\lambda^2} \\exp\\left[-\\left(\\frac{r^2}{2\\lambda^2}\\right)^p\\right]$.</p> <p>The first and (rms) second moment of the distribution are given by:</p> <p>$\\langle r\\rangle = \\frac{2\\sqrt{2}}{3}\\frac{\\Gamma\\left(1+\\frac{3}{2p}\\right)}{\\Gamma\\left(1+\\frac{1}{p}\\right)}\\lambda$,</p> <p>$r_{\\text{rms}} = \\sqrt{\\frac{\\Gamma\\left(1+\\frac{2}{p}\\right)}{\\Gamma\\left(1+\\frac{1}{p}\\right)}}\\lambda$.</p> <p>Example 1: hyper-Gaussian (uniform) limit (power $\\rightarrow\\infty$): $\\sigma_{x,y}$ = 1 mm</p>"},{"location":"examples/example_dists/#radial-deformable","title":"Radial Deformable\u00b6","text":""},{"location":"examples/example_dists/#radial-interpolation","title":"Radial Interpolation\u00b6","text":""},{"location":"examples/example_dists/#2d-distributions","title":"2D Distributions\u00b6","text":""},{"location":"examples/example_dists/#2d-file","title":"2D File\u00b6","text":"<p>The user can load images for use in generating particles.  Supported file formats include:</p>"},{"location":"examples/example_dists/#2d-image","title":"2D Image\u00b6","text":"<p>If the user has an image dataset already loaded into python, they can directly pass this to Distgen using the Image2d class.  An example of how to use this in practice is given below:</p>"},{"location":"examples/example_dists/#product-2d","title":"Product 2D\u00b6","text":"<p>It is possible to multiply two or more 2d or radial distributions.  This is useful for creating particles from a laser and folding in a cathod QE map.  The example shows a truncated Gaussian laser profile combined with a simple checker board QE map:</p>"},{"location":"examples/example_dists/#1d-distributions","title":"1D Distributions\u00b6","text":""},{"location":"examples/example_dists/#uniform","title":"Uniform\u00b6","text":"<p>The uniform distirbuition is defined by a probability distribution function:</p> <p>$\\rho(x) = \\frac{1}{b-a}$ for $a\\leq x\\leq b$ and zero elsewhere.</p> <p>The corresponding CDF is</p> <p>$P(x) = \\frac{x-a}{b-a}$ for $a\\leq x\\leq b$ and zero elsewhere.</p> <p>The first and second moments of this distribution are:</p> <p>$\\langle x \\rangle = \\frac{1}{2}(a+b)$ and $\\sigma_x = \\frac{b-a}{\\sqrt{12}}$.</p> <p>It is possible to set a uniform distribution using the <code>min_{var}</code> and <code>max_{var}</code> input variables:</p>"},{"location":"examples/example_dists/#linear","title":"Linear\u00b6","text":"<p>The linear distirbuition is defined by a probability distribution function:</p> <p>$\\rho(x) = \\frac{p_b-p_a}{b-a}(x-a) + p_a$ for $a\\leq x\\leq b$ and zero elsewhere.</p> <p>The corresponding CDF is</p> <p>$P(x) = \\frac{1}{2}\\frac{p_b-p_a}{b-a}(x-a)$ for $a\\leq x\\leq b$ and zero elsewhere.</p> <p>It is possible to set a uniform distribution using the <code>min_{var}</code> and <code>max_{var}</code>(equivalent to $a$ and $b$ above) input variables as well as the <code>slope_fraction</code> $\\in[-1,1]$.</p>"},{"location":"examples/example_dists/#1d-file","title":"1D File\u00b6","text":"<p>Disgten supports importing a 1D PDF saved in column form in.  The input form of the file should have space separated headers such as $x$ and $Px$, with corresponding column data below it.  The PDF is normalized numerically using the numpy.trapz numerical integration routine. The CDF is computed using the scipy.cumtrapz cumulative numerical intgration routine.</p> <p>The following example shows a gaussian PDF with cuts added to it.</p>"},{"location":"examples/example_dists/#gaussian-with-truncation","title":"Gaussian (with Truncation)\u00b6","text":""},{"location":"examples/example_dists/#super-gaussian","title":"Super Gaussian\u00b6","text":"<p>In additional to the regular Gaussian function, it is also possible to sample a super-Gaussian distribution defined by</p> <p>$\\rho(x; \\lambda, p) = \\frac{1}{2\\sqrt{2}\\Gamma\\left(1+\\frac{1}{2p}\\right)\\lambda } \\exp\\left[-\\left(\\frac{(x-\\mu)^2 }{2\\lambda^2}\\right)^{p}\\right]$</p> <p>Here $\\lambda$ is the length scale and $p$ is the power of the super-Gaussian. Note when $p=1$ this expression reduces to a Normal distirbution, in which case $\\sigma_x=\\lambda$.  As $p\\rightarrow\\infty$ the distribution reduces to a flat-top (uniform). The full range of powers is given by $p\\in\\left(0,\\infty\\right]$.</p> <p>The first and second moments of the distribution are given by:</p> <p>$\\langle x\\rangle = \\mu$, and $\\sigma_x = \\left(\\frac{2\\Gamma\\left(1+\\frac{3}{2p}\\right)}{3\\Gamma\\left(1+\\frac{1}{2p}\\right)}\\right)^{1/2}\\lambda$.</p> <p>Often, it is convenient to scan the distribution from the uniform limit to the Gaussian limit.  To do some, the input $p$ can be parameterized by $\\alpha\\in[0,1]$ where $p = 1/\\alpha$.  Here $\\alpha=0$ corresponds to a flat-top (uniform) and $\\alpha=1$ corresponds to a Gaussian.  Examples of both types of usage are shown below.\\</p> <p>Example 1: specifying $\\alpha = 1/p \\in[0,1]$:</p>"},{"location":"examples/example_dists/#tukey","title":"Tukey\u00b6","text":""},{"location":"examples/example_dists/#superposition-1d","title":"Superposition 1D\u00b6","text":"<p>This distribution allows the user to superimpose an arbitrary number of 1D PDFs.  The general form is:</p> <p>$\\rho(x) = \\sum_i w_i \\frac{\\rho_i(x)}{\\max(\\rho_i)}$.</p> <p>Here the $w_i$ are user specified weights.  If no weight is specified for a given $\\rho_i$, then the weight(s) will default to one.</p> <p>Example 1: equal weighting</p>"},{"location":"examples/example_dists/#product-1d","title":"Product 1D\u00b6","text":""},{"location":"examples/example_dists/#deformable","title":"Deformable\u00b6","text":""},{"location":"examples/example_dists/#interpolation","title":"Interpolation\u00b6","text":"<p>For the 1d interpolation distribution the user provides N points of the PDF for the desired variable and interpolation is employed to make a smooth curve.  The PDF knots can be passed in as a dictionary or as an array.  Passing in a corresponding coordinate vector is optional.  If a coordinate vector is not input, then the user must use a transform operator to scale the resulting distribution (shown below).</p>"},{"location":"examples/example_dists/#special-temporal-distributions","title":"Special Temporal Distributions\u00b6","text":""},{"location":"examples/example_dists/#pulse-stacking-temporal-crystals","title":"Pulse stacking temporal crystals\u00b6","text":""},{"location":"examples/metrics/","title":"Metrics for comparing different distributions","text":"In\u00a0[1]: Copied! <pre># Useful for debugging\n%load_ext autoreload\n%autoreload 2\n%config InlineBackend.figure_format = 'retina'\n</pre> # Useful for debugging %load_ext autoreload %autoreload 2 %config InlineBackend.figure_format = 'retina' In\u00a0[2]: Copied! <pre>from distgen.dist import Uniform\nfrom distgen.dist import SuperGaussian\nfrom distgen.dist import Norm\nfrom distgen.physical_constants import unit_registry\n\nfrom matplotlib import pyplot as plt\n\nimport numpy as np\n</pre> from distgen.dist import Uniform from distgen.dist import SuperGaussian from distgen.dist import Norm from distgen.physical_constants import unit_registry  from matplotlib import pyplot as plt  import numpy as np In\u00a0[3]: Copied! <pre>L = 2*unit_registry('ps')\navg_t_sg = 0*unit_registry('ps')\nsigma_t_sg = L/np.sqrt(12)\n</pre> L = 2*unit_registry('ps') avg_t_sg = 0*unit_registry('ps') sigma_t_sg = L/np.sqrt(12) In\u00a0[4]: Copied! <pre>sg = SuperGaussian('t', avg_t=avg_t_sg, sigma_t=sigma_t_sg, p=12)\n</pre> sg = SuperGaussian('t', avg_t=avg_t_sg, sigma_t=sigma_t_sg, p=12) In\u00a0[5]: Copied! <pre>tsg, Psg = sg.get_x_pts(), sg.pdf()\nplt.plot(tsg, Psg);\n</pre> tsg, Psg = sg.get_x_pts(), sg.pdf() plt.plot(tsg, Psg); In\u00a0[6]: Copied! <pre>norm = Norm('t', avg_t=avg_t_sg, sigma_t=sigma_t_sg)\n</pre> norm = Norm('t', avg_t=avg_t_sg, sigma_t=sigma_t_sg) In\u00a0[7]: Copied! <pre>tn, Pn = norm.get_x_pts(), norm.pdf()\nplt.plot(tn, Pn);\n</pre> tn, Pn = norm.get_x_pts(), norm.pdf() plt.plot(tn, Pn); In\u00a0[8]: Copied! <pre>from distgen.metrics import kullback_liebler_div\n</pre> from distgen.metrics import kullback_liebler_div In\u00a0[9]: Copied! <pre>kullback_liebler_div(tn, Pn, tsg, Psg, as_float=False)\n</pre> kullback_liebler_div(tn, Pn, tsg, Psg, as_float=False) Out[9]:  4.301370109274345 dimensionless  <p>The functions work with raw NumPy arrays, and support both float output or Pint Quantity outputs:</p> In\u00a0[10]: Copied! <pre>kullback_liebler_div(tn.magnitude, Pn.magnitude, tsg.magnitude, Psg.magnitude, as_float=True)\n</pre> kullback_liebler_div(tn.magnitude, Pn.magnitude, tsg.magnitude, Psg.magnitude, as_float=True) Out[10]: <pre>4.301370109274345</pre> <p>In addition to the Kullback Liebler Divergence, the residual squared between two distributions is implemented:</p> In\u00a0[11]: Copied! <pre>from distgen.metrics import res2\n</pre> from distgen.metrics import res2 In\u00a0[12]: Copied! <pre>res2(tn, Pn, tsg, Psg, as_float=False, normalize=True)\n</pre> res2(tn, Pn, tsg, Psg, as_float=False, normalize=True) Out[12]:  0.11983271504891024 dimensionless  In\u00a0[13]: Copied! <pre>res2(tn.magnitude, Pn.magnitude, tsg.magnitude, Psg.magnitude, as_float=True)\n</pre> res2(tn.magnitude, Pn.magnitude, tsg.magnitude, Psg.magnitude, as_float=True) Out[13]: <pre>0.058441901838167956</pre> In\u00a0[14]: Copied! <pre>from distgen.metrics import resample_pq\n</pre> from distgen.metrics import resample_pq In\u00a0[15]: Copied! <pre>resample_pq(tn, Pn, tsg, Psg, plot=True);\n</pre> resample_pq(tn, Pn, tsg, Psg, plot=True); In\u00a0[16]: Copied! <pre>dist_yaml=\"\"\"\nn_particle: 30000\nr_dist:\n  truncation_fraction:\n    units: dimensionless\n    value: 0.5\n  truncation_radius:\n    units: mm\n    value: 2.3319043122\n  type: rg\nrandom_type: hammersley\nstart:\n  MTE:\n    units: meV\n    value: 130\n  type: cathode\nt_dist:\n  p:\n    units: ''\n    value: 1\n  sigma_t:\n    units: ps\n    value: 10\n  type: sg\ntotal_charge:\n  units: pC\n  value: 100\n\"\"\"\n</pre> dist_yaml=\"\"\" n_particle: 30000 r_dist:   truncation_fraction:     units: dimensionless     value: 0.5   truncation_radius:     units: mm     value: 2.3319043122   type: rg random_type: hammersley start:   MTE:     units: meV     value: 130   type: cathode t_dist:   p:     units: ''     value: 1   sigma_t:     units: ps     value: 10   type: sg total_charge:   units: pC   value: 100 \"\"\" In\u00a0[17]: Copied! <pre>from distgen import Generator\n</pre> from distgen import Generator In\u00a0[18]: Copied! <pre>D = Generator(dist_yaml)\n</pre> D = Generator(dist_yaml) In\u00a0[19]: Copied! <pre>P = D.run()\n</pre> P = D.run() In\u00a0[20]: Copied! <pre>P.plot('t')\n</pre> P.plot('t') In\u00a0[21]: Copied! <pre>from distgen.metrics import get_current_profile\nfrom distgen.metrics import rms_equivalent_current_nonuniformity\n</pre> from distgen.metrics import get_current_profile from distgen.metrics import rms_equivalent_current_nonuniformity In\u00a0[22]: Copied! <pre>t, I = get_current_profile(P)\n</pre> t, I = get_current_profile(P) In\u00a0[23]: Copied! <pre>plt.plot(t, I);\n</pre> plt.plot(t, I); In\u00a0[24]: Copied! <pre>ps = np.linspace(1, 12, 50)\n</pre> ps = np.linspace(1, 12, 50) In\u00a0[25]: Copied! <pre>kldivs = np.zeros(ps.shape)\nres2s = np.zeros(ps.shape)\n\nfor ii, p in enumerate(ps):\n    \n    D['t_dist:p']=p\n    \n    P = D.run()\n    \n    t, I = get_current_profile(P)\n    \n    plt.plot(t, I)\n    \n    kldivs[ii] = rms_equivalent_current_nonuniformity(P, method='kl_div', p=12)\n    \n    res2s[ii] = rms_equivalent_current_nonuniformity(P, method='res2')\n\nplt.xlabel('t (s)');\nplt.ylabel('$\\\\rho$ ($s^{-1}$)');\n</pre> kldivs = np.zeros(ps.shape) res2s = np.zeros(ps.shape)  for ii, p in enumerate(ps):          D['t_dist:p']=p          P = D.run()          t, I = get_current_profile(P)          plt.plot(t, I)          kldivs[ii] = rms_equivalent_current_nonuniformity(P, method='kl_div', p=12)          res2s[ii] = rms_equivalent_current_nonuniformity(P, method='res2')  plt.xlabel('t (s)'); plt.ylabel('$\\\\rho$ ($s^{-1}$)'); <p>$D_{KL} = \\int_{-\\infty}^{\\infty} P\\ln(P/Q)dt$</p> <p>Note, not defined for uniform beam where $Q_u = \\frac{1}{t_2-t_1}\\left[\\theta(t-t_1)-\\theta(t-t_2)\\right]$.  If comparing to uniform beam, replace target distribution with rms equivalent super-Gaussian with power $p$: $Q=Q_{SG}(t; p)$.  So KL-div nonuniformity:</p> <p>$\\lim_{p\\rightarrow\\infty}\\int_{-\\infty}^{\\infty} P\\ln[P/Q_{SG}(t;p)]dt$</p> In\u00a0[26]: Copied! <pre>plt.plot(ps, kldivs);\nplt.xlabel('super-Gaussian power');\nplt.ylabel('KL-Divergence');\n</pre> plt.plot(ps, kldivs); plt.xlabel('super-Gaussian power'); plt.ylabel('KL-Divergence'); <p>$\\frac{\\int_{-\\infty}^{\\infty} (P-Q)^2dt}{\\int_{-\\infty}^{\\infty} Q^2(t)dt}$</p> In\u00a0[27]: Copied! <pre>plt.plot(ps, res2s);\nplt.xlabel('super-Gaussian power');\nplt.ylabel('integrated squared residuals');\n</pre> plt.plot(ps, res2s); plt.xlabel('super-Gaussian power'); plt.ylabel('integrated squared residuals'); In\u00a0[28]: Copied! <pre>D['t_dist:p']=4\nP = D.run()\nP.plot('t')\n</pre> D['t_dist:p']=4 P = D.run() P.plot('t') In\u00a0[29]: Copied! <pre>D['t_dist:p']=6\nP = D.run()\nP.plot('t')\n</pre> D['t_dist:p']=6 P = D.run() P.plot('t') In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/metrics/#metrics-for-comparing-different-distributions","title":"Metrics for comparing different distributions\u00b6","text":"<p>In some cases, it is desired to target a particular distribution shape in an optimization.  To facilitate this the following two metrics are implemented:</p>"},{"location":"examples/metrics/#kullback-leibler-relative-entropy","title":"Kullback-Leibler (Relative Entropy)\u00b6","text":"<p>Defined as: $D_{KL}(P|Q) = \\int_{-\\infty}^{\\infty}p(x)\\ln{\\left(\\frac{p(x)}{q(x)}\\right)} dx$</p> <p>Note that this is not well defined in regions where the PDF $q(x)=0$.  This causes trouble for distributions like a uniform distribution.  For this, its suggested to use a SuperGaussian to approximate the uniform dist (see below).</p> <p>https://en.wikipedia.org/wiki/Kullback\u2013Leibler_divergence</p>"},{"location":"examples/metrics/#helper-functions","title":"Helper Functions\u00b6","text":""},{"location":"examples/parallel_distgen/","title":"Parallel distgen","text":"In\u00a0[1]: Copied! <pre># Useful for debugging\n%load_ext autoreload\n%autoreload 2\n%config InlineBackend.figure_format = 'retina'\n</pre> # Useful for debugging %load_ext autoreload %autoreload 2 %config InlineBackend.figure_format = 'retina' In\u00a0[2]: Copied! <pre>from distgen import Generator\n\nimport numpy as np\nfrom time import time\nfrom matplotlib import pyplot as plt\n</pre> from distgen import Generator  import numpy as np from time import time from matplotlib import pyplot as plt In\u00a0[15]: Copied! <pre>G = Generator('data/rad.gaussian.in.yaml', verbose=1)\n</pre> G = Generator('data/rad.gaussian.in.yaml', verbose=1) In\u00a0[16]: Copied! <pre>G.run()\n</pre> G.run() <pre>Distribution format: gpt\nOutput file: rad.gaussian.out.txt\n\nCreating beam distribution....\n   Beam starting from: cathode\n   Total charge: 10 pC.\n   Number of macroparticles: 200000.\n   Assuming cylindrical symmetry...\n   r distribution: radial Gaussian\n   theta distribution: uniform theta\n      min_theta = 0 rad, max_theta = 6.28319 rad\n   t distribution: uniform\n      min_t = -2 ps, max_t = 2 ps\n   px distribution: Gaussian\n      avg_px = 0 eV/c, sigma_px = 276.857 eV/c\n   py distribution: Gaussian\n      avg_py = 0 eV/c, sigma_py = 276.857 eV/c\n   pz distribution: Gaussian\n      avg_pz = 0 eV/c, sigma_pz = 276.857 eV/c\n   Shifting avg_x = -7.82345E-05 mm -&gt; 0 mm\n   Scaling sigma_x = 1.99984 mm -&gt; 2 mm\n   Shifting avg_y = -1.09911E-05 mm -&gt; 0 mm\n   Scaling sigma_y = 1.99994 mm -&gt; 2 mm\n   Shifting avg_px = -0.0212516 eV/c -&gt; 0 eV/c\n   Scaling sigma_px = 276.849 eV/c -&gt; 276.857 eV/c\n   Shifting avg_py = -0.0259627 eV/c -&gt; 0 eV/c\n   Scaling sigma_py = 276.844 eV/c -&gt; 276.857 eV/c\n   Shifting avg_pz = -0.0372953 eV/c -&gt; 0 eV/c\n   Scaling sigma_pz = 276.843 eV/c -&gt; 276.857 eV/c\n   Shifting avg_t = -4.90022E-05 ps -&gt; 0 ps\n   Scaling sigma_t = 1.1547 ps -&gt; 1.1547 ps\n   Cathode start: fixing pz momenta to forward hemisphere\n      avg_pz -&gt; 220.904 eV/c, sigma_pz -&gt; 166.887 eV/c\n...done. Time Elapsed: 688.285 ms.\n\n   Created particles in .particles: \n   ParticleGroup with 200000 particles with total charge 1.0000000000000003e-11 C\n</pre> Out[16]: <pre>&lt;ParticleGroup with 200000 particles at 0x15f9b0d60&gt;</pre> In\u00a0[21]: Copied! <pre>G['n_particle']=10_000_000\n</pre> G['n_particle']=10_000_000 In\u00a0[22]: Copied! <pre>G.run(max_workers=10)\n</pre> G.run(max_workers=10) <pre>Creating particles in parallel with 10 workers\n   Setting up workers...done.\n   Executing worker tasks...done\n   Collecting beamlets...   Created particles in .particles: \n   ParticleGroup with 10000000 particles with total charge 1.0000000000000125e-11 C\n</pre> Out[22]: <pre>&lt;ParticleGroup with 10000000 particles at 0x1653867c0&gt;</pre> In\u00a0[7]: Copied! <pre>n_particles = [100, 1_000, 10_000, 100_000, 1_000_000, 10_000_000, 25_000_000, 50_000_000, 100_000_000]\n</pre> n_particles = [100, 1_000, 10_000, 100_000, 1_000_000, 10_000_000, 25_000_000, 50_000_000, 100_000_000] In\u00a0[8]: Copied! <pre>s_times = []\n\nfor n_part in n_particles:\n\n    G['n_particle'] = n_part\n\n    # Run in serial:\n    ts0 = time()\n    G.run()\n    ts1 = time()\n\n    s_times.append(ts1-ts0)\n</pre> s_times = []  for n_part in n_particles:      G['n_particle'] = n_part      # Run in serial:     ts0 = time()     G.run()     ts1 = time()      s_times.append(ts1-ts0)       <pre>Distribution format: gpt\nOutput file: rad.gaussian.out.txt\n\nCreating beam distribution....\n   Beam starting from: cathode\n   Total charge: 10 pC.\n   Number of macroparticles: 100.\n   Assuming cylindrical symmetry...\n   r distribution: radial Gaussian\n   theta distribution: uniform theta\n      min_theta = 0 rad, max_theta = 6.28319 rad\n   t distribution: uniform\n      min_t = -2 ps, max_t = 2 ps\n   px distribution: Gaussian\n      avg_px = 0 eV/c, sigma_px = 276.857 eV/c\n   py distribution: Gaussian\n      avg_py = 0 eV/c, sigma_py = 276.857 eV/c\n   pz distribution: Gaussian\n      avg_pz = 0 eV/c, sigma_pz = 276.857 eV/c\n   Shifting avg_x = -0.0128692 mm -&gt; 0 mm\n   Scaling sigma_x = 1.98551 mm -&gt; 2 mm\n   Shifting avg_y = -0.00373924 mm -&gt; 0 mm\n   Scaling sigma_y = 1.96499 mm -&gt; 2 mm\n   Shifting avg_px = -5.75344 eV/c -&gt; 0 eV/c\n   Scaling sigma_px = 267.468 eV/c -&gt; 276.857 eV/c\n   Shifting avg_py = -6.91735 eV/c -&gt; 0 eV/c\n   Scaling sigma_py = 274.758 eV/c -&gt; 276.857 eV/c\n   Shifting avg_pz = -5.61571 eV/c -&gt; 0 eV/c\n   Scaling sigma_pz = 263.769 eV/c -&gt; 276.857 eV/c\n   Shifting avg_t = -0.0329218 ps -&gt; 0 ps\n   Scaling sigma_t = 1.15829 ps -&gt; 1.1547 ps\n   Cathode start: fixing pz momenta to forward hemisphere\n      avg_pz -&gt; 226.104 eV/c, sigma_pz -&gt; 159.771 eV/c\n...done. Time Elapsed: 16.963 ms.\n\n   Created particles in .particles: \n   ParticleGroup with 100 particles with total charge 1e-11 C\nDistribution format: gpt\nOutput file: rad.gaussian.out.txt\n\nCreating beam distribution....\n   Beam starting from: cathode\n   Total charge: 10 pC.\n   Number of macroparticles: 1000.\n   Assuming cylindrical symmetry...\n   r distribution: radial Gaussian\n   theta distribution: uniform theta\n      min_theta = 0 rad, max_theta = 6.28319 rad\n   t distribution: uniform\n      min_t = -2 ps, max_t = 2 ps\n   px distribution: Gaussian\n      avg_px = 0 eV/c, sigma_px = 276.857 eV/c\n   py distribution: Gaussian\n      avg_py = 0 eV/c, sigma_py = 276.857 eV/c\n   pz distribution: Gaussian\n      avg_pz = 0 eV/c, sigma_pz = 276.857 eV/c\n   Shifting avg_x = -0.00349168 mm -&gt; 0 mm\n   Scaling sigma_x = 1.99119 mm -&gt; 2 mm\n   Shifting avg_y = -0.0017992 mm -&gt; 0 mm\n   Scaling sigma_y = 1.99479 mm -&gt; 2 mm\n   Shifting avg_px = -2.08758 eV/c -&gt; 0 eV/c\n   Scaling sigma_px = 276.15 eV/c -&gt; 276.857 eV/c\n   Shifting avg_py = -2.20483 eV/c -&gt; 0 eV/c\n   Scaling sigma_py = 275.013 eV/c -&gt; 276.857 eV/c\n   Shifting avg_pz = -2.66491 eV/c -&gt; 0 eV/c\n   Scaling sigma_pz = 274.96 eV/c -&gt; 276.857 eV/c\n   Shifting avg_t = -0.00602835 ps -&gt; 0 ps\n   Scaling sigma_t = 1.15477 ps -&gt; 1.1547 ps\n   Cathode start: fixing pz momenta to forward hemisphere\n      avg_pz -&gt; 221.563 eV/c, sigma_pz -&gt; 166.011 eV/c\n...done. Time Elapsed: 20.0179 ms.\n\n   Created particles in .particles: \n   ParticleGroup with 1000 particles with total charge 1e-11 C\nDistribution format: gpt\nOutput file: rad.gaussian.out.txt\n\nCreating beam distribution....\n   Beam starting from: cathode\n   Total charge: 10 pC.\n   Number of macroparticles: 10000.\n   Assuming cylindrical symmetry...\n   r distribution: radial Gaussian\n   theta distribution: uniform theta\n      min_theta = 0 rad, max_theta = 6.28319 rad\n   t distribution: uniform\n      min_t = -2 ps, max_t = 2 ps\n   px distribution: Gaussian\n      avg_px = 0 eV/c, sigma_px = 276.857 eV/c\n   py distribution: Gaussian\n      avg_py = 0 eV/c, sigma_py = 276.857 eV/c\n   pz distribution: Gaussian\n      avg_pz = 0 eV/c, sigma_pz = 276.857 eV/c\n   Shifting avg_x = -0.00102054 mm -&gt; 0 mm\n   Scaling sigma_x = 1.99758 mm -&gt; 2 mm\n   Shifting avg_y = -0.000286803 mm -&gt; 0 mm\n   Scaling sigma_y = 1.99973 mm -&gt; 2 mm\n   Shifting avg_px = -0.256036 eV/c -&gt; 0 eV/c\n   Scaling sigma_px = 276.783 eV/c -&gt; 276.857 eV/c\n   Shifting avg_py = -0.399525 eV/c -&gt; 0 eV/c\n   Scaling sigma_py = 276.803 eV/c -&gt; 276.857 eV/c\n   Shifting avg_pz = -0.618933 eV/c -&gt; 0 eV/c\n   Scaling sigma_pz = 276.58 eV/c -&gt; 276.857 eV/c\n   Shifting avg_t = -0.000807357 ps -&gt; 0 ps\n   Scaling sigma_t = 1.15467 ps -&gt; 1.1547 ps\n   Cathode start: fixing pz momenta to forward hemisphere\n      avg_pz -&gt; 221.023 eV/c, sigma_pz -&gt; 166.729 eV/c\n...done. Time Elapsed: 49.448 ms.\n\n   Created particles in .particles: \n   ParticleGroup with 10000 particles with total charge 1.0000000000000003e-11 C\nDistribution format: gpt\nOutput file: rad.gaussian.out.txt\n\nCreating beam distribution....\n   Beam starting from: cathode\n   Total charge: 10 pC.\n   Number of macroparticles: 100000.\n   Assuming cylindrical symmetry...\n   r distribution: radial Gaussian\n   theta distribution: uniform theta\n      min_theta = 0 rad, max_theta = 6.28319 rad\n   t distribution: uniform\n      min_t = -2 ps, max_t = 2 ps\n   px distribution: Gaussian\n      avg_px = 0 eV/c, sigma_px = 276.857 eV/c\n   py distribution: Gaussian\n      avg_py = 0 eV/c, sigma_py = 276.857 eV/c\n   pz distribution: Gaussian\n      avg_pz = 0 eV/c, sigma_pz = 276.857 eV/c\n   Shifting avg_x = -0.000144205 mm -&gt; 0 mm\n   Scaling sigma_x = 1.99971 mm -&gt; 2 mm\n   Shifting avg_y = -2.14199E-05 mm -&gt; 0 mm\n   Scaling sigma_y = 1.99989 mm -&gt; 2 mm\n   Shifting avg_px = -0.0379046 eV/c -&gt; 0 eV/c\n   Scaling sigma_px = 276.852 eV/c -&gt; 276.857 eV/c\n   Shifting avg_py = -0.0437018 eV/c -&gt; 0 eV/c\n   Scaling sigma_py = 276.825 eV/c -&gt; 276.857 eV/c\n   Shifting avg_pz = -0.06805 eV/c -&gt; 0 eV/c\n   Scaling sigma_pz = 276.827 eV/c -&gt; 276.857 eV/c\n   Shifting avg_t = -9.00043E-05 ps -&gt; 0 ps\n   Scaling sigma_t = 1.1547 ps -&gt; 1.1547 ps\n   Cathode start: fixing pz momenta to forward hemisphere\n      avg_pz -&gt; 220.913 eV/c, sigma_pz -&gt; 166.875 eV/c\n...done. Time Elapsed: 339.288 ms.\n\n   Created particles in .particles: \n   ParticleGroup with 100000 particles with total charge 1.0000000000000003e-11 C\nDistribution format: gpt\nOutput file: rad.gaussian.out.txt\n\nCreating beam distribution....\n   Beam starting from: cathode\n   Total charge: 10 pC.\n   Number of macroparticles: 1000000.\n   Assuming cylindrical symmetry...\n   r distribution: radial Gaussian\n   theta distribution: uniform theta\n      min_theta = 0 rad, max_theta = 6.28319 rad\n   t distribution: uniform\n      min_t = -2 ps, max_t = 2 ps\n   px distribution: Gaussian\n      avg_px = 0 eV/c, sigma_px = 276.857 eV/c\n   py distribution: Gaussian\n      avg_py = 0 eV/c, sigma_py = 276.857 eV/c\n   pz distribution: Gaussian\n      avg_pz = 0 eV/c, sigma_pz = 276.857 eV/c\n   Shifting avg_x = -1.5856E-05 mm -&gt; 0 mm\n   Scaling sigma_x = 1.99996 mm -&gt; 2 mm\n   Shifting avg_y = -2.52974E-06 mm -&gt; 0 mm\n   Scaling sigma_y = 1.99999 mm -&gt; 2 mm\n   Shifting avg_px = -0.00462116 eV/c -&gt; 0 eV/c\n   Scaling sigma_px = 276.855 eV/c -&gt; 276.857 eV/c\n   Shifting avg_py = -0.00944177 eV/c -&gt; 0 eV/c\n   Scaling sigma_py = 276.855 eV/c -&gt; 276.857 eV/c\n   Shifting avg_pz = -0.0119469 eV/c -&gt; 0 eV/c\n   Scaling sigma_pz = 276.855 eV/c -&gt; 276.857 eV/c\n   Shifting avg_t = -1.09788E-05 ps -&gt; 0 ps\n   Scaling sigma_t = 1.1547 ps -&gt; 1.1547 ps\n   Cathode start: fixing pz momenta to forward hemisphere\n      avg_pz -&gt; 220.901 eV/c, sigma_pz -&gt; 166.891 eV/c\n...done. Time Elapsed: 3.39724 s.\n\n   Created particles in .particles: \n   ParticleGroup with 1000000 particles with total charge 9.99999999999998e-12 C\nDistribution format: gpt\nOutput file: rad.gaussian.out.txt\n\nCreating beam distribution....\n   Beam starting from: cathode\n   Total charge: 10 pC.\n   Number of macroparticles: 10000000.\n   Assuming cylindrical symmetry...\n   r distribution: radial Gaussian\n   theta distribution: uniform theta\n      min_theta = 0 rad, max_theta = 6.28319 rad\n   t distribution: uniform\n      min_t = -2 ps, max_t = 2 ps\n   px distribution: Gaussian\n      avg_px = 0 eV/c, sigma_px = 276.857 eV/c\n   py distribution: Gaussian\n      avg_py = 0 eV/c, sigma_py = 276.857 eV/c\n   pz distribution: Gaussian\n      avg_pz = 0 eV/c, sigma_pz = 276.857 eV/c\n   Shifting avg_x = -2.57762E-06 mm -&gt; 0 mm\n   Scaling sigma_x = 1.99999 mm -&gt; 2 mm\n   Shifting avg_y = -4.00986E-07 mm -&gt; 0 mm\n   Scaling sigma_y = 2 mm -&gt; 2 mm\n   Shifting avg_px = -0.000374215 eV/c -&gt; 0 eV/c\n   Scaling sigma_px = 276.857 eV/c -&gt; 276.857 eV/c\n   Shifting avg_py = -0.000600273 eV/c -&gt; 0 eV/c\n   Scaling sigma_py = 276.857 eV/c -&gt; 276.857 eV/c\n   Shifting avg_pz = -0.00104701 eV/c -&gt; 0 eV/c\n   Scaling sigma_pz = 276.857 eV/c -&gt; 276.857 eV/c\n   Shifting avg_t = -1.23261E-06 ps -&gt; 0 ps\n   Scaling sigma_t = 1.1547 ps -&gt; 1.1547 ps\n   Cathode start: fixing pz momenta to forward hemisphere\n      avg_pz -&gt; 220.9 eV/c, sigma_pz -&gt; 166.892 eV/c\n...done. Time Elapsed: 34.8159 s.\n\n   Created particles in .particles: \n   ParticleGroup with 10000000 particles with total charge 1.0000000000000125e-11 C\nDistribution format: gpt\nOutput file: rad.gaussian.out.txt\n\nCreating beam distribution....\n   Beam starting from: cathode\n   Total charge: 10 pC.\n   Number of macroparticles: 25000000.\n   Assuming cylindrical symmetry...\n   r distribution: radial Gaussian\n   theta distribution: uniform theta\n      min_theta = 0 rad, max_theta = 6.28319 rad\n   t distribution: uniform\n      min_t = -2 ps, max_t = 2 ps\n   px distribution: Gaussian\n      avg_px = 0 eV/c, sigma_px = 276.857 eV/c\n   py distribution: Gaussian\n      avg_py = 0 eV/c, sigma_py = 276.857 eV/c\n   pz distribution: Gaussian\n      avg_pz = 0 eV/c, sigma_pz = 276.857 eV/c\n   Shifting avg_x = -9.28673E-07 mm -&gt; 0 mm\n   Scaling sigma_x = 2 mm -&gt; 2 mm\n   Shifting avg_y = -8.4613E-08 mm -&gt; 0 mm\n   Scaling sigma_y = 2 mm -&gt; 2 mm\n   Shifting avg_px = -0.000211406 eV/c -&gt; 0 eV/c\n   Scaling sigma_px = 276.857 eV/c -&gt; 276.857 eV/c\n   Shifting avg_py = -0.000548 eV/c -&gt; 0 eV/c\n   Scaling sigma_py = 276.857 eV/c -&gt; 276.857 eV/c\n   Shifting avg_pz = -0.000557315 eV/c -&gt; 0 eV/c\n   Scaling sigma_pz = 276.857 eV/c -&gt; 276.857 eV/c\n   Shifting avg_t = -5.15499E-07 ps -&gt; 0 ps\n   Scaling sigma_t = 1.1547 ps -&gt; 1.1547 ps\n   Cathode start: fixing pz momenta to forward hemisphere\n      avg_pz -&gt; 220.9 eV/c, sigma_pz -&gt; 166.892 eV/c\n...done. Time Elapsed: 88.0815 s.\n\n   Created particles in .particles: \n   ParticleGroup with 25000000 particles with total charge 9.999999999999536e-12 C\nDistribution format: gpt\nOutput file: rad.gaussian.out.txt\n\nCreating beam distribution....\n   Beam starting from: cathode\n   Total charge: 10 pC.\n   Number of macroparticles: 50000000.\n   Assuming cylindrical symmetry...\n   r distribution: radial Gaussian\n   theta distribution: uniform theta\n      min_theta = 0 rad, max_theta = 6.28319 rad\n   t distribution: uniform\n      min_t = -2 ps, max_t = 2 ps\n   px distribution: Gaussian\n      avg_px = 0 eV/c, sigma_px = 276.857 eV/c\n   py distribution: Gaussian\n      avg_py = 0 eV/c, sigma_py = 276.857 eV/c\n   pz distribution: Gaussian\n      avg_pz = 0 eV/c, sigma_pz = 276.857 eV/c\n   Shifting avg_x = -4.81676E-07 mm -&gt; 0 mm\n   Scaling sigma_x = 2 mm -&gt; 2 mm\n   Shifting avg_y = -4.29885E-08 mm -&gt; 0 mm\n   Scaling sigma_y = 2 mm -&gt; 2 mm\n   Shifting avg_px = -7.96742E-05 eV/c -&gt; 0 eV/c\n   Scaling sigma_px = 276.857 eV/c -&gt; 276.857 eV/c\n   Shifting avg_py = -0.000206235 eV/c -&gt; 0 eV/c\n   Scaling sigma_py = 276.857 eV/c -&gt; 276.857 eV/c\n   Shifting avg_pz = -0.000326574 eV/c -&gt; 0 eV/c\n   Scaling sigma_pz = 276.857 eV/c -&gt; 276.857 eV/c\n   Shifting avg_t = -2.78483E-07 ps -&gt; 0 ps\n   Scaling sigma_t = 1.1547 ps -&gt; 1.1547 ps\n   Cathode start: fixing pz momenta to forward hemisphere\n      avg_pz -&gt; 220.9 eV/c, sigma_pz -&gt; 166.892 eV/c\n...done. Time Elapsed: 182.012 s.\n\n   Created particles in .particles: \n   ParticleGroup with 50000000 particles with total charge 1.0000000000000699e-11 C\nDistribution format: gpt\nOutput file: rad.gaussian.out.txt\n\nCreating beam distribution....\n   Beam starting from: cathode\n   Total charge: 10 pC.\n   Number of macroparticles: 100000000.\n   Assuming cylindrical symmetry...\n   r distribution: radial Gaussian\n   theta distribution: uniform theta\n      min_theta = 0 rad, max_theta = 6.28319 rad\n   t distribution: uniform\n      min_t = -2 ps, max_t = 2 ps\n   px distribution: Gaussian\n      avg_px = 0 eV/c, sigma_px = 276.857 eV/c\n   py distribution: Gaussian\n      avg_py = 0 eV/c, sigma_py = 276.857 eV/c\n   pz distribution: Gaussian\n      avg_pz = 0 eV/c, sigma_pz = 276.857 eV/c\n   Shifting avg_x = -2.48076E-07 mm -&gt; 0 mm\n   Scaling sigma_x = 2 mm -&gt; 2 mm\n   Shifting avg_y = -2.18301E-08 mm -&gt; 0 mm\n   Scaling sigma_y = 2 mm -&gt; 2 mm\n   Shifting avg_px = -5.16031E-05 eV/c -&gt; 0 eV/c\n   Scaling sigma_px = 276.857 eV/c -&gt; 276.857 eV/c\n   Shifting avg_py = -0.000121808 eV/c -&gt; 0 eV/c\n   Scaling sigma_py = 276.857 eV/c -&gt; 276.857 eV/c\n   Shifting avg_pz = -0.000158586 eV/c -&gt; 0 eV/c\n   Scaling sigma_pz = 276.857 eV/c -&gt; 276.857 eV/c\n   Shifting avg_t = -1.44598E-07 ps -&gt; 0 ps\n   Scaling sigma_t = 1.1547 ps -&gt; 1.1547 ps\n   Cathode start: fixing pz momenta to forward hemisphere\n      avg_pz -&gt; 220.9 eV/c, sigma_pz -&gt; 166.892 eV/c\n...done. Time Elapsed: 390.299 s.\n\n   Created particles in .particles: \n   ParticleGroup with 100000000 particles with total charge 9.999999999999717e-12 C\n</pre> In\u00a0[9]: Copied! <pre>p_times = []\n\nfor n_part in n_particles:\n\n    G['n_particle'] = n_part\n\n    # Run in serial:\n    ts0 = time()\n    G.run(max_workers=10)\n    ts1 = time()\n\n    p_times.append(ts1-ts0)\n</pre> p_times = []  for n_part in n_particles:      G['n_particle'] = n_part      # Run in serial:     ts0 = time()     G.run(max_workers=10)     ts1 = time()      p_times.append(ts1-ts0) <pre>Creating particles in parallel with 10 workers\n   Setting up workers...done.\n   Executing worker tasks...done\n   Collecting beamlets...   Created particles in .particles: \n   ParticleGroup with 100 particles with total charge 1e-11 C\nCreating particles in parallel with 10 workers\n   Setting up workers...done.\n   Executing worker tasks...done\n   Collecting beamlets...   Created particles in .particles: \n   ParticleGroup with 1000 particles with total charge 1e-11 C\nCreating particles in parallel with 10 workers\n   Setting up workers...done.\n   Executing worker tasks...done\n   Collecting beamlets...   Created particles in .particles: \n   ParticleGroup with 10000 particles with total charge 1.0000000000000003e-11 C\nCreating particles in parallel with 10 workers\n   Setting up workers...done.\n   Executing worker tasks...done\n   Collecting beamlets...   Created particles in .particles: \n   ParticleGroup with 100000 particles with total charge 1.0000000000000003e-11 C\nCreating particles in parallel with 10 workers\n   Setting up workers...done.\n   Executing worker tasks...done\n   Collecting beamlets...   Created particles in .particles: \n   ParticleGroup with 1000000 particles with total charge 9.99999999999998e-12 C\nCreating particles in parallel with 10 workers\n   Setting up workers...done.\n   Executing worker tasks...done\n   Collecting beamlets...   Created particles in .particles: \n   ParticleGroup with 10000000 particles with total charge 1.0000000000000125e-11 C\nCreating particles in parallel with 10 workers\n   Setting up workers...done.\n   Executing worker tasks...done\n   Collecting beamlets...   Created particles in .particles: \n   ParticleGroup with 25000000 particles with total charge 9.999999999999536e-12 C\nCreating particles in parallel with 10 workers\n   Setting up workers...done.\n   Executing worker tasks...done\n   Collecting beamlets...   Created particles in .particles: \n   ParticleGroup with 50000000 particles with total charge 1.0000000000000699e-11 C\nCreating particles in parallel with 10 workers\n   Setting up workers...done.\n   Executing worker tasks...done\n   Collecting beamlets...   Created particles in .particles: \n   ParticleGroup with 100000000 particles with total charge 9.999999999999717e-12 C\n</pre> In\u00a0[11]: Copied! <pre>plt.loglog(n_particles, s_times)\nplt.semilogx(n_particles, p_times)\nplt.xlabel('n_particle')\nplt.ylabel('time (sec)')\nplt.legend(['series', 'parallel, 10 workers'])\n</pre> plt.loglog(n_particles, s_times) plt.semilogx(n_particles, p_times) plt.xlabel('n_particle') plt.ylabel('time (sec)') plt.legend(['series', 'parallel, 10 workers']) Out[11]: <pre>&lt;matplotlib.legend.Legend at 0x15ee9fa00&gt;</pre> In\u00a0[19]: Copied! <pre>G = Generator('data/rad.gaussian.in.yaml', verbose=0)\nG['n_particle'] = 1_000_000\n\npgs = [G.run() for ii in range(10)]\n</pre> G = Generator('data/rad.gaussian.in.yaml', verbose=0) G['n_particle'] = 1_000_000  pgs = [G.run() for ii in range(10)] In\u00a0[20]: Copied! <pre>np.hstack([pg['x'] for pg in pgs])\n</pre> np.hstack([pg['x'] for pg in pgs]) Out[20]: <pre>array([0.00128888, 0.00305052, 0.0021455 , ..., 0.00260326, 0.00176102,\n       0.00371194])</pre> In\u00a0[25]: Copied! <pre>data = {k:np.hstack([pg[k] for pg in pgs]) for k in pgs[0].data.keys() if k not in ['species']}\n</pre> data = {k:np.hstack([pg[k] for pg in pgs]) for k in pgs[0].data.keys() if k not in ['species']} In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/surface_emitter/","title":"Surface emitter","text":"In\u00a0[1]: Copied! <pre># Useful for debugging\n%load_ext autoreload\n%autoreload 2\n%config InlineBackend.figure_format = 'retina'\n\nimport os\nimport yaml\nimport numpy as np\n</pre> # Useful for debugging %load_ext autoreload %autoreload 2 %config InlineBackend.figure_format = 'retina'  import os import yaml import numpy as np In\u00a0[2]: Copied! <pre>from distgen import Generator\n</pre> from distgen import Generator In\u00a0[3]: Copied! <pre>input_yaml = \"\"\"\nn_particle: 100000\nstart: \n  type: free\nrandom:\n  type: hammersley\ntotal_charge:\n  units: pC\n  value: 10\nr_dist:\n  max_r:\n    units: mm\n    value: 1\n  type: radial_uniform\np_dist:\n  sigma_p:\n    value: 1\n    units: eV/c\n  avg_p: \n    value: 100\n    units: eV/c\n  type: gaussian\n\"\"\"\n</pre> input_yaml = \"\"\" n_particle: 100000 start:    type: free random:   type: hammersley total_charge:   units: pC   value: 10 r_dist:   max_r:     units: mm     value: 1   type: radial_uniform p_dist:   sigma_p:     value: 1     units: eV/c   avg_p:      value: 100     units: eV/c   type: gaussian \"\"\" In\u00a0[4]: Copied! <pre>gen = Generator(input_yaml, verbose=True)\n</pre> gen = Generator(input_yaml, verbose=True) In\u00a0[5]: Copied! <pre>P = gen.run()\n</pre> P = gen.run() <pre>Distribution format: None\n   Warning: no output file specified, defaulting to \"None\".\nOutput file: None\n\nCreating beam distribution....\n   Beam starting from: free\n   Total charge: 10 pC.\n   Number of macroparticles: 100000.\n   Assuming cylindrical symmetry...\n   r distribution: radial uniform\n      min_r = 0 mm, max_r = 1 mm\n   theta distribution: uniform theta\n      min_theta = 0 rad, max_theta = 6.28319 rad\n   p distribution: Gaussian\n      avg_p = 100 eV/c, sigma_p = 1.000 eV/c\n   azimuthal angle distribution: uniform theta\n      min_theta = 0 rad, max_theta = 6.28319 rad\n   polar angle distribution: uniform phi\n      min_phi = 0 rad, max_phi = 3.14159 rad\n   Shifting avg_x = -4.85224E-08 mm -&gt; 0 mm\n   Scaling sigma_x = 0.499991 mm -&gt; 0.5 mm\n   Shifting avg_y = 1.44675E-06 mm -&gt; 0 mm\n   Scaling sigma_y = 0.49999 mm -&gt; 0.5 mm\n   Shifting avg_px = -3.3074E-05 eV/c -&gt; -6.12323E-15 eV/c\n   Scaling sigma_px = 57.7382 eV/c -&gt; 57.7379 eV/c\n   Shifting avg_py = 1.54491E-06 eV/c -&gt; 0 eV/c\n   Scaling sigma_py = 57.7382 eV/c -&gt; 57.7379 eV/c\n   Shifting avg_pz = -0.000118434 eV/c -&gt; 6.12323E-15 eV/c\n   Scaling sigma_pz = 57.7372 eV/c -&gt; 57.7379 eV/c\n...done. Time Elapsed: 451.074 ms.\n\n   Created particles in .particles: \n   ParticleGroup with 100000 particles with total charge 1.0000000000000003e-11 C</pre> In\u00a0[6]: Copied! <pre>P.plot('p')\n</pre> P.plot('p') In\u00a0[7]: Copied! <pre>P.plot('x', 'px')\n</pre> P.plot('x', 'px') In\u00a0[8]: Copied! <pre>P.plot('pz')\n</pre> P.plot('pz') In\u00a0[9]: Copied! <pre>P.plot('px')\n</pre> P.plot('px') In\u00a0[10]: Copied! <pre>P.plot('py')\n</pre> P.plot('py') In\u00a0[13]: Copied! <pre>from matplotlib import pyplot as plt\nfig = plt.figure()\nax = fig.add_subplot(projection='3d')\n\npx, py, pz = P['px'], P['py'], P['pz']\n\np = np.sqrt(px**2 + py**2 + pz**2)\n\ntheta = np.arctan2(py, px)\nphi = np.arccos(pz/p)\nhist, pedges = np.histogram(phi, bins=100, density=True)\npcs = (pedges[1:] + pedges[:-1]) / 2\n\nx = px/p\ny = py/p\nz = pz/p\n\nax.scatter(x[::200], y[::200], z[::200], '.');\nax.set_xlabel('$\\hat{p}_x$')\nax.set_ylabel('$\\hat{p}_y$')\nax.set_zlabel('$\\hat{p}_z$')\n</pre> from matplotlib import pyplot as plt fig = plt.figure() ax = fig.add_subplot(projection='3d')  px, py, pz = P['px'], P['py'], P['pz']  p = np.sqrt(px**2 + py**2 + pz**2)  theta = np.arctan2(py, px) phi = np.arccos(pz/p) hist, pedges = np.histogram(phi, bins=100, density=True) pcs = (pedges[1:] + pedges[:-1]) / 2  x = px/p y = py/p z = pz/p  ax.scatter(x[::200], y[::200], z[::200], '.'); ax.set_xlabel('$\\hat{p}_x$') ax.set_ylabel('$\\hat{p}_y$') ax.set_zlabel('$\\hat{p}_z$') Out[13]: <pre>Text(0.5, 0, '$\\\\hat{p}_z$')</pre> In\u00a0[14]: Copied! <pre>theta = np.arctan2(py, px)\nphi = np.arccos(pz/p)\nhist, pedges = np.histogram(phi, bins=100, density=True)\npcs = (pedges[1:] + pedges[:-1]) / 2\n\nplt.plot(pcs, hist);\n</pre> theta = np.arctan2(py, px) phi = np.arccos(pz/p) hist, pedges = np.histogram(phi, bins=100, density=True) pcs = (pedges[1:] + pedges[:-1]) / 2  plt.plot(pcs, hist); In\u00a0[15]: Copied! <pre>rns = np.random.random(100000)\n</pre> rns = np.random.random(100000) In\u00a0[16]: Copied! <pre>pa = 0\npb = np.pi\n\nCa = np.cos(pa)\nCb = np.cos(pb)\n</pre> pa = 0 pb = np.pi  Ca = np.cos(pa) Cb = np.cos(pb) In\u00a0[17]: Copied! <pre>rho = 1/(Ca-Cb)\n</pre> rho = 1/(Ca-Cb) In\u00a0[18]: Copied! <pre>phis = np.linspace(pa, pb, 1000)\n</pre> phis = np.linspace(pa, pb, 1000) In\u00a0[19]: Copied! <pre>plt.plot(phis, rho*np.sin(phis));\n</pre> plt.plot(phis, rho*np.sin(phis)); In\u00a0[20]: Copied! <pre>np.trapz(rho*np.sin(phis), phis)\n</pre> np.trapz(rho*np.sin(phis), phis) Out[20]: <pre>0.999999175885426</pre> In\u00a0[21]: Copied! <pre>cdf = (Ca - np.cos(phis))*rho\n</pre> cdf = (Ca - np.cos(phis))*rho In\u00a0[22]: Copied! <pre>from scipy.integrate import cumtrapz\n</pre> from scipy.integrate import cumtrapz In\u00a0[23]: Copied! <pre>plt.plot(phis, cdf, phis, cumtrapz(rho*np.sin(phis), phis, initial=0));\n</pre> plt.plot(phis, cdf, phis, cumtrapz(rho*np.sin(phis), phis, initial=0)); In\u00a0[24]: Copied! <pre>ps = np.arccos( Ca - rns*(Ca-Cb) )\n</pre> ps = np.arccos( Ca - rns*(Ca-Cb) ) In\u00a0[25]: Copied! <pre>hist, pedges = np.histogram(ps, bins=30, density=True)\n</pre> hist, pedges = np.histogram(ps, bins=30, density=True) In\u00a0[26]: Copied! <pre>pcs = (pedges[1:] + pedges[:-1]) / 2\n</pre> pcs = (pedges[1:] + pedges[:-1]) / 2 In\u00a0[27]: Copied! <pre>plt.plot(pcs, hist, phis, rho*np.sin(phis));\n</pre> plt.plot(pcs, hist, phis, rho*np.sin(phis)); In\u00a0[36]: Copied! <pre>gen = Generator('data/beer.can.in.yaml', verbose=1)\n\n#print(gen)\n</pre> gen = Generator('data/beer.can.in.yaml', verbose=1)  #print(gen) <pre>/Users/colwyngulliford/GitHub/distgen/distgen/generator.py:232: UserWarning: Input variable n_particle was a float, expected int.\n  warnings.warn('Input variable n_particle was a float, expected int.')\n</pre> In\u00a0[37]: Copied! <pre>P1 = gen.run()\n</pre> P1 = gen.run() <pre>Distribution format: gpt\nOutput file: beer.can.out.txt\n\nCreating beam distribution....\n   Beam starting from: cathode\n   Total charge: 10 pC.\n   Number of macroparticles: 200000.\n   Assuming cylindrical symmetry...\n   r distribution: radial uniform\n      min_r = 0 mm, max_r = 2 mm\n   theta distribution: uniform theta\n      min_theta = 0 rad, max_theta = 6.28319 rad\n   t distribution: uniform\n      min_t = -2 ps, max_t = 2 ps\n   px distribution: Gaussian\n      avg_px = 0 eV/c, sigma_px = 276.857 eV/c\n   py distribution: Gaussian\n      avg_py = 0 eV/c, sigma_py = 276.857 eV/c\n   pz distribution: Gaussian\n      avg_pz = 0 eV/c, sigma_pz = 276.857 eV/c\n   Shifting avg_x = -2.10539E-05 mm -&gt; 0 mm\n   Scaling sigma_x = 0.999982 mm -&gt; 1 mm\n   Shifting avg_y = -1.97648E-06 mm -&gt; 0 mm\n   Scaling sigma_y = 0.999998 mm -&gt; 1 mm\n   Shifting avg_px = -0.0212516 eV/c -&gt; 0 eV/c\n   Scaling sigma_px = 276.849 eV/c -&gt; 276.857 eV/c\n   Shifting avg_py = -0.0259627 eV/c -&gt; 0 eV/c\n   Scaling sigma_py = 276.844 eV/c -&gt; 276.857 eV/c\n   Shifting avg_pz = -0.0372953 eV/c -&gt; 0 eV/c\n   Scaling sigma_pz = 276.843 eV/c -&gt; 276.857 eV/c\n   Shifting avg_t = -4.90022E-05 ps -&gt; 0 ps\n   Scaling sigma_t = 1.1547 ps -&gt; 1.1547 ps\n   Cathode start: fixing pz momenta to forward hemisphere\n      avg_pz -&gt; 220.904 eV/c, sigma_pz -&gt; 166.887 eV/c\n...done. Time Elapsed: 1.05421 s.\n\n   Created particles in .particles: \n   ParticleGroup with 200000 particles with total charge 1.0000000000000003e-11 C</pre> In\u00a0[38]: Copied! <pre>P1.plot('x', 'px')\n</pre> P1.plot('x', 'px') In\u00a0[39]: Copied! <pre>P1.plot('p')\n</pre> P1.plot('p') In\u00a0[40]: Copied! <pre>P1.plot('pz')\n</pre> P1.plot('pz') In\u00a0[41]: Copied! <pre>P1['sigma_px'], P1['sigma_py'], P1['sigma_pz']\n</pre> P1['sigma_px'], P1['sigma_py'], P1['sigma_pz'] Out[41]: <pre>(276.8570795554991, 276.8570795554992, 166.88683722575215)</pre> In\u00a0[77]: Copied! <pre>gen = Generator('data/maxwell_boltzmann.beer.can.in.yaml', verbose=1)\n</pre> gen = Generator('data/maxwell_boltzmann.beer.can.in.yaml', verbose=1) In\u00a0[78]: Copied! <pre>P2 = gen.run()\n</pre> P2 = gen.run() <pre>Distribution format: gpt\nOutput file: beer.can.out.txt\n\nCreating beam distribution....\n   Beam starting from: cathode\n   Total charge: 10 pC.\n   Number of macroparticles: 200000.\n   Assuming cylindrical symmetry...\n   r distribution: radial uniform\n      min_r = 0 mm, max_r = 2 mm\n   theta distribution: uniform theta\n      min_theta = 0 rad, max_theta = 6.28319 rad\n   p distribution: Maxwell-Boltzmann\n      p scale = 276.857 eV/c\n   azimuthal angle distribution: uniform theta\n      min_theta = 0 rad, max_theta = 6.28319 rad\n   polar angle distribution: uniform phi\n      min_phi = 0 rad, max_phi = 3.14159 rad\n   t distribution: uniform\n      min_t = -2 ps, max_t = 2 ps\n   Shifting avg_x = 1.63849E-05 mm -&gt; 0 mm\n   Scaling sigma_x = 0.999984 mm -&gt; 1 mm\n   Shifting avg_y = -2.77139E-06 mm -&gt; 0 mm\n   Scaling sigma_y = 0.999996 mm -&gt; 1 mm\n   Shifting avg_px = -0.000954618 eV/c -&gt; -2.70524E-14 eV/c\n   Scaling sigma_px = 276.853 eV/c -&gt; 276.857 eV/c\n   Shifting avg_py = 0.000856608 eV/c -&gt; 0 eV/c\n   Scaling sigma_py = 276.848 eV/c -&gt; 276.857 eV/c\n   Shifting avg_pz = -0.0142766 eV/c -&gt; 2.70524E-14 eV/c\n   Scaling sigma_pz = 276.833 eV/c -&gt; 276.857 eV/c\n   Shifting avg_t = -4.90022E-05 ps -&gt; 0 ps\n   Scaling sigma_t = 1.1547 ps -&gt; 1.1547 ps\n   Cathode start: fixing pz momenta to forward hemisphere\n      avg_pz -&gt; 220.909 eV/c, sigma_pz -&gt; 166.881 eV/c\n...done. Time Elapsed: 912.85 ms.\n\n   Created particles in .particles: \n   ParticleGroup with 200000 particles with total charge 1.0000000000000003e-11 C</pre> In\u00a0[79]: Copied! <pre>P2['sigma_px'], P2['sigma_py'], P2['sigma_pz']\n</pre> P2['sigma_px'], P2['sigma_py'], P2['sigma_pz'] Out[79]: <pre>(276.85707955549907, 276.85707955549907, 166.88083659251544)</pre> In\u00a0[80]: Copied! <pre>gen = Generator('data/maxwell_boltzmann_KE.beer.can.in.yaml', verbose=1)\n</pre> gen = Generator('data/maxwell_boltzmann_KE.beer.can.in.yaml', verbose=1) In\u00a0[81]: Copied! <pre>P3 = gen.run()\n</pre> P3 = gen.run() <pre>Distribution format: gpt\nOutput file: beer.can.out.txt\n\nCreating beam distribution....\n   Beam starting from: cathode\n   Total charge: 10 pC.\n   Number of macroparticles: 200000.\n   Assuming cylindrical symmetry...\n   r distribution: radial uniform\n      min_r = 0 mm, max_r = 2 mm\n   theta distribution: uniform theta\n      min_theta = 0 rad, max_theta = 6.28319 rad\n   KE distribution: Maxwell-Boltzmann Energy\n      kT = 150 meV\n   azimuthal angle distribution: uniform theta\n      min_theta = 0 rad, max_theta = 6.28319 rad\n   polar angle distribution: uniform phi\n      min_phi = 0 rad, max_phi = 3.14159 rad\n   t distribution: uniform\n      min_t = -2 ps, max_t = 2 ps\n   Shifting avg_x = 1.63849E-05 mm -&gt; 0 mm\n   Scaling sigma_x = 0.999984 mm -&gt; 1 mm\n   Shifting avg_y = -2.77139E-06 mm -&gt; 0 mm\n   Scaling sigma_y = 0.999996 mm -&gt; 1 mm\n   Shifting avg_px = -0.000526097 eV/c -&gt; -2.7043E-14 eV/c\n   Scaling sigma_px = 276.708 eV/c -&gt; 276.7 eV/c\n   Shifting avg_py = 0.00036565 eV/c -&gt; 0 eV/c\n   Scaling sigma_py = 276.702 eV/c -&gt; 276.7 eV/c\n   Shifting avg_pz = -0.0134587 eV/c -&gt; 2.7043E-14 eV/c\n   Scaling sigma_pz = 276.69 eV/c -&gt; 276.7 eV/c\n   Shifting avg_t = -4.90022E-05 ps -&gt; 0 ps\n   Scaling sigma_t = 1.1547 ps -&gt; 1.1547 ps\n   Cathode start: fixing pz momenta to forward hemisphere\n      avg_pz -&gt; 220.827 eV/c, sigma_pz -&gt; 166.728 eV/c\n...done. Time Elapsed: 913.835 ms.\n\n   Created particles in .particles: \n   ParticleGroup with 200000 particles with total charge 1.0000000000000003e-11 C</pre> In\u00a0[82]: Copied! <pre>P3.plot('kinetic_energy')\n</pre> P3.plot('kinetic_energy') In\u00a0[83]: Copied! <pre>P3.plot('x', 'px')\n</pre> P3.plot('x', 'px') In\u00a0[86]: Copied! <pre>P3['sigma_px'], P3['sigma_py'], P3['sigma_pz']\n</pre> P3['sigma_px'], P3['sigma_py'], P3['sigma_pz'] Out[86]: <pre>(276.7000087216931, 276.7000087216931, 166.72798635897524)</pre> In\u00a0[88]: Copied! <pre>fig = plt.figure()\nax = fig.add_subplot(projection='3d')\n\npx, py, pz = P3['px'], P3['py'], P3['pz']\n\np = np.sqrt(px**2 + py**2 + pz**2)\n\ntheta = np.arctan2(py, px)\nphi = np.arccos(pz/p)\nhist, pedges = np.histogram(phi, bins=100, density=True)\npcs = (pedges[1:] + pedges[:-1]) / 2\n\nx = px/p\ny = py/p\nz = pz/p\n\nax.scatter(x[::500], y[::500], z[::500], '.');\nax.set_xlabel('$\\hat{p}_x$')\nax.set_ylabel('$\\hat{p}_y$')\nax.set_zlabel('$\\hat{p}_z$')\n</pre> fig = plt.figure() ax = fig.add_subplot(projection='3d')  px, py, pz = P3['px'], P3['py'], P3['pz']  p = np.sqrt(px**2 + py**2 + pz**2)  theta = np.arctan2(py, px) phi = np.arccos(pz/p) hist, pedges = np.histogram(phi, bins=100, density=True) pcs = (pedges[1:] + pedges[:-1]) / 2  x = px/p y = py/p z = pz/p  ax.scatter(x[::500], y[::500], z[::500], '.'); ax.set_xlabel('$\\hat{p}_x$') ax.set_ylabel('$\\hat{p}_y$') ax.set_zlabel('$\\hat{p}_z$') Out[88]: <pre>Text(0.5, 0, '$\\\\hat{p}_z$')</pre> In\u00a0[124]: Copied! <pre>KE = np.linspace(0, 150, 10000)\n\nE0=3.5\n\nA1 = 0.8,\nm1 = 8\n\nA2 = 0.1\nm2 = 90\n\nPKE = A1*np.exp(-np.abs(KE-E0)/m1) + A2*np.exp(-np.abs(KE-E0)/m2) \nPKE = PKE/np.trapz(PKE, KE)  # Numerically intergate to normalize\n\nplt.plot(KE, PKE);\nplt.xlabel('KE (eV)');\nplt.ylabel('$\\\\rho(KE)$ (1/eV)');\n</pre> KE = np.linspace(0, 150, 10000)  E0=3.5  A1 = 0.8, m1 = 8  A2 = 0.1 m2 = 90  PKE = A1*np.exp(-np.abs(KE-E0)/m1) + A2*np.exp(-np.abs(KE-E0)/m2)  PKE = PKE/np.trapz(PKE, KE)  # Numerically intergate to normalize  plt.plot(KE, PKE); plt.xlabel('KE (eV)'); plt.ylabel('$\\\\rho(KE)$ (1/eV)'); In\u00a0[125]: Copied! <pre>dat = np.zeros((len(KE),2))\ndat[:,0], dat[:,1] = KE, PKE\n\nnp.savetxt('KEdist.txt', dat, header=\"KE     PKE\", comments='')\n</pre> dat = np.zeros((len(KE),2)) dat[:,0], dat[:,1] = KE, PKE  np.savetxt('KEdist.txt', dat, header=\"KE     PKE\", comments='') In\u00a0[674]: Copied! <pre>q = 1000*1.60217663e-19\n\nprint(q)\n\ninput_yaml = \"\"\"\nn_particle: 1000\noutput: \n  file: test_simion_writer.ion\n  type: simion\nstart: \n  type: cathode\nrandom:\n  type: hammersley\ntotal_charge:\n  units: C\n  value: 1.60217663e-17\nr_dist:\n  max_r:\n    units: mm\n    value: 14.6\n  type: radial_uniform\nKE_dist:\n  file: KEdist.txt\n  units: eV\n  type: file1d\ntransforms:\n  sx:\n    avg_x:\n      units: millimeter\n      value: -50\n    type: set_avg x\n  sy:\n    avg_y:\n      units: millimeter\n      value: 50\n    type: set_avg y\n  sz:\n    avg_z:\n      units: millimeter\n      value: 65\n    type: set_avg z\n\"\"\"\n</pre> q = 1000*1.60217663e-19  print(q)  input_yaml = \"\"\" n_particle: 1000 output:    file: test_simion_writer.ion   type: simion start:    type: cathode random:   type: hammersley total_charge:   units: C   value: 1.60217663e-17 r_dist:   max_r:     units: mm     value: 14.6   type: radial_uniform KE_dist:   file: KEdist.txt   units: eV   type: file1d transforms:   sx:     avg_x:       units: millimeter       value: -50     type: set_avg x   sy:     avg_y:       units: millimeter       value: 50     type: set_avg y   sz:     avg_z:       units: millimeter       value: 65     type: set_avg z \"\"\" <pre>1.6021766299999998e-16\n</pre> In\u00a0[675]: Copied! <pre>import yaml\n\ninputs = yaml.safe_load(input_yaml)\n\nn = 1000\n\ninputs['n_particle'] = n\ninputs['output']['file'] = 'test_ion_writer.ion'\ninputs['output']['type'] = 'simion'\ninputs['total_charge']['value'] = n*1.60217663e-19\ninputs['transforms']['sx']['avg_x']['value'] = -50\ninputs['transforms']['sy']['avg_y']['value'] = 50\ninputs['transforms']['sz']['avg_z']['value'] = 55\n</pre> import yaml  inputs = yaml.safe_load(input_yaml)  n = 1000  inputs['n_particle'] = n inputs['output']['file'] = 'test_ion_writer.ion' inputs['output']['type'] = 'simion' inputs['total_charge']['value'] = n*1.60217663e-19 inputs['transforms']['sx']['avg_x']['value'] = -50 inputs['transforms']['sy']['avg_y']['value'] = 50 inputs['transforms']['sz']['avg_z']['value'] = 55 In\u00a0[676]: Copied! <pre>gen = Generator(inputs, verbose=1)\n</pre> gen = Generator(inputs, verbose=1)  In\u00a0[677]: Copied! <pre>P = gen.run()\n</pre> P = gen.run() <pre>Distribution format: simion\nOutput file: /Users/colwyngulliford/GitHub/distgen/docs/examples/test_ion_writer.ion\n\nCreating beam distribution....\n   Beam starting from: cathode\n   Total charge: 1.60218E-16 C.\n   Number of macroparticles: 1000.\n   Assuming cylindrical symmetry...\n   r distribution: radial uniform\n      min_r = 0 mm, max_r = 14.6 mm\n   theta distribution: uniform theta\n      min_theta = 0 rad, max_theta = 6.28319 rad\n   KE distribution: KE-distribution file: \"/Users/colwyngulliford/GitHub/distgen/docs/examples/KEdist.txt\"\n   azimuthal angle distribution: uniform theta\n      min_theta = 0 rad, max_theta = 6.28319 rad\n   polar angle distribution: uniform phi\n      min_phi = 0 rad, max_phi = 3.14159 rad\n   Shifting avg_x = 0.00564031 mm -&gt; 0 mm\n   Scaling sigma_x = 7.29551 mm -&gt; 7.3 mm\n   Shifting avg_y = 0.00120927 mm -&gt; 0 mm\n   Scaling sigma_y = 7.29741 mm -&gt; 7.3 mm\n   Shifting avg_px = -6.05715E-09 eV\u00b7s/m -&gt; -9.5489E-22 eV\u00b7s/m\n   Scaling sigma_px = 1.07391E-05 eV\u00b7s/m -&gt; 1.0734E-05 eV\u00b7s/m\n   Shifting avg_py = -2.57E-09 eV\u00b7s/m -&gt; 0 eV\u00b7s/m\n   Scaling sigma_py = 1.07565E-05 eV\u00b7s/m -&gt; 1.0734E-05 eV\u00b7s/m\n   Shifting avg_pz = -2.40928E-08 eV\u00b7s/m -&gt; 9.5489E-22 eV\u00b7s/m\n   Scaling sigma_pz = 1.07063E-05 eV\u00b7s/m -&gt; 1.0734E-05 eV\u00b7s/m\n   Cathode start: fixing pz momenta to forward hemisphere\n      avg_pz -&gt; 7.80217E-06 eV\u00b7s/m, sigma_pz -&gt; 7.37191E-06 eV\u00b7s/m\n   Applying user supplied transform: \"sx\" = set_avg x...\n      Setting avg_x -&gt; -50 mm.\n   Applying user supplied transform: \"sy\" = set_avg y...\n      Setting avg_y -&gt; 50 mm.\n   Applying user supplied transform: \"sz\" = set_avg z...\n      Setting avg_z -&gt; 55 mm.\n...done. Time Elapsed: 78.516 ms.\n\n   Created particles in .particles: \n   ParticleGroup with 1000 particles with total charge 1.6021766300000003e-16 C</pre> In\u00a0[678]: Copied! <pre>P.plot('x', 'y', figsize=(5,5))\n</pre> P.plot('x', 'y', figsize=(5,5)) In\u00a0[665]: Copied! <pre>P.plot('x', 'px', figsize=(5,5))\n</pre> P.plot('x', 'px', figsize=(5,5)) In\u00a0[666]: Copied! <pre>P.plot('kinetic_energy')\n</pre> P.plot('kinetic_energy') In\u00a0[717]: Copied! <pre>from distgen.writers import writer\n\nwriter('simion', gen.beam(), 'test_ion_writer.ion', params={'color':0})\n</pre> from distgen.writers import writer  writer('simion', gen.beam(), 'test_ion_writer.ion', params={'color':0}) <pre>Distribution format: simion\nOutput file: /Users/colwyngulliford/GitHub/distgen/docs/examples/test_ion_writer.ion\n\nCreating beam distribution....\n   Beam starting from: cathode\n   Total charge: 1.60218E-16 C.\n   Number of macroparticles: 1000.\n   Assuming cylindrical symmetry...\n   r distribution: radial uniform\n      min_r = 0 mm, max_r = 14.6 mm\n   theta distribution: uniform theta\n      min_theta = 0 rad, max_theta = 6.28319 rad\n   KE distribution: KE-distribution file: \"/Users/colwyngulliford/GitHub/distgen/docs/examples/KEdist.txt\"\n   azimuthal angle distribution: uniform theta\n      min_theta = 0 rad, max_theta = 6.28319 rad\n   polar angle distribution: uniform phi\n      min_phi = 0 rad, max_phi = 3.14159 rad\n   Shifting avg_x = 0.00564031 mm -&gt; 0 mm\n   Scaling sigma_x = 7.29551 mm -&gt; 7.3 mm\n   Shifting avg_y = 0.00120927 mm -&gt; 0 mm\n   Scaling sigma_y = 7.29741 mm -&gt; 7.3 mm\n   Shifting avg_px = -6.05715E-09 eV\u00b7s/m -&gt; -9.5489E-22 eV\u00b7s/m\n   Scaling sigma_px = 1.07391E-05 eV\u00b7s/m -&gt; 1.0734E-05 eV\u00b7s/m\n   Shifting avg_py = -2.57E-09 eV\u00b7s/m -&gt; 0 eV\u00b7s/m\n   Scaling sigma_py = 1.07565E-05 eV\u00b7s/m -&gt; 1.0734E-05 eV\u00b7s/m\n   Shifting avg_pz = -2.40928E-08 eV\u00b7s/m -&gt; 9.5489E-22 eV\u00b7s/m\n   Scaling sigma_pz = 1.07063E-05 eV\u00b7s/m -&gt; 1.0734E-05 eV\u00b7s/m\n   Cathode start: fixing pz momenta to forward hemisphere\n      avg_pz -&gt; 7.80217E-06 eV\u00b7s/m, sigma_pz -&gt; 7.37191E-06 eV\u00b7s/m\n   Applying user supplied transform: \"sx\" = set_avg x...\n      Setting avg_x -&gt; -50 mm.\n   Applying user supplied transform: \"sy\" = set_avg y...\n      Setting avg_y -&gt; 50 mm.\n   Applying user supplied transform: \"sz\" = set_avg z...\n      Setting avg_z -&gt; 55 mm.\n...done. Time Elapsed: 69.241 ms.\n\n1.6021766299999998e-16 -1.602176634e-19\n</pre> In\u00a0[668]: Copied! <pre>from scipy.constants import physical_constants\n\nmc2 = 1e6 * physical_constants['electron mass energy equivalent in MeV'][0]\ne_= physical_constants['elementary charge'][0]\nme = physical_constants['electron mass in u'][0]\n\ndef particle_group_to_SIMION(P, filename, color=0):\n    \n    header=';0'\n    \n    simion_params= ['TOB', 'MASS', 'CHARGE', 'X', 'Y', 'Z', 'AZ', 'EL', 'KE', 'CWF', 'COLOR']\n    \n    simion_units = {'TOB':'usec', 'MASS':'amu', 'CHARGE':'e', 'X':'mm', 'Y':'mm', 'Z':'mm', 'AZ':'deg', 'EL':'deg', 'CWF':'', 'COLOR':''}\n    \n    data = np.zeros( (len(P), len(simion_params)) )\n    \n    data[:, simion_params.index('TOB')] = P.t*1e6    # [P.t] = sec, convert to usec\n    \n    if(P.species == 'electron'):\n        data[:, simion_params.index('MASS')] = np.full(len(P), me)\n        data[:, simion_params.index('CHARGE')] = np.full(len(P), -1)\n    else:\n        raise ValueError(f'Species {P.species} is not supported')\n    \n    data[:, simion_params.index('X')] =  P.z*1e3\n    data[:, simion_params.index('Y')] =  P.y*1e3\n    data[:, simion_params.index('Z')] = -P.x*1e3\n    \n    px =  P.pz\n    py =  P.py\n    pz = -P.px\n    \n    data[:, simion_params.index('KE')] = P.kinetic_energy       # [eV] \n    data[:, simion_params.index('AZ')] = np.arctan2(-pz, px) * (180/np.pi)   # [deg]\n    data[:, simion_params.index('EL')] = np.arctan2(py, np.sqrt(px**2 + pz**2) ) * (180/np.pi) # [deg]\n    \n    data[:, simion_params.index('CWF')] = P.weight/e_                       # Charge Weighting Factor, derive from particle group weights\n    data[:, simion_params.index('COLOR')] = np.full(len(P), color)\n    #fname, X, fmt='%.18e', delimiter=' '\n    \n    np.savetxt(filename, data, delimiter=',', header=header, comments='', fmt='  %.9e')\n</pre> from scipy.constants import physical_constants  mc2 = 1e6 * physical_constants['electron mass energy equivalent in MeV'][0] e_= physical_constants['elementary charge'][0] me = physical_constants['electron mass in u'][0]  def particle_group_to_SIMION(P, filename, color=0):          header=';0'          simion_params= ['TOB', 'MASS', 'CHARGE', 'X', 'Y', 'Z', 'AZ', 'EL', 'KE', 'CWF', 'COLOR']          simion_units = {'TOB':'usec', 'MASS':'amu', 'CHARGE':'e', 'X':'mm', 'Y':'mm', 'Z':'mm', 'AZ':'deg', 'EL':'deg', 'CWF':'', 'COLOR':''}          data = np.zeros( (len(P), len(simion_params)) )          data[:, simion_params.index('TOB')] = P.t*1e6    # [P.t] = sec, convert to usec          if(P.species == 'electron'):         data[:, simion_params.index('MASS')] = np.full(len(P), me)         data[:, simion_params.index('CHARGE')] = np.full(len(P), -1)     else:         raise ValueError(f'Species {P.species} is not supported')          data[:, simion_params.index('X')] =  P.z*1e3     data[:, simion_params.index('Y')] =  P.y*1e3     data[:, simion_params.index('Z')] = -P.x*1e3          px =  P.pz     py =  P.py     pz = -P.px          data[:, simion_params.index('KE')] = P.kinetic_energy       # [eV]      data[:, simion_params.index('AZ')] = np.arctan2(-pz, px) * (180/np.pi)   # [deg]     data[:, simion_params.index('EL')] = np.arctan2(py, np.sqrt(px**2 + pz**2) ) * (180/np.pi) # [deg]          data[:, simion_params.index('CWF')] = P.weight/e_                       # Charge Weighting Factor, derive from particle group weights     data[:, simion_params.index('COLOR')] = np.full(len(P), color)     #fname, X, fmt='%.18e', delimiter=' '          np.savetxt(filename, data, delimiter=',', header=header, comments='', fmt='  %.9e')      In\u00a0[669]: Copied! <pre>particle_group_to_SIMION(P, 'text_ion_file.ion')\n</pre> particle_group_to_SIMION(P, 'text_ion_file.ion') In\u00a0[623]: Copied! <pre>def read_simion_ION_file(filename):\n    \n    data = np.loadtxt(filename, comments=';', delimiter=',', skiprows=1)\n    \n    simion_params= ['TOB', 'MASS', 'CHARGE', 'X', 'Y', 'Z', 'AZ', 'EL', 'KE', 'CWF', 'COLOR']\n    \n    return {simion_params[ii]:data[:,ii] for ii, p in enumerate(simion_params)}\n</pre> def read_simion_ION_file(filename):          data = np.loadtxt(filename, comments=';', delimiter=',', skiprows=1)          simion_params= ['TOB', 'MASS', 'CHARGE', 'X', 'Y', 'Z', 'AZ', 'EL', 'KE', 'CWF', 'COLOR']          return {simion_params[ii]:data[:,ii] for ii, p in enumerate(simion_params)}                        In\u00a0[719]: Copied! <pre>ions1 = read_simion_ION_file('text_ion_file.ion')\nions2 = read_simion_ION_file('test_ion_writer.ion')\n</pre> ions1 = read_simion_ION_file('text_ion_file.ion') ions2 = read_simion_ION_file('test_ion_writer.ion') In\u00a0[617]: Copied! <pre>fig = plt.figure()\nax = fig.add_subplot(projection='3d')\n\npx, py, pz = P['px'], P['py'], P['pz']\n\np = np.sqrt(px**2 + py**2 + pz**2)\n\ntheta = np.arctan2(py, px)\nphi = np.arccos(pz/p)\nhist, pedges = np.histogram(phi, bins=100, density=True)\npcs = (pedges[1:] + pedges[:-1]) / 2\n\nx = px/p\ny = py/p\nz = pz/p\n\nax.scatter(x[::], y[::], z[::], '.');\nax.set_xlabel('$\\hat{p}_x$')\nax.set_ylabel('$\\hat{p}_y$')\nax.set_zlabel('$\\hat{p}_z$')\n</pre> fig = plt.figure() ax = fig.add_subplot(projection='3d')  px, py, pz = P['px'], P['py'], P['pz']  p = np.sqrt(px**2 + py**2 + pz**2)  theta = np.arctan2(py, px) phi = np.arccos(pz/p) hist, pedges = np.histogram(phi, bins=100, density=True) pcs = (pedges[1:] + pedges[:-1]) / 2  x = px/p y = py/p z = pz/p  ax.scatter(x[::], y[::], z[::], '.'); ax.set_xlabel('$\\hat{p}_x$') ax.set_ylabel('$\\hat{p}_y$') ax.set_zlabel('$\\hat{p}_z$') Out[617]: <pre>Text(0.5, 0, '$\\\\hat{p}_z$')</pre> In\u00a0[720]: Copied! <pre>for p in ions1: print(f'{p}:', max(np.abs(ions1[p] - ions2[p])))\n</pre> for p in ions1: print(f'{p}:', max(np.abs(ions1[p] - ions2[p]))) <pre>TOB: 0.0\nMASS: 0.0\nCHARGE: 0.0\nX: 0.0\nY: 0.0\nZ: 0.0\nAZ: 0.0\nEL: 0.0\nKE: 9.99999905104687e-09\nCWF: 0.0\nCOLOR: 0.0\n</pre> In\u00a0[723]: Copied! <pre>plt.plot(ions1['KE'], ions1['KE']/ions2['KE'], '.');\nplt.xlabel('KE (eV)');\n</pre> plt.plot(ions1['KE'], ions1['KE']/ions2['KE'], '.'); plt.xlabel('KE (eV)'); In\u00a0[\u00a0]: Copied! <pre>#calc. data columns calc.\n#eV scale x height y normaliz\n1.25 1 3.4 0.85\n2.5\t2\t3.45\t0.8625\n3.75\t3\t1.9\t0.475\n5\t4\t1.5\t0.375\n6.25\t5\t1.55\t0.3875\n7.5\t6\t10.5\t2.625\n8.75\t7\t9.5\t2.375\n11.25\t9\t8.5\t2.125\n12.5\t10\t6.5\t1.625\n18.75\t15\t6\t1.5\n25\t20\t4.5\t1.125\n31.25\t25\t4\t1\n37.5\t30\t3.5\t0.875\n62.5\t50\t3\t0.75\n75\t60\t2\t0.5\n100\t80\t1\t0.25\n</pre> #calc. data columns calc. #eV scale x height y normaliz 1.25 1 3.4 0.85 2.5\t2\t3.45\t0.8625 3.75\t3\t1.9\t0.475 5\t4\t1.5\t0.375 6.25\t5\t1.55\t0.3875 7.5\t6\t10.5\t2.625 8.75\t7\t9.5\t2.375 11.25\t9\t8.5\t2.125 12.5\t10\t6.5\t1.625 18.75\t15\t6\t1.5 25\t20\t4.5\t1.125 31.25\t25\t4\t1 37.5\t30\t3.5\t0.875 62.5\t50\t3\t0.75 75\t60\t2\t0.5 100\t80\t1\t0.25 In\u00a0[724]: Copied! <pre>KE = [1.25, 2.5, 3.75, 5, 6.25, 7.5, 8.75, 11.25, 12.5, 18.75, 25, 31.25, 37.5, 62.5, 75, 100]\nrho = [1, 3.45, 3, 1.5, 5, 10.5, 7, 9, 10, 15]\n</pre> KE = [1.25, 2.5, 3.75, 5, 6.25, 7.5, 8.75, 11.25, 12.5, 18.75, 25, 31.25, 37.5, 62.5, 75, 100] rho = [1, 3.45, 3, 1.5, 5, 10.5, 7, 9, 10, 15] In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/transforms/","title":"Transformation utilties","text":"In\u00a0[1]: Copied! <pre># Useful for debugging\n%load_ext autoreload\n%autoreload 2\n%config InlineBackend.figure_format = 'retina'\n</pre> # Useful for debugging %load_ext autoreload %autoreload 2 %config InlineBackend.figure_format = 'retina' In\u00a0[2]: Copied! <pre>units = {'x':'mm','y':'mm','r':'mm','z':'mm','px':'keV/c','py':'keV/c','pz':'MeV/c','t':'ps','q':'pC','thetax':'mrad','thetay':'mrad'}\nfrom distgen import Generator\nfrom distgen.plot import plot_dist2d, plot_radial_dist\nfrom distgen.physical_constants import unit_registry as unit\nfrom matplotlib import pyplot as plt\nimport yaml\nimport numpy as np\nfrom pprint import pprint\n</pre> units = {'x':'mm','y':'mm','r':'mm','z':'mm','px':'keV/c','py':'keV/c','pz':'MeV/c','t':'ps','q':'pC','thetax':'mrad','thetay':'mrad'} from distgen import Generator from distgen.plot import plot_dist2d, plot_radial_dist from distgen.physical_constants import unit_registry as unit from matplotlib import pyplot as plt import yaml import numpy as np from pprint import pprint <p>A set of transformations can be applied to a beam when it is created by adding a dictionary called 'transforms' at the top level of the Distgen input structure (in either dictionary or YAML format).</p> <p>Transformations are added to this dictionary with a unique identifier key.  The key <code>'order'</code> is protected and should not be used. Each transformation definition must be a dictionary containing a <code>'type'</code> key associated with a known transform function and the variable(s) it acts on.  A simple example is given by a translation in x: the type key is then \"type: translate x\".  All input parameters for the transformation should be input at the same level as the 'type' key. Physical quantities with units should be dictionaries with a 'value' and 'units' key/value pair supplied.</p> <p>Unless specified, transformations are applied in the order they are input in the transforms dictionary. Because transformation operations often do not commute, the user may specify a desired order by adding a list of transformation ID's to the tranform dictionary using the key <code>'order'</code>. Because python and yaml do not universally guarantee order is preserved, it is recommended to always specify the order list when the number of transforms is more than one.</p> <p>In the example below, two transforms are include: scaling a round beam so that it is oval, and then rotated the beam by 45 deg.  In this example the full input to Distgen is printed, in subsequent examples, only the transform details are printed.</p> In\u00a0[3]: Copied! <pre>gen = Generator('data/beer.can.in.yaml', verbose=0) \n\ninitial_beam = gen.beam()\n\nsetstdx = {'type':'set_std x', 'sigma_x':{'value': 3, 'units': 'mm'}}\nrot2dxy = {'type':'rotate2d x:y', 'angle':{'value':45, 'units':'deg'}}\ntransy = {'type': 'translate y', 'delta': {'value': 1, 'units': 'mm'}}\n\ngen['transforms']={'t1':setstdx, 't2':rot2dxy, 't3':transy, 'order':['t1', 't2', 't3']}\n\nfinal_beam = gen.beam()\n\nprint('Input:\\n', yaml.dump(gen.input['transforms']))\n\nfig, ax = plt.subplots(1, 2, sharex='col',constrained_layout=True)\n\nplot_dist2d(initial_beam, 'x', units['x'], 'y', units['y'], axis='equal', ax=ax[0]);\nax[0].set_title('Before transforms');\n\nplot_dist2d(final_beam, 'x', units['x'], 'y', units['y'], axis='equal', ax=ax[1]);\nax[1].set_title('After transforms');\n</pre> gen = Generator('data/beer.can.in.yaml', verbose=0)   initial_beam = gen.beam()  setstdx = {'type':'set_std x', 'sigma_x':{'value': 3, 'units': 'mm'}} rot2dxy = {'type':'rotate2d x:y', 'angle':{'value':45, 'units':'deg'}} transy = {'type': 'translate y', 'delta': {'value': 1, 'units': 'mm'}}  gen['transforms']={'t1':setstdx, 't2':rot2dxy, 't3':transy, 'order':['t1', 't2', 't3']}  final_beam = gen.beam()  print('Input:\\n', yaml.dump(gen.input['transforms']))  fig, ax = plt.subplots(1, 2, sharex='col',constrained_layout=True)  plot_dist2d(initial_beam, 'x', units['x'], 'y', units['y'], axis='equal', ax=ax[0]); ax[0].set_title('Before transforms');  plot_dist2d(final_beam, 'x', units['x'], 'y', units['y'], axis='equal', ax=ax[1]); ax[1].set_title('After transforms'); <pre>/usr/share/miniconda/envs/distgen-dev/lib/python3.9/site-packages/distgen/generator.py:237: UserWarning: Input variable n_particle was a float, expected int.\n  warnings.warn('Input variable n_particle was a float, expected int.')\n</pre> <pre>Input:\n order:\n- t1\n- t2\n- t3\nt1:\n  sigma_x:\n    units: millimeter\n    value: 3.0\n  type: set_std x\nt2:\n  angle:\n    units: degree\n    value: 45.0\n  type: rotate2d x:y\nt3:\n  delta:\n    units: millimeter\n    value: 1.0\n  type: translate y\n\n</pre> <p>Distgen provides a set of basic transformation utilities that can be applied the particle coordinates of a beam object.  Here the basic examples are discused: the transformation functions are defined as well as how to use them from the standard Distgen input structure.  Note the these transformation operations do not in general commute.</p> <p>The primary example used is that of a uniform radial distribution.</p> <p>Translations of the coordinate $u$ are defined by: $u\\rightarrow u + \\Delta u$.</p> In\u00a0[4]: Copied! <pre># Translations: a translation of a single coordinate are handled by transforms.translate\nfrom distgen.transforms import translate\n\ngen=Generator('data/beer.can.in.yaml',verbose=0)\nbeam1=gen.beam()\n\ntransx = {'type':'translate x', 'delta':{'value':+3, 'units':'mm'}}\ntransy = {'type':'translate y', 'delta': '-1 mm'}\n\ngen['transforms']={'tx':transx, 'ty':transy, 'order':['tx','ty']}\nbeam2 = gen.beam()\n\nprint('Input:\\n',yaml.dump(gen.input['transforms']))\n\nfig, ax = plt.subplots(1, 2, sharex='col',constrained_layout=True)\n\nplot_dist2d(beam1, 'x', units['x'], 'y', units['y'], axis='equal', ax=ax[0], title_on=True);\nax[0].set_title(f'Before\\n{ax[0].get_title()}')\n\nplot_dist2d(beam2, 'x', units['x'], 'y', units['y'], axis='equal', ax=ax[1], title_on=True);\nax[1].set_title(f'After\\n{ax[1].get_title()}');\n</pre> # Translations: a translation of a single coordinate are handled by transforms.translate from distgen.transforms import translate  gen=Generator('data/beer.can.in.yaml',verbose=0) beam1=gen.beam()  transx = {'type':'translate x', 'delta':{'value':+3, 'units':'mm'}} transy = {'type':'translate y', 'delta': '-1 mm'}  gen['transforms']={'tx':transx, 'ty':transy, 'order':['tx','ty']} beam2 = gen.beam()  print('Input:\\n',yaml.dump(gen.input['transforms']))  fig, ax = plt.subplots(1, 2, sharex='col',constrained_layout=True)  plot_dist2d(beam1, 'x', units['x'], 'y', units['y'], axis='equal', ax=ax[0], title_on=True); ax[0].set_title(f'Before\\n{ax[0].get_title()}')  plot_dist2d(beam2, 'x', units['x'], 'y', units['y'], axis='equal', ax=ax[1], title_on=True); ax[1].set_title(f'After\\n{ax[1].get_title()}'); <pre>Input:\n order:\n- tx\n- ty\ntx:\n  delta:\n    units: millimeter\n    value: 3.0\n  type: translate x\nty:\n  delta:\n    units: millimeter\n    value: -1\n  type: translate y\n\n</pre> In\u00a0[5]: Copied! <pre>gen=Generator('data/beer.can.in.yaml',verbose=0)\nbeam1=gen.beam()\n\nsetavgx = {'type':'set_avg x', 'avg_x':{'value':+3, 'units':'mm'}}\nsetavgy = {'type':'set_avg y', 'avg_y':{'value':-1, 'units':'mm'}}\n\ngen['transforms']={'tx':setavgx, 'ty':setavgy, 'order':['tx', 'ty']}\nbeam2 = gen.beam()\n\nprint('Input:\\n',yaml.dump(gen.input['transforms']))\n\nfig, ax = plt.subplots(1, 2, sharex='col',constrained_layout=True)\n\nplot_dist2d(beam1, 'x', units['x'], 'y', units['y'], axis='equal', ax=ax[0], title_on=True);\nax[0].set_title(f'Before\\n{ax[0].get_title()}')\n\nplot_dist2d(beam2, 'x', units['x'], 'y', units[\"y\"], axis='equal', ax=ax[1], title_on=True);\nax[1].set_title(f'After\\n{ax[1].get_title()}');\n</pre> gen=Generator('data/beer.can.in.yaml',verbose=0) beam1=gen.beam()  setavgx = {'type':'set_avg x', 'avg_x':{'value':+3, 'units':'mm'}} setavgy = {'type':'set_avg y', 'avg_y':{'value':-1, 'units':'mm'}}  gen['transforms']={'tx':setavgx, 'ty':setavgy, 'order':['tx', 'ty']} beam2 = gen.beam()  print('Input:\\n',yaml.dump(gen.input['transforms']))  fig, ax = plt.subplots(1, 2, sharex='col',constrained_layout=True)  plot_dist2d(beam1, 'x', units['x'], 'y', units['y'], axis='equal', ax=ax[0], title_on=True); ax[0].set_title(f'Before\\n{ax[0].get_title()}')  plot_dist2d(beam2, 'x', units['x'], 'y', units[\"y\"], axis='equal', ax=ax[1], title_on=True); ax[1].set_title(f'After\\n{ax[1].get_title()}'); <pre>Input:\n order:\n- tx\n- ty\ntx:\n  avg_x:\n    units: millimeter\n    value: 3.0\n  type: set_avg x\nty:\n  avg_y:\n    units: millimeter\n    value: -1.0\n  type: set_avg y\n\n</pre> <p>Basic scaling is handled using transforms.scale.  To scale the $x$ coordinate of the beam by $\\alpha$ use:</p> <p>scale(beam,'x',$\\alpha$)</p> <p>where $\\alpha$ is a dimensionless quantity or float.  Note that if the $&lt;x&gt;\\neq0$ then $&lt;x&gt;\\rightarrow\\alpha&lt;x&gt;$.  It is possible to fix the average value under scaling using:</p> <p>scale(beam, 'x', $\\alpha$, fix_average='True')</p> In\u00a0[6]: Copied! <pre>from distgen.transforms import scale\n\ngen=Generator('data/beer.can.in.yaml',verbose=0)\nbeam1 = gen.beam()\n\ntransx = {'type':'translate x', 'delta':{'value': 3,'units': 'mm'}}\nscalex = {'type':'scale x', 'scale':2,}\n\ngen['transforms']={'t1':transx, 't2':scalex, 'order':['t1','t2']}\nbeam1 = gen.beam()\n\nscalex['fix_average']=True\n\ngen['transforms']={'t':transx, 's':scalex, 'order':['t','s']}\nbeam2 = gen.beam()\n\nprint('Input:\\n',yaml.dump(gen.input['transforms']))\n\nfig, ax = plt.subplots(1, 2, constrained_layout=True)\n\nplot_dist2d(beam1, 'x', units['x'], 'y', units[\"y\"], axis='equal', ax=ax[0]);\nax[0].set_title('Default scaling (average scaled)');\n\nplot_dist2d(beam2, 'x', units['x'], 'y', units['y'], axis='equal', ax=ax[1]);\nax[1].set_title('Scaling with average fixed');\n</pre> from distgen.transforms import scale  gen=Generator('data/beer.can.in.yaml',verbose=0) beam1 = gen.beam()  transx = {'type':'translate x', 'delta':{'value': 3,'units': 'mm'}} scalex = {'type':'scale x', 'scale':2,}  gen['transforms']={'t1':transx, 't2':scalex, 'order':['t1','t2']} beam1 = gen.beam()  scalex['fix_average']=True  gen['transforms']={'t':transx, 's':scalex, 'order':['t','s']} beam2 = gen.beam()  print('Input:\\n',yaml.dump(gen.input['transforms']))  fig, ax = plt.subplots(1, 2, constrained_layout=True)  plot_dist2d(beam1, 'x', units['x'], 'y', units[\"y\"], axis='equal', ax=ax[0]); ax[0].set_title('Default scaling (average scaled)');  plot_dist2d(beam2, 'x', units['x'], 'y', units['y'], axis='equal', ax=ax[1]); ax[1].set_title('Scaling with average fixed'); <pre>Input:\n order:\n- t\n- s\ns:\n  fix_average: true\n  scale: 2\n  type: scale x\nt:\n  delta:\n    units: millimeter\n    value: 3.0\n  type: translate x\n\n</pre> In\u00a0[7]: Copied! <pre>from distgen.transforms import set_stdxy\n\ngen=Generator('data/beer.can.in.yaml',verbose=0)\nbeam1 = gen.beam()\n\nscalex = {'type':'set_stdxy x:y', 'sigma_xy':{'value':3.4, 'units': 'mm'},}\n\ngen['transforms']={'t1':scalex}\nbeam2 = gen.beam()\n\nplot_dist2d(beam2, 'x', units['x'], 'y', units[\"y\"], axis='equal', title_on=True);\n</pre> from distgen.transforms import set_stdxy  gen=Generator('data/beer.can.in.yaml',verbose=0) beam1 = gen.beam()  scalex = {'type':'set_stdxy x:y', 'sigma_xy':{'value':3.4, 'units': 'mm'},}  gen['transforms']={'t1':scalex} beam2 = gen.beam()  plot_dist2d(beam2, 'x', units['x'], 'y', units[\"y\"], axis='equal', title_on=True);  <p>It is possible to combine a translation with a scaling operation to shift and rescale a coordinate to have a new standard deviation while keeping the form of the underlying coordinate distribution unchanged. This is accomplished using transforms.set_avg_and_std(...)</p> In\u00a0[8]: Copied! <pre>from distgen.transforms import set_avg_and_std\n\ngen=Generator('data/beer.can.in.yaml',verbose=0)\n\nsetx = {\n    'type':'set_avg_and_std x',\n    'avg_x':  {'value': -3, 'units': 'mm'},\n    'sigma_x':{'value':  5, 'units': 'mm'}\n}\n\ngen['transforms']={'sx':setx}\nbeam = gen.beam()\n\nprint('Input:\\n',yaml.dump(gen.input['transforms']))\n\nplot_dist2d(beam, 'x', units['x'], 'y', units['y'], axis='equal', title_on=True);\n</pre> from distgen.transforms import set_avg_and_std  gen=Generator('data/beer.can.in.yaml',verbose=0)  setx = {     'type':'set_avg_and_std x',     'avg_x':  {'value': -3, 'units': 'mm'},     'sigma_x':{'value':  5, 'units': 'mm'} }  gen['transforms']={'sx':setx} beam = gen.beam()  print('Input:\\n',yaml.dump(gen.input['transforms']))  plot_dist2d(beam, 'x', units['x'], 'y', units['y'], axis='equal', title_on=True); <pre>Input:\n sx:\n  avg_x:\n    units: millimeter\n    value: -3.0\n  sigma_x:\n    units: millimeter\n    value: 5.0\n  type: set_avg_and_std x\n\n</pre> <p>Rotation between two coordinates is accomplished using transforms.rotate2d.  In addition to the beam object, the user must specify the variables to rotate.  This can be done in a string of the form 'var1:var2' or as a list of strs ['var1','var2'].  The variables supplied must have the same type of units.  The user must also specify an angle in radians or degrees to rotate by.</p> <p>Note, the default behavior is to rotate around the coordinate origins (not the coordinate averages) as seen in the plot on the left below. The rotation can be performed about a different origin by setting the keyword arguement 'origin'.  Often it is desirable to set the origin of rotation to be the coordinate centroids. This is done by setting origin='centroid' (as seen in the plot on the right below).</p> In\u00a0[9]: Copied! <pre>from distgen.transforms import rotate2d\n\ngen=Generator('data/beer.can.in.yaml',verbose=0)\n\nscalex = {'type':'scale x', 'scale':3}\nshiftx = {'type': 'translate x', 'delta': {'value': 5, 'units': 'mm'}}\nrotxy = {'type':'rotate2d x:y', 'angle':{'value':45, 'units':'deg'}}\n            \ngen['transforms']={'sx':scalex, 'shx':shiftx, 'rxy':rotxy, 'order':['sx','shx','rxy']}\nobeam = gen.beam()\n\n# do with rotation around centroid\ngen['transforms:rxy']={'type':'rotate2d x:y', 'angle':{'value':45, 'units':'deg'}, 'origin':'centroid'}\n\ncbeam = gen.beam()\nprint('YAML input:\\n', yaml.dump(gen.input['transforms']))\n\nfig, ax = plt.subplots(1, 2, sharex='col',constrained_layout=True)\nplot_dist2d(obeam, 'x', units['x'], 'y', units['y'], ax=ax[0], axis=\"equal\");\nax[0].set_title('Rotated around origin');\n\nplot_dist2d(cbeam, 'x', units['x'], 'y', units['y'], ax=ax[1], axis=\"equal\");\nax[1].set_title('Rotated around centroids');\n</pre> from distgen.transforms import rotate2d  gen=Generator('data/beer.can.in.yaml',verbose=0)  scalex = {'type':'scale x', 'scale':3} shiftx = {'type': 'translate x', 'delta': {'value': 5, 'units': 'mm'}} rotxy = {'type':'rotate2d x:y', 'angle':{'value':45, 'units':'deg'}}              gen['transforms']={'sx':scalex, 'shx':shiftx, 'rxy':rotxy, 'order':['sx','shx','rxy']} obeam = gen.beam()  # do with rotation around centroid gen['transforms:rxy']={'type':'rotate2d x:y', 'angle':{'value':45, 'units':'deg'}, 'origin':'centroid'}  cbeam = gen.beam() print('YAML input:\\n', yaml.dump(gen.input['transforms']))  fig, ax = plt.subplots(1, 2, sharex='col',constrained_layout=True) plot_dist2d(obeam, 'x', units['x'], 'y', units['y'], ax=ax[0], axis=\"equal\"); ax[0].set_title('Rotated around origin');  plot_dist2d(cbeam, 'x', units['x'], 'y', units['y'], ax=ax[1], axis=\"equal\"); ax[1].set_title('Rotated around centroids'); <pre>YAML input:\n order:\n- sx\n- shx\n- rxy\nrxy:\n  angle:\n    units: degree\n    value: 45.0\n  origin: centroid\n  type: rotate2d x:y\nshx:\n  delta:\n    units: millimeter\n    value: 5.0\n  type: translate x\nsx:\n  scale: 3\n  type: scale x\n\n</pre> <p>The shear operation allows one to apply a sheer in a 2D subspace according of the form:</p> <p>$v\\rightarrow v + \\alpha u$</p> <p>This can be useful in a variety of cases such as drifting particles.</p> In\u00a0[10]: Copied! <pre>from distgen.transforms import shear\n\ngen=Generator('data/x.y.uniform.in.yaml',verbose=0)\nbeam1=gen.beam()\n\ngen['transforms']= {'s':{'type':'shear x:y', 'shear_coefficient':{'value': 0.5, 'units': ''}} }\nbeam2=gen.beam()\nprint('YAML:\\n',yaml.dump(gen.input['transforms']))\n\nfig, ax = plt.subplots(1, 2, constrained_layout=True)\nplot_dist2d(beam1, 'x', units['x'], 'y', units['y'], axis=\"equal\",ax=ax[0]);\nax[0].set_title('Before')\n\nplot_dist2d(beam2, 'x', units['x'], 'y', units['y'], axis=\"equal\", ax=ax[1]);\nax[1].set_title('After');\n</pre> from distgen.transforms import shear  gen=Generator('data/x.y.uniform.in.yaml',verbose=0) beam1=gen.beam()  gen['transforms']= {'s':{'type':'shear x:y', 'shear_coefficient':{'value': 0.5, 'units': ''}} } beam2=gen.beam() print('YAML:\\n',yaml.dump(gen.input['transforms']))  fig, ax = plt.subplots(1, 2, constrained_layout=True) plot_dist2d(beam1, 'x', units['x'], 'y', units['y'], axis=\"equal\",ax=ax[0]); ax[0].set_title('Before')  plot_dist2d(beam2, 'x', units['x'], 'y', units['y'], axis=\"equal\", ax=ax[1]); ax[1].set_title('After'); <pre>YAML:\n s:\n  shear_coefficient:\n    units: dimensionless\n    value: 0.5\n  type: shear x:y\n\n</pre> <p>Magnetizing a cylindrical beam provides a more physically relevant application of the sheer function.  Here the magnetization $\\mathcal{L}$ is added to the particle momentum in the form $p_x\\rightarrow p_x + \\frac{\\mathcal{L}}{\\sigma_{x,y}^2}y$ and $p_y\\rightarrow p_y - \\frac{\\mathcal{L}}{\\sigma_{x,y}^2}x$.  This results in a transverse emittance of $\\sqrt{\\epsilon_{n,x,uncor}^2 + \\mathcal{L}^2}$.  Note that using the definitions of cylindrical variables it is possible to show this is equivalent to a sheer of $p_{\\theta}\\rightarrow p_{\\theta}-\\frac{\\mathcal{L}}{\\sigma_{x,y}^2}r$.</p> <p>For symplicity, a magnetization function has been defined to perform the above transform given the magnetization $\\mathcal{L}$.  Currently this assumes a cylindrically symmetric bunch.</p> In\u00a0[11]: Copied! <pre>from distgen.physical_constants import MC2\nfrom distgen.transforms import magnetize\n\ngen = Generator('data/beer.can.in.yaml',verbose=0)\n\nfig, ax = plt.subplots(1, 2, constrained_layout=True, figsize=(10,4))\n\nibeam = gen.beam()\nplot_dist2d(ibeam, 'r', units['r'], 'ptheta', units['px'], ax=ax[0], title_on=True);\nax[0].set_title(f'Before\\n{ax[0].get_title()}')\n\nLmag = -50*unit('micrometer')*MC2.magnitude*unit('eV/c')\nprint(f'{Lmag.units:~P}')\nmagnetize = {\n    'type':'magnetize r:ptheta',\n    'magnetization':{'value': Lmag.magnitude, 'units': str(Lmag.units)},\n}\n\ngen['transforms']={'m':magnetize}\n\nprint('YAML:\\n',yaml.dump(gen.input['transforms']))\n\nfbeam = gen.beam()\nplot_dist2d(fbeam, 'r', units['r'], 'ptheta', units['px'], ax=ax[1], title_on=True);\nax[1].set_title(f'After\\n{ax[1].get_title()}');\n\neni = 0.5*(ibeam.emitt('x','normalized') + ibeam.emitt('y', 'normalized'))\nenf = 0.5*(fbeam.emitt('x','normalized') + fbeam.emitt('y', 'normalized'))\n\nenf0 = np.sqrt(eni**2 + (Lmag/(1*unit('GB')))**2)\nerr = (enf/enf0-1)\n\nprint(f'Initial emittance: {eni.to(\"um\"):G~P}')\nprint(f'Final emittance: {enf.to(\"um\"):G~P}')\nprint(f'Error: {100*err.magnitude} %')\n</pre> from distgen.physical_constants import MC2 from distgen.transforms import magnetize  gen = Generator('data/beer.can.in.yaml',verbose=0)  fig, ax = plt.subplots(1, 2, constrained_layout=True, figsize=(10,4))  ibeam = gen.beam() plot_dist2d(ibeam, 'r', units['r'], 'ptheta', units['px'], ax=ax[0], title_on=True); ax[0].set_title(f'Before\\n{ax[0].get_title()}')  Lmag = -50*unit('micrometer')*MC2.magnitude*unit('eV/c') print(f'{Lmag.units:~P}') magnetize = {     'type':'magnetize r:ptheta',     'magnetization':{'value': Lmag.magnitude, 'units': str(Lmag.units)}, }  gen['transforms']={'m':magnetize}  print('YAML:\\n',yaml.dump(gen.input['transforms']))  fbeam = gen.beam() plot_dist2d(fbeam, 'r', units['r'], 'ptheta', units['px'], ax=ax[1], title_on=True); ax[1].set_title(f'After\\n{ax[1].get_title()}');  eni = 0.5*(ibeam.emitt('x','normalized') + ibeam.emitt('y', 'normalized')) enf = 0.5*(fbeam.emitt('x','normalized') + fbeam.emitt('y', 'normalized'))  enf0 = np.sqrt(eni**2 + (Lmag/(1*unit('GB')))**2) err = (enf/enf0-1)  print(f'Initial emittance: {eni.to(\"um\"):G~P}') print(f'Final emittance: {enf.to(\"um\"):G~P}') print(f'Error: {100*err.magnitude} %') <pre>eV\u00b7\u00b5m/c\nYAML:\n m:\n  magnetization:\n    units: electron_volt * micrometer / speed_of_light\n    value: -25549947.499999996\n  type: magnetize r:ptheta\n\nInitial emittance: 0.541796 \u00b5m\nFinal emittance: 50.0029 \u00b5m\nError: -5.4643748059746144e-05 %\n</pre> In\u00a0[12]: Copied! <pre>from distgen.physical_constants import pi,c\nfrom distgen.transforms import polynomial\nimport numpy as np\n\ngen=Generator('data/gaussian.in.yaml',verbose=0)\n\nV0 = 1000*unit('MeV/c')\nw = 2*pi*1.3*unit('GHz')\nk = w/c\nphi = -2.5*unit('deg')\nc3 = -0.5*V0*k**2\n\npolytrans = {\n    'type':'polynomial z:pz',\n    'coefficients':[\n        {'value': V0.magnitude, 'units': str(V0.units)},\n        {'value': 0.0, 'units': 'eV/c/meter'},\n        {'value': c3.magnitude, 'units': str(c3.units)},\n    ]\n}\n\ngen['transforms']={'pt':polytrans}\n\nbeam = gen.beam()\nprint('YAML input:\\n',yaml.dump(gen.input['transforms']))\n\nplot_dist2d(beam, 'z', units['z'], 'pz', units['pz']);\n</pre> from distgen.physical_constants import pi,c from distgen.transforms import polynomial import numpy as np  gen=Generator('data/gaussian.in.yaml',verbose=0)  V0 = 1000*unit('MeV/c') w = 2*pi*1.3*unit('GHz') k = w/c phi = -2.5*unit('deg') c3 = -0.5*V0*k**2  polytrans = {     'type':'polynomial z:pz',     'coefficients':[         {'value': V0.magnitude, 'units': str(V0.units)},         {'value': 0.0, 'units': 'eV/c/meter'},         {'value': c3.magnitude, 'units': str(c3.units)},     ] }  gen['transforms']={'pt':polytrans}  beam = gen.beam() print('YAML input:\\n',yaml.dump(gen.input['transforms']))  plot_dist2d(beam, 'z', units['z'], 'pz', units['pz']); <pre>YAML input:\n pt:\n  coefficients:\n  - units: megaelectron_volt / speed_of_light\n    value: 1000.0\n  - units: electron_volt / meter / speed_of_light\n    value: 0.0\n  - units: gigahertz ** 2 * megaelectron_volt * radian ** 2 * second ** 2 / meter\n      ** 2 / speed_of_light\n    value: -3.7117185708535e-13\n  type: polynomial z:pz\n\n</pre> In\u00a0[13]: Copied! <pre>from distgen.physical_constants import pi,c\nfrom distgen.transforms import cosine\nimport numpy as np\n\ngen=Generator('data/gaussian.in.yaml',verbose=0)\n\nw = 2*pi*1.3*unit('GHz')\nk = w/c\n\ntcos = {\n    'type':'cosine z:pz',\n    'amplitude':{'value':1000, 'units':'MeV/c'},\n    'phase':{'value':-2.5, 'units':'deg'},\n    'omega':{'value': k.magnitude, 'units': str(k.units)}\n}\n\ngen['transforms']={'tc':tcos}\n\nbeam = gen.beam()\nprint('YAML input:\\n',yaml.dump(gen.input['transforms']))\n\nplot_dist2d(beam, 'z', units['z'], 'pz', units['pz']);\n</pre> from distgen.physical_constants import pi,c from distgen.transforms import cosine import numpy as np  gen=Generator('data/gaussian.in.yaml',verbose=0)  w = 2*pi*1.3*unit('GHz') k = w/c  tcos = {     'type':'cosine z:pz',     'amplitude':{'value':1000, 'units':'MeV/c'},     'phase':{'value':-2.5, 'units':'deg'},     'omega':{'value': k.magnitude, 'units': str(k.units)} }  gen['transforms']={'tc':tcos}  beam = gen.beam() print('YAML input:\\n',yaml.dump(gen.input['transforms']))  plot_dist2d(beam, 'z', units['z'], 'pz', units['pz']); <pre>YAML input:\n tc:\n  amplitude:\n    units: megaelectron_volt / speed_of_light\n    value: 1000.0\n  omega:\n    units: gigahertz * radian * second / meter\n    value: 2.724598528537186e-08\n  phase:\n    units: degree\n    value: -2.5\n  type: cosine z:pz\n\n</pre> In\u00a0[14]: Copied! <pre>from distgen.transforms import set_twiss, translate\nfilename = \"data/gaussian.in.yaml\"\n\ngen = Generator(filename, verbose=0) \n\nboost_pz = {'type':'translate pz',  'delta': { 'value':1, 'units':'GeV/c',}}\n\ngen['transforms']={'boost':boost_pz}\nbeam1 = gen.beam()\n\ntwiss_x = {\n    'type':'set_twiss x', \n    'beta': {'value':12.5, 'units':'m',},\n    'alpha':{'value':-1, 'units':''},\n    'emittance': {'value':2, 'units':'nm'}\n}\n\ngen['transforms']={'boost':boost_pz, 'twiss':twiss_x, 'order':['boost','twiss']}\nbeam2 = gen.beam()\n\nprint('YAML input:\\n',yaml.dump(gen.input['transforms']))\n\nprint('Initial Horizontal Twiss params:')\nprint(f'beta: {beam1.Beta(\"x\"):G~P}, alpha: {beam1.Alpha(\"x\"):G~P}, eps: {beam1.emitt(\"x\",\"geometric\").to(\"nm\"):0.3f~P}')\n\nfig, ax = plt.subplots(1, 2, constrained_layout=True)\nplot_dist2d(beam1, 'x', units['x'], 'thetax', units['thetax'], ax=ax[0]);\nax[0].set_title('Before')\n\nplot_dist2d(beam2, 'x', units['x'], 'thetax', units[\"thetax\"], ax=ax[1]);\nax[1].set_title('After');\n\nprint('\\nFinal Horizontal Twiss params:')\nprint(f'beta: {beam2.Beta(\"x\").to(\"m\"):G~P}, alpha: {beam2.Alpha(\"x\"):G~P}, eps: {beam2.emitt(\"x\",\"geometric\").to(\"nm\"):0.3f~P}')\n</pre> from distgen.transforms import set_twiss, translate filename = \"data/gaussian.in.yaml\"  gen = Generator(filename, verbose=0)   boost_pz = {'type':'translate pz',  'delta': { 'value':1, 'units':'GeV/c',}}  gen['transforms']={'boost':boost_pz} beam1 = gen.beam()  twiss_x = {     'type':'set_twiss x',      'beta': {'value':12.5, 'units':'m',},     'alpha':{'value':-1, 'units':''},     'emittance': {'value':2, 'units':'nm'} }  gen['transforms']={'boost':boost_pz, 'twiss':twiss_x, 'order':['boost','twiss']} beam2 = gen.beam()  print('YAML input:\\n',yaml.dump(gen.input['transforms']))  print('Initial Horizontal Twiss params:') print(f'beta: {beam1.Beta(\"x\"):G~P}, alpha: {beam1.Alpha(\"x\"):G~P}, eps: {beam1.emitt(\"x\",\"geometric\").to(\"nm\"):0.3f~P}')  fig, ax = plt.subplots(1, 2, constrained_layout=True) plot_dist2d(beam1, 'x', units['x'], 'thetax', units['thetax'], ax=ax[0]); ax[0].set_title('Before')  plot_dist2d(beam2, 'x', units['x'], 'thetax', units[\"thetax\"], ax=ax[1]); ax[1].set_title('After');  print('\\nFinal Horizontal Twiss params:') print(f'beta: {beam2.Beta(\"x\").to(\"m\"):G~P}, alpha: {beam2.Alpha(\"x\"):G~P}, eps: {beam2.emitt(\"x\",\"geometric\").to(\"nm\"):0.3f~P}') <pre>YAML input:\n boost:\n  delta:\n    units: gigaelectron_volt / speed_of_light\n    value: 1.0\n  type: translate pz\norder:\n- boost\n- twiss\ntwiss:\n  alpha:\n    units: dimensionless\n    value: -1.0\n  beta:\n    units: meter\n    value: 12.5\n  emittance:\n    units: nanometer\n    value: 2.0\n  type: set_twiss x\n\nInitial Horizontal Twiss params:\nbeta: 999999 mm, alpha: 0.000112133, eps: 1.000 nm\n\nFinal Horizontal Twiss params:\nbeta: 12.5 m, alpha: -1, eps: 2.000 nm\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/transforms/#transformation-utilties","title":"Transformation utilties\u00b6","text":""},{"location":"examples/transforms/#translations","title":"Translations\u00b6","text":""},{"location":"examples/transforms/#scaling","title":"Scaling\u00b6","text":""},{"location":"examples/transforms/#shift-and-scale-a-single-coordinate","title":"Shift and Scale a single coordinate\u00b6","text":""},{"location":"examples/transforms/#rotating-coordinates","title":"Rotating coordinates\u00b6","text":""},{"location":"examples/transforms/#shear","title":"Shear\u00b6","text":""},{"location":"examples/transforms/#polynomial","title":"Polynomial\u00b6","text":"<p>It is possible to apply a polynomial map in one beam variable to a second using the polynomial function:</p> <p>$p \\rightarrow p + \\sum_{n=0}^N a_n (x-\\mathcal{O})^n$.</p> <p>Here $p_i$ is the dependent variable before the transformation (this term can be left out by specifying the keyword zero_dependent_var=True),  the $a_n$ specify the polynomial coefficients, and $\\mathcal{O}$ is the expansion origin.  In the example used below, a quartic polynomial in $z$ is applied to $p_z$ mimicing the effect of an RF cavity:</p>"},{"location":"examples/transforms/#cosine","title":"Cosine\u00b6","text":"<p>It is often convenient to impart a cosine like energy spread to beam's longitudinal momentum.  This can be accomplished using the cosine transform:</p> <p>$p \\rightarrow p + A\\cos(\\omega v + \\phi)$.</p>"},{"location":"examples/transforms/#setting-twiss-parameters","title":"Setting Twiss parameters\u00b6","text":"<p>Often for beams at energy the user may wish to set beam Twiss parameters $\\beta$, $\\alpha$, and $\\epsilon$ for a desired 2D phase space.</p>"},{"location":"examples/data/convert2yaml/","title":"Convert2yaml","text":"In\u00a0[\u00a0]: Copied! <pre>import yaml\nimport os\n</pre> import yaml import os In\u00a0[\u00a0]: Copied! <pre>def main():\n\n    for filename in os.listdir(os.getcwd()):\n        if(filename.endswith('json')):\n            with open(filename) as fid:\n                data = yaml.safe_load(fid)\n\n            newfile = '.'.join( (filename.split('.'))[:-1] )+'.yaml'\n            with open(newfile,'w') as yid:\n                yaml.dump(data, yid, default_flow_style=False)\n</pre> def main():      for filename in os.listdir(os.getcwd()):         if(filename.endswith('json')):             with open(filename) as fid:                 data = yaml.safe_load(fid)              newfile = '.'.join( (filename.split('.'))[:-1] )+'.yaml'             with open(newfile,'w') as yid:                 yaml.dump(data, yid, default_flow_style=False) In\u00a0[\u00a0]: Copied! <pre>if __name__==main():\n    #main()\n    filename='tukey.beer.can.in.json'\n    with open(filename) as fid:\n        data = yaml.safe_load(fid)\n\n    newfile='tukey.beer.can.in.yaml'\n    with open(newfile,'w') as yid:\n        yaml.dump(data, yid, default_flow_style=False)\n</pre> if __name__==main():     #main()     filename='tukey.beer.can.in.json'     with open(filename) as fid:         data = yaml.safe_load(fid)      newfile='tukey.beer.can.in.yaml'     with open(newfile,'w') as yid:         yaml.dump(data, yid, default_flow_style=False)"},{"location":"examples/data/convert_examples/","title":"Convert examples","text":"In\u00a0[\u00a0]: Copied! <pre>import json\nimport os\nimport copy\n</pre> import json import os import copy In\u00a0[\u00a0]: Copied! <pre>def main():\n\n    exs = {}\n\n    files = os.listdir('.')\n    for filename in files:\n\n        if(filename.endswith('json') and 'examples' not in filename):\n            print(filename)\n            with open(filename) as jid:\n                data = json.load(jid)\n\n            ndata = copy.deepcopy(data)\n\n            ndata['total_charge']=data['beam']['params']['total_charge']\n            ndata['n_particles']=data['generator']['rand']['count'] \n            ndata['random_type']=data['generator']['rand']['type'] \n            ndata['count']=data['generator']['rand']['count']\n\n            del[ndata['generator']]\n            del[ndata['beam']]\n\n            exs[filename[:-8]]=ndata\n\n    \n\n    with open('examples.json','w') as jfile:\n        json.dump(exs,jfile,indent=4,sort_keys=True)\n</pre> def main():      exs = {}      files = os.listdir('.')     for filename in files:          if(filename.endswith('json') and 'examples' not in filename):             print(filename)             with open(filename) as jid:                 data = json.load(jid)              ndata = copy.deepcopy(data)              ndata['total_charge']=data['beam']['params']['total_charge']             ndata['n_particles']=data['generator']['rand']['count']              ndata['random_type']=data['generator']['rand']['type']              ndata['count']=data['generator']['rand']['count']              del[ndata['generator']]             del[ndata['beam']]              exs[filename[:-8]]=ndata            with open('examples.json','w') as jfile:         json.dump(exs,jfile,indent=4,sort_keys=True) In\u00a0[\u00a0]: Copied! <pre>if __name__== \"__main__\":\n    main()\n</pre> if __name__== \"__main__\":     main()"},{"location":"examples/data/fix_random_keys/","title":"Fix random keys","text":"In\u00a0[1]: Copied! <pre># Useful for debugging\n%load_ext autoreload\n%autoreload 2\n%config InlineBackend.figure_format = 'retina'\nimport yaml\nfrom glob import glob\nfrom pathlib import Path\n</pre> # Useful for debugging %load_ext autoreload %autoreload 2 %config InlineBackend.figure_format = 'retina' import yaml from glob import glob from pathlib import Path In\u00a0[2]: Copied! <pre>yamls = glob('*yaml')\n</pre> yamls = glob('*yaml') In\u00a0[3]: Copied! <pre>for y in yamls:\n    \n    with open(y, 'r') as fid:\n        inputs = yaml.safe_load(fid)\n        \n        if('random_type' in inputs):\n            del inputs['random_type']\n            \n        inputs['random']={'type':'hammersley'}\n    \n    with open(y, 'w') as fid:\n        yaml.dump(inputs, fid)\n</pre> for y in yamls:          with open(y, 'r') as fid:         inputs = yaml.safe_load(fid)                  if('random_type' in inputs):             del inputs['random_type']                      inputs['random']={'type':'hammersley'}          with open(y, 'w') as fid:         yaml.dump(inputs, fid)  In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"regression_tests/beam/","title":"Beam Class Regression Tests","text":"In\u00a0[1]: Copied! <pre>%load_ext autoreload\n%autoreload 2\n</pre> %load_ext autoreload %autoreload 2 In\u00a0[2]: Copied! <pre>import numpy as np\nfrom distgen import Generator\nfrom distgen.physical_constants import MC2\n</pre> import numpy as np from distgen import Generator from distgen.physical_constants import MC2 In\u00a0[3]: Copied! <pre>input_file = \"../examples/data/rad.gaussian.in.yaml\"\ngen = Generator(input_file,verbose=0)\nbeam = gen.beam()\n\ncoordinates = {'x', 'y', 'z', 'px', 'py', 'pz', \n               'r', 'theta', 'pr', 'ptheta', \n               'xp', 'yp', 'thetax', 'thetay',\n               'gamma', 'energy', 'kinetic_energy', \n               'beta_x', 'beta_y', 'beta_z'}\n</pre> input_file = \"../examples/data/rad.gaussian.in.yaml\" gen = Generator(input_file,verbose=0) beam = gen.beam()  coordinates = {'x', 'y', 'z', 'px', 'py', 'pz',                 'r', 'theta', 'pr', 'ptheta',                 'xp', 'yp', 'thetax', 'thetay',                'gamma', 'energy', 'kinetic_energy',                 'beta_x', 'beta_y', 'beta_z'} In\u00a0[4]: Copied! <pre>assert np.abs(np.sum(beam['w'])-1)&lt;1e14, 'Beam weights not normalized'\n</pre> assert np.abs(np.sum(beam['w'])-1)&lt;1e14, 'Beam weights not normalized' <p>$\\langle \\mathcal{O}\\rangle = \\sum_i w_i \\mathcal{O}_i$</p> In\u00a0[5]: Copied! <pre>for var in coordinates:\n    assert np.abs(beam.avg(var) - np.sum(beam['w']*beam[var])).magnitude&lt;1e-14, f'&lt;{var}&gt; is not correct'\n</pre> for var in coordinates:     assert np.abs(beam.avg(var) - np.sum(beam['w']*beam[var])).magnitude&lt;1e-14, f'&lt;{var}&gt; is not correct' <p>$\\sigma_{\\mathcal{O}}^2 = \\sum_i w_i (\\mathcal{O}_i-\\langle \\mathcal{O}\\rangle)^2 $</p> In\u00a0[6]: Copied! <pre>for var in coordinates:\n    assert np.abs(beam.std(var)**2 - np.sum(beam['w']*(beam[var]-beam.avg(var))**2)).magnitude&lt;5e-10, f'&lt;{var}&gt; is not correct'\n</pre> for var in coordinates:     assert np.abs(beam.std(var)**2 - np.sum(beam['w']*(beam[var]-beam.avg(var))**2)).magnitude&lt;5e-10, f'&lt;{var}&gt; is not correct' <p>$r=\\sqrt{ x^2 + y^2 }$</p> In\u00a0[7]: Copied! <pre>deviation =  np.abs(beam['r'] - np.sqrt(beam['x']**2 + beam['y']**2))\nassert max(deviation.magnitude)&lt;1e-14, 'Radial coordinate incorrect'\n</pre> deviation =  np.abs(beam['r'] - np.sqrt(beam['x']**2 + beam['y']**2)) assert max(deviation.magnitude)&lt;1e-14, 'Radial coordinate incorrect' <p>$x=r\\cos\\theta$</p> In\u00a0[8]: Copied! <pre>deviation = np.abs(beam['x'] - beam['r']*np.cos(beam['theta']))\nassert max(deviation.magnitude)&lt;1e-14, 'x coordinate incorrect'\n</pre> deviation = np.abs(beam['x'] - beam['r']*np.cos(beam['theta'])) assert max(deviation.magnitude)&lt;1e-14, 'x coordinate incorrect' <p>$y = r\\sin\\theta$</p> In\u00a0[9]: Copied! <pre>deviation = np.abs(beam['x'] - beam['r']*np.cos(beam['theta']))\nassert max(deviation.magnitude)&lt;5e-13, 'y coordinate incorrect'\n</pre> deviation = np.abs(beam['x'] - beam['r']*np.cos(beam['theta'])) assert max(deviation.magnitude)&lt;5e-13, 'y coordinate incorrect' <p>$p_r = p_x\\cos\\theta - p_y\\sin\\theta$</p> In\u00a0[10]: Copied! <pre>deviation = np.abs(beam['pr'] - beam['px']*np.cos(beam['theta']) - beam['py']*np.sin(beam['theta']))\nassert max(deviation.magnitude)&lt;5e-13, 'pr coordinate incorrect'\n</pre> deviation = np.abs(beam['pr'] - beam['px']*np.cos(beam['theta']) - beam['py']*np.sin(beam['theta'])) assert max(deviation.magnitude)&lt;5e-13, 'pr coordinate incorrect' <p>$p_{\\theta} = -p_x\\cos\\theta + p_y\\sin\\theta$</p> In\u00a0[11]: Copied! <pre>deviation = np.abs(beam['ptheta'] + beam['px']*np.sin(beam['theta']) - beam['py']*np.cos(beam['theta']))\nassert max(deviation.magnitude)&lt;5e-13, 'ptheta coordinate incorrect'\n</pre> deviation = np.abs(beam['ptheta'] + beam['px']*np.sin(beam['theta']) - beam['py']*np.cos(beam['theta'])) assert max(deviation.magnitude)&lt;5e-13, 'ptheta coordinate incorrect' <p>$x^{\\prime} = p_x/p_z$</p> In\u00a0[12]: Copied! <pre>deviation = np.abs(beam['xp'] - beam['px'].to(beam['pz'].units)/beam['pz'])\nassert max(deviation.magnitude)&lt;1e-14, 'xp coordinate incorrect'\n</pre> deviation = np.abs(beam['xp'] - beam['px'].to(beam['pz'].units)/beam['pz']) assert max(deviation.magnitude)&lt;1e-14, 'xp coordinate incorrect' <p>$y^{\\prime} = p_y/p_z$</p> In\u00a0[13]: Copied! <pre>deviation = np.abs(beam['yp'] - beam['py'].to(beam['py'].units)/beam['pz'])\nassert max(deviation.magnitude)&lt;1e-14, 'yp coordinate incorrect'\n</pre> deviation = np.abs(beam['yp'] - beam['py'].to(beam['py'].units)/beam['pz']) assert max(deviation.magnitude)&lt;1e-14, 'yp coordinate incorrect' <p>$\\theta_x = \\arctan(p_x/p_z)$</p> In\u00a0[14]: Copied! <pre>deviation = np.abs(beam['thetax'] - np.arctan(beam['px'].to(beam['px'].units)/beam['pz']))\nassert max(deviation.magnitude)&lt;1e-14, f'thetax coordinate deviation = {max(deviation)}'\n</pre> deviation = np.abs(beam['thetax'] - np.arctan(beam['px'].to(beam['px'].units)/beam['pz'])) assert max(deviation.magnitude)&lt;1e-14, f'thetax coordinate deviation = {max(deviation)}' <p>$\\theta_y = \\arctan(p_y/p_z)$</p> In\u00a0[15]: Copied! <pre>deviation = np.abs(beam['thetay'] - np.arctan(beam['py'].to(beam['py'].units)/beam['pz']))\nassert max(deviation.magnitude)&lt;1e-14, 'thetay coordinate incorrect'\n</pre> deviation = np.abs(beam['thetay'] - np.arctan(beam['py'].to(beam['py'].units)/beam['pz'])) assert max(deviation.magnitude)&lt;1e-14, 'thetay coordinate incorrect' In\u00a0[16]: Copied! <pre>deviation = np.abs(beam['p'] - np.sqrt(beam['px']**2 +beam['py']**2 + beam['pz']**2))\nassert max(deviation.magnitude)&lt;1e-14, 'thetay coordinate incorrect'\n</pre> deviation = np.abs(beam['p'] - np.sqrt(beam['px']**2 +beam['py']**2 + beam['pz']**2)) assert max(deviation.magnitude)&lt;1e-14, 'thetay coordinate incorrect' <p>$\\gamma = \\sqrt{1+\\left(\\frac{p}{mc}\\right)^2}$</p> In\u00a0[17]: Copied! <pre>deviation = np.abs( beam['gamma'] - np.sqrt(1+ (beam['p'].to('eV/c').magnitude/MC2.magnitude)**2) )\nassert max(deviation.magnitude)&lt;1e-13, 'gamma coordinate incorrect'\n</pre> deviation = np.abs( beam['gamma'] - np.sqrt(1+ (beam['p'].to('eV/c').magnitude/MC2.magnitude)**2) ) assert max(deviation.magnitude)&lt;1e-13, 'gamma coordinate incorrect' <p>$\\beta_{x_i} = p_{x_i}/\\gamma$</p> In\u00a0[18]: Copied! <pre>for var in ['x', 'y', 'z']:\n    deviation = np.abs( beam[f'beta_{var}'] - beam[f'p{var}'].to('GB')/beam['gamma'])  \n    assert max(deviation.magnitude)&lt;1e-14, f'beta_{var} coordinate incorrect'\n</pre> for var in ['x', 'y', 'z']:     deviation = np.abs( beam[f'beta_{var}'] - beam[f'p{var}'].to('GB')/beam['gamma'])       assert max(deviation.magnitude)&lt;1e-14, f'beta_{var} coordinate incorrect' <p>KE = $mc^2(\\gamma-1)$</p> In\u00a0[19]: Copied! <pre>deviation = np.abs( beam['kinetic_energy'] - MC2*(beam['gamma']-1) ) \nassert max(deviation.magnitude)&lt;1e-14, 'KE coordinate incorrect'\n</pre> deviation = np.abs( beam['kinetic_energy'] - MC2*(beam['gamma']-1) )  assert max(deviation.magnitude)&lt;1e-14, 'KE coordinate incorrect' <p>E = $mc^2\\gamma$</p> In\u00a0[20]: Copied! <pre>deviation = np.abs( beam['energy'] - MC2*(beam['gamma']) ) \nassert max(deviation.magnitude)&lt;1e-14, 'E coordinate incorrect'\n</pre> deviation = np.abs( beam['energy'] - MC2*(beam['gamma']) )  assert max(deviation.magnitude)&lt;1e-14, 'E coordinate incorrect' In\u00a0[21]: Copied! <pre>for var in ['x', 'y']:\n    stdx = beam.std(var)\n    stdp = (beam.std(f'p{var}').to('GB')).magnitude\n    dx = beam[var]-beam.avg(var)\n    dp = (beam[f'p{var}']-beam.avg(f'p{var}')).to('GB').magnitude\n    \n    deviation = np.abs(beam.emitt(var) - np.sqrt(stdx**2 * stdp**2 - (np.sum(beam['w']*dx*dp))**2 ))\n    assert deviation.magnitude &lt; 1e-14\n</pre> for var in ['x', 'y']:     stdx = beam.std(var)     stdp = (beam.std(f'p{var}').to('GB')).magnitude     dx = beam[var]-beam.avg(var)     dp = (beam[f'p{var}']-beam.avg(f'p{var}')).to('GB').magnitude          deviation = np.abs(beam.emitt(var) - np.sqrt(stdx**2 * stdp**2 - (np.sum(beam['w']*dx*dp))**2 ))     assert deviation.magnitude &lt; 1e-14 <p>$\\epsilon_{x} = \\sqrt{\\sigma_x^2\\sigma_{x^{\\prime}}^2 - \\langle \\left(x-\\langle x\\rangle\\right)\\left(x^{\\prime}-\\langle x^{\\prime}\\rangle\\right)\\rangle^2 }$</p> In\u00a0[22]: Copied! <pre>for var in ['x', 'y']:\n    stdx = beam.std(var)\n    stdp = (beam.std(f'{var}p')).magnitude\n    dx = beam[var]-beam.avg(var)\n    dp = (beam[f'{var}p']-beam.avg(f'{var}p')).magnitude\n    \n    deviation = np.abs(beam.emitt(var,'geometric') - np.sqrt(stdx**2 * stdp**2 - (np.sum(beam['w']*dx*dp))**2 ))\n    assert deviation.magnitude &lt; 1e-14\n</pre> for var in ['x', 'y']:     stdx = beam.std(var)     stdp = (beam.std(f'{var}p')).magnitude     dx = beam[var]-beam.avg(var)     dp = (beam[f'{var}p']-beam.avg(f'{var}p')).magnitude          deviation = np.abs(beam.emitt(var,'geometric') - np.sqrt(stdx**2 * stdp**2 - (np.sum(beam['w']*dx*dp))**2 ))     assert deviation.magnitude &lt; 1e-14 <p>Twiss $\\beta_{x_i} = \\frac{\\sigma_x^2}{\\epsilon_x}$</p> In\u00a0[23]: Copied! <pre>for var in ['x', 'y']:\n    stdx = beam.std(var)\n    epsx = beam.emitt(var,'geometric')\n\n    deviation = np.abs( beam.Beta(var) - stdx**2/epsx )\n    assert deviation.magnitude &lt; 1e-14\n</pre> for var in ['x', 'y']:     stdx = beam.std(var)     epsx = beam.emitt(var,'geometric')      deviation = np.abs( beam.Beta(var) - stdx**2/epsx )     assert deviation.magnitude &lt; 1e-14 <p>Twiss $\\alpha_{x_i} = -\\frac{\\langle(x-\\langle x\\rangle)(x^{\\prime}-\\langle x^{\\prime}\\rangle)\\rangle}{\\epsilon_x}$</p> In\u00a0[24]: Copied! <pre>for var in ['x', 'y']:\n    dx = beam[var]-beam.avg(var)\n    dp = (beam[f'{var}p']-beam.avg(f'{var}p'))\n    epsx = beam.emitt(var,'geometric')\n    deviation = np.abs( beam.Alpha(var) + sum(beam['w']*dx*dp)/epsx )\n    assert deviation.magnitude &lt; 1e-15\n</pre> for var in ['x', 'y']:     dx = beam[var]-beam.avg(var)     dp = (beam[f'{var}p']-beam.avg(f'{var}p'))     epsx = beam.emitt(var,'geometric')     deviation = np.abs( beam.Alpha(var) + sum(beam['w']*dx*dp)/epsx )     assert deviation.magnitude &lt; 1e-15 <p>Twiss $\\gamma_{x_i} = \\frac{\\sigma_{x^{\\prime}}^2}{\\epsilon_x}$</p> In\u00a0[25]: Copied! <pre>for var in ['x', 'y']:\n    stdp = beam.std(f'{var}p')\n    epsx = beam.emitt(var,'geometric')\n    deviation = np.abs( beam.Gamma(var) - stdp**2/epsx )\n    assert deviation.magnitude &lt; 5e-15\n</pre> for var in ['x', 'y']:     stdp = beam.std(f'{var}p')     epsx = beam.emitt(var,'geometric')     deviation = np.abs( beam.Gamma(var) - stdp**2/epsx )     assert deviation.magnitude &lt; 5e-15"},{"location":"regression_tests/beam/#beam-class-regression-tests","title":"Beam Class Regression Tests\u00b6","text":""},{"location":"regression_tests/beam/#statistical-tests","title":"Statistical Tests\u00b6","text":"<p>$\\sum_i w_i = 1$</p>"},{"location":"regression_tests/beam/#cylindrical-coordinates","title":"Cylindrical Coordinates\u00b6","text":""},{"location":"regression_tests/beam/#getting","title":"Getting\u00b6","text":""},{"location":"regression_tests/beam/#transverse-derivatives-and-angles","title":"Transverse Derivatives and Angles\u00b6","text":""},{"location":"regression_tests/beam/#getting","title":"Getting\u00b6","text":""},{"location":"regression_tests/beam/#relativistic-quantities","title":"Relativistic Quantities\u00b6","text":"<p>$p=\\sqrt{p_x^2 + p_y^2 + p_z^2}$</p>"},{"location":"regression_tests/beam/#twiss-parameters","title":"Twiss Parameters\u00b6","text":""},{"location":"regression_tests/beam/#getting","title":"Getting\u00b6","text":"<p>$\\epsilon_{n,x_i} = \\frac{1}{mc}\\sqrt{\\sigma_{x_i}^2\\sigma_{p_{x_i}}^2 - \\langle \\left(x_i-\\langle x_i\\rangle\\right)\\left(p_{x_i}-\\langle p_{x_i}\\rangle\\right)\\rangle^2 }$</p>"},{"location":"regression_tests/correlations/","title":"Correlation Regression Tests","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nfrom matplotlib import pyplot as plt\nimport matplotlib \n\n%matplotlib inline\n%config InlineBackend.figure_format = 'retina'\n</pre> import numpy as np from matplotlib import pyplot as plt import matplotlib   %matplotlib inline %config InlineBackend.figure_format = 'retina' In\u00a0[2]: Copied! <pre>from distgen.dist import random_generator\n\nrands = random_generator((4,1000), sequence='hammersley')\ncov = np.cov(rands)\n\nprint('Covariance of Hammersley samples:')\nprint(cov)\nplt.plot(rands[0,:], rands[1,:],'.');\n</pre> from distgen.dist import random_generator  rands = random_generator((4,1000), sequence='hammersley') cov = np.cov(rands)  print('Covariance of Hammersley samples:') print(cov) plt.plot(rands[0,:], rands[1,:],'.');   <pre>Covariance of Hammersley samples:\n[[ 8.33224805e-02 -3.68343309e-04 -6.68187387e-05  4.25010191e-04]\n [-3.68343309e-04  8.33878181e-02  7.56326104e-05  2.25221076e-04]\n [-6.68187387e-05  7.56326104e-05  8.34060346e-02  4.12948253e-04]\n [ 4.25010191e-04  2.25221076e-04  4.12948253e-04  8.32500833e-02]]\n</pre> In\u00a0[3]: Copied! <pre>rands = random_generator((4,1000), sequence='pseudo')\ncov = np.cov(rands)\nprint('Covariance of Rand samples:')\nprint(cov)\nplt.plot(rands[0,:], rands[1,:], '.')\n</pre>  rands = random_generator((4,1000), sequence='pseudo') cov = np.cov(rands) print('Covariance of Rand samples:') print(cov) plt.plot(rands[0,:], rands[1,:], '.') <pre>Covariance of Rand samples:\n[[ 8.19342793e-02 -5.61406857e-04  4.47405875e-05  3.11822659e-05]\n [-5.61406857e-04  8.79730138e-02  1.28826034e-03  3.86397392e-03]\n [ 4.47405875e-05  1.28826034e-03  8.54523707e-02  5.57363419e-04]\n [ 3.11822659e-05  3.86397392e-03  5.57363419e-04  8.39805754e-02]]\n</pre> Out[3]: <pre>[&lt;matplotlib.lines.Line2D at 0x7f041c341cd0&gt;]</pre> In\u00a0[4]: Copied! <pre>import math\nrands = random_generator((2,10000), sequence='hammersley')\nnp.sum( np.cos(2*math.pi)*rands[1,:] * np.sin(2*math.pi)*rands[1,:])\n</pre> import math rands = random_generator((2,10000), sequence='hammersley') np.sum( np.cos(2*math.pi)*rands[1,:] * np.sin(2*math.pi)*rands[1,:]) Out[4]: <pre>-8.163903819533452e-13</pre> In\u00a0[5]: Copied! <pre>rands = random_generator((2,10000), sequence='pseudo')\nnp.sum( np.cos(2*math.pi)*rands[1,:] * np.sin(2*math.pi)*rands[1,:])\n</pre> rands = random_generator((2,10000), sequence='pseudo') np.sum( np.cos(2*math.pi)*rands[1,:] * np.sin(2*math.pi)*rands[1,:]) Out[5]: <pre>-8.096769580344563e-13</pre> In\u00a0[6]: Copied! <pre>R = 1\nN=100000\n\nrands1 = random_generator((2,N), sequence='hammersley')\nrands2 = random_generator((2,N), sequence='pseudo')\nrands3 = np.linspace(0, 1, N)\n\nrs = R*np.sqrt(rands1[0,:]) \n\nxs1 = rs*np.cos(2*math.pi*rands1[1,:])\nys1 = rs*np.sin(2*math.pi*rands1[1,:])\n\nxs2 = rs*np.cos(2*math.pi*rands2[1,:])\nys2 = rs*np.sin(2*math.pi*rands2[1,:])\n\nxs3 = rs*np.cos(2*math.pi*rands3)\nys3 = rs*np.sin(2*math.pi*rands3)\n\nplt.plot(xs1,ys1,'.');\n</pre> R = 1 N=100000  rands1 = random_generator((2,N), sequence='hammersley') rands2 = random_generator((2,N), sequence='pseudo') rands3 = np.linspace(0, 1, N)  rs = R*np.sqrt(rands1[0,:])   xs1 = rs*np.cos(2*math.pi*rands1[1,:]) ys1 = rs*np.sin(2*math.pi*rands1[1,:])  xs2 = rs*np.cos(2*math.pi*rands2[1,:]) ys2 = rs*np.sin(2*math.pi*rands2[1,:])  xs3 = rs*np.cos(2*math.pi*rands3) ys3 = rs*np.sin(2*math.pi*rands3)  plt.plot(xs1,ys1,'.'); In\u00a0[7]: Copied! <pre>print( np.mean( (xs1-xs1.mean())*(ys1-ys1.mean())) )\nprint( np.mean( (xs2-xs2.mean())*(ys2-ys2.mean())) )\nprint( np.mean( (xs3-xs3.mean())*(ys3-ys3.mean())) )\n</pre> print( np.mean( (xs1-xs1.mean())*(ys1-ys1.mean())) ) print( np.mean( (xs2-xs2.mean())*(ys2-ys2.mean())) ) print( np.mean( (xs3-xs3.mean())*(ys3-ys3.mean())) ) <pre>-9.407807239092847e-07\n-3.844472251044676e-05\n-9.40046825031402e-07\n</pre> In\u00a0[8]: Copied! <pre>sigma=np.cov(rands1)\nv,V = np.linalg.eig(sigma)\n\n#np.matmul(np.matmul(V.T, sigma), V) \n\nrandsp = np.matmul(V.T, rands1)\n\nnp.cov(randsp)\nrs = R*np.sqrt(randsp[0,:]) \n\nxsp = rs*np.cos(2*math.pi*randsp[1,:])\nysp = rs*np.sin(2*math.pi*randsp[1,:])\nprint(np.mean( (xsp-xsp.mean())*(ysp-ysp.mean())))\n</pre> sigma=np.cov(rands1) v,V = np.linalg.eig(sigma)  #np.matmul(np.matmul(V.T, sigma), V)   randsp = np.matmul(V.T, rands1)  np.cov(randsp) rs = R*np.sqrt(randsp[0,:])   xsp = rs*np.cos(2*math.pi*randsp[1,:]) ysp = rs*np.sin(2*math.pi*randsp[1,:]) print(np.mean( (xsp-xsp.mean())*(ysp-ysp.mean()))) <pre>0.008920000391515817\n</pre> In\u00a0[9]: Copied! <pre>input_str=\"\"\"\nn_particle: 100000\nrandom_type: hammersley\ntotal_charge:\n  value: 1\n  units: pC\nstart:\n  type: time\nr_dist:\n  max_r:\n    units: m\n    value: 2\n  min_r:\n    units: m\n    value: 0\n  type: radial_uniform\n\"\"\"\n\nimport yaml\n\nyaml.safe_load(input_str)\n</pre> input_str=\"\"\" n_particle: 100000 random_type: hammersley total_charge:   value: 1   units: pC start:   type: time r_dist:   max_r:     units: m     value: 2   min_r:     units: m     value: 0   type: radial_uniform \"\"\"  import yaml  yaml.safe_load(input_str) Out[9]: <pre>{'n_particle': 100000,\n 'random_type': 'hammersley',\n 'total_charge': {'value': 1, 'units': 'pC'},\n 'start': {'type': 'time'},\n 'r_dist': {'max_r': {'units': 'm', 'value': 2},\n  'min_r': {'units': 'm', 'value': 0},\n  'type': 'radial_uniform'}}</pre> In\u00a0[10]: Copied! <pre>from distgen import Generator\ngen = Generator(input_str)\ngen.run()\nxs = gen.particles['x']\nys = gen.particles['y']\n\ngen.particles.cov('x','y')\n</pre> from distgen import Generator gen = Generator(input_str) gen.run() xs = gen.particles['x'] ys = gen.particles['y']  gen.particles.cov('x','y') Out[10]: <pre>array([[ 1.00001000e+00, -3.76331398e-06],\n       [-3.76331398e-06,  1.00001000e+00]])</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"regression_tests/correlations/#correlation-regression-tests","title":"Correlation Regression Tests\u00b6","text":""},{"location":"regression_tests/correlations/#test-correlations-in-the-hammersley-generator","title":"Test Correlations in the Hammersley Generator\u00b6","text":"<p>The Hammerlsey sequence should produce random numbers on (0,1) that are less correlated than the basic random generator:</p>"},{"location":"regression_tests/correlations/#radial-distributions","title":"Radial Distributions\u00b6","text":""},{"location":"regression_tests/correlations/#test-correlation-in-sinthetacostheta","title":"Test correlation in sin(theta)cos(theta)\u00b6","text":""},{"location":"regression_tests/correlations/#generate-xy-for-uniform-dist-and-check-correlation","title":"Generate x,y for uniform dist and check correlation\u00b6","text":""},{"location":"regression_tests/dist/","title":"Dist Regression Tests","text":"In\u00a0[1]: Copied! <pre>%load_ext autoreload\n%autoreload 2\n%config InlineBackend.figure_format = 'retina'\n</pre> %load_ext autoreload %autoreload 2 %config InlineBackend.figure_format = 'retina' In\u00a0[2]: Copied! <pre>from distgen.physical_constants import unit_registry\nimport numpy as np\nfrom matplotlib import pyplot as plt\n</pre> from distgen.physical_constants import unit_registry import numpy as np from matplotlib import pyplot as plt <p>To sample various distributions requires generating random numbers and supplying them to the $CDF^{-1}$ functions for each corresponding distribution.  Currently, this is handled using</p> <p><code>distgen.dist.random_generator(shape, sequence, **params)</code>.</p> <p>Here <code>shape = (n_dimension, n_particle)</code> determines the shape of the random numbers returned.  The keyword 'sequence' can be used to set the sequence to Hammerlsey for quasi-random numbers.</p> <p>The difference is shown below:</p> In\u00a0[3]: Copied! <pre>from distgen.dist import random_generator\n\nshape = (2,100)\n\np1 = random_generator(shape, sequence='hammersley')\np2 = random_generator(shape, 'pseudo')\n\nfig, ax = plt.subplots(1, 2, constrained_layout=True)\n\nax[0].plot(p1[0,:],p1[1,:],'.');\nax[0].set(xlabel='rx', ylabel='ry', title='hammersley');\n\nax[1].plot(p2[0,:],p2[1,:],'*');\nax[1].set(xlabel='rx', ylabel='ry', title='random.rand');\n</pre> from distgen.dist import random_generator  shape = (2,100)  p1 = random_generator(shape, sequence='hammersley') p2 = random_generator(shape, 'pseudo')  fig, ax = plt.subplots(1, 2, constrained_layout=True)  ax[0].plot(p1[0,:],p1[1,:],'.'); ax[0].set(xlabel='rx', ylabel='ry', title='hammersley');  ax[1].plot(p2[0,:],p2[1,:],'*'); ax[1].set(xlabel='rx', ylabel='ry', title='random.rand'); In\u00a0[4]: Copied! <pre>from distgen.dist import Uniform\nvar = 'x'\nverbose=1\nparams={'min_x':2*unit_registry('mm'),'max_x':4*unit_registry('mm')}\nuniform = Uniform(var,verbose=verbose,**params)\nuniform.plot_pdf()\nuniform.plot_cdf()\nuniform.test_sampling()\n</pre> from distgen.dist import Uniform var = 'x' verbose=1 params={'min_x':2*unit_registry('mm'),'max_x':4*unit_registry('mm')} uniform = Uniform(var,verbose=verbose,**params) uniform.plot_pdf() uniform.plot_cdf() uniform.test_sampling() <pre>uniform\n      min_x = 2 mm, max_x = 4 mm\n</pre> In\u00a0[5]: Copied! <pre>from distgen.dist import Linear\nvar = 'x'\nverbose=1\nparams={'min_x':-2*unit_registry('mm'),\n        'max_x':1*unit_registry('mm'),\n        'slope_fraction':-1\n       }\nnorm = Linear(var,verbose=verbose,**params)\nnorm.plot_pdf()\nnorm.plot_cdf()\nnorm.test_sampling()\n</pre> from distgen.dist import Linear var = 'x' verbose=1 params={'min_x':-2*unit_registry('mm'),         'max_x':1*unit_registry('mm'),         'slope_fraction':-1        } norm = Linear(var,verbose=verbose,**params) norm.plot_pdf() norm.plot_cdf() norm.test_sampling() <pre>Linear\n</pre> In\u00a0[6]: Copied! <pre>from distgen.dist import Norm\nvar = 'x'\nverbose=1\nparams={'sigma_x':2*unit_registry('mm'),'avg_x':-1*unit_registry('mm')}\nnorm = Norm(var,verbose=verbose,**params)\nnorm.plot_pdf()\nnorm.plot_cdf()\nnorm.test_sampling()\n</pre> from distgen.dist import Norm var = 'x' verbose=1 params={'sigma_x':2*unit_registry('mm'),'avg_x':-1*unit_registry('mm')} norm = Norm(var,verbose=verbose,**params) norm.plot_pdf() norm.plot_cdf() norm.test_sampling() <pre>Gaussian\n      avg_x = -1 mm, sigma_x = 2.000 mm\n</pre> <p>Below the $N_{\\text{cutoff}}$ parameter is set to cut the distribution symmetrically:</p> In\u00a0[7]: Copied! <pre>from distgen.dist import Norm\nvar = 'x'\nverbose=1\nparams={'sigma_x':2*unit_registry('mm'),'avg_x':0*unit_registry('mm'), 'n_sigma_cutoff':2}\nnorm = Norm(var,verbose=verbose,**params)\nnorm.plot_pdf()\nnorm.plot_cdf()\nnorm.test_sampling()\n</pre> from distgen.dist import Norm var = 'x' verbose=1 params={'sigma_x':2*unit_registry('mm'),'avg_x':0*unit_registry('mm'), 'n_sigma_cutoff':2} norm = Norm(var,verbose=verbose,**params) norm.plot_pdf() norm.plot_cdf() norm.test_sampling() <pre>Gaussian\n      avg_x = 0 mm, sigma_x = 2.000 mm\n      Left n_sigma_cutoff = 2, Right n_sigma_cutoff = -2\n</pre> <p>The distribution can be truncated asymmetrically using the $N_{\\text{cutoff},R}$ and $N_{\\text{cutoff},L}$ parameters, as shown below.  Note in this case, it is only required that $N_{\\text{cutoff},L} &lt; N_{\\text{cutoff},R}$, allowing for completley arbtitray location of the truncation points.  This requires a minus sign for the cut off parameters for truncation values less than zero.</p> In\u00a0[8]: Copied! <pre>from distgen.dist import Norm\nparams={'sigma_x':2*unit_registry('mm'),\n        'avg_x':0*unit_registry('mm'), \n        'n_sigma_cutoff_left':-1.5,\n        'n_sigma_cutoff_right':1}\n\nnorm = Norm('x',verbose=1,**params)\nnorm.plot_pdf()\nnorm.plot_cdf()\nnorm.test_sampling()\n</pre> from distgen.dist import Norm params={'sigma_x':2*unit_registry('mm'),         'avg_x':0*unit_registry('mm'),          'n_sigma_cutoff_left':-1.5,         'n_sigma_cutoff_right':1}  norm = Norm('x',verbose=1,**params) norm.plot_pdf() norm.plot_cdf() norm.test_sampling() <pre>Gaussian\n      avg_x = 0 mm, sigma_x = 2.000 mm\n      Left n_sigma_cutoff = 1, Right n_sigma_cutoff = -1.5\n</pre> In\u00a0[9]: Copied! <pre>from distgen.dist import SuperGaussian\n\nps = [0.5, 1 , 5, float('Inf')]\nalphas = [0, 0.25, 0.5, 1]\n\nfig, (ax1, ax2) = plt.subplots(1, 2,\n                               sharex='col',\n                               figsize=(12,4),\n                               constrained_layout=True)\n\nplegs = ['p = '+str(p) for p in ps]\nalegs = ['$\\\\alpha$ = '+str(a) for a in alphas]\n\nfor ii,p in enumerate(ps):\n    pparams = {'lambda':2*unit_registry('mm'),\n              'p':p*unit_registry('dimensionless'),}\n    \n    supG = SuperGaussian('x',verbose=0,**pparams)\n    x = supG.get_x_pts(1000)\n    rho = supG.pdf(x)\n    ax1.plot(x,rho);\n    \n    a=alphas[ii]\n    aparams = {'lambda':2*unit_registry('mm'),\n              'alpha':a*unit_registry('dimensionless'),}\n    \n    x = np.linspace(-3*aparams['lambda'], 3*aparams['lambda'],100)\n    supG = SuperGaussian('x',verbose=0,**aparams)\n    rho = supG.pdf(x)\n    ax2.plot(x,rho);\n    \nax1.set_xlabel('x (mm)');    ax2.set_xlabel('x (mm)');\nax1.set_ylabel('pdf (1/mm)');ax2.set_ylabel('pdf (1/mm)');\nax1.legend(plegs);           ax2.legend(alegs);\n</pre> from distgen.dist import SuperGaussian  ps = [0.5, 1 , 5, float('Inf')] alphas = [0, 0.25, 0.5, 1]  fig, (ax1, ax2) = plt.subplots(1, 2,                                sharex='col',                                figsize=(12,4),                                constrained_layout=True)  plegs = ['p = '+str(p) for p in ps] alegs = ['$\\\\alpha$ = '+str(a) for a in alphas]  for ii,p in enumerate(ps):     pparams = {'lambda':2*unit_registry('mm'),               'p':p*unit_registry('dimensionless'),}          supG = SuperGaussian('x',verbose=0,**pparams)     x = supG.get_x_pts(1000)     rho = supG.pdf(x)     ax1.plot(x,rho);          a=alphas[ii]     aparams = {'lambda':2*unit_registry('mm'),               'alpha':a*unit_registry('dimensionless'),}          x = np.linspace(-3*aparams['lambda'], 3*aparams['lambda'],100)     supG = SuperGaussian('x',verbose=0,**aparams)     rho = supG.pdf(x)     ax2.plot(x,rho);      ax1.set_xlabel('x (mm)');    ax2.set_xlabel('x (mm)'); ax1.set_ylabel('pdf (1/mm)');ax2.set_ylabel('pdf (1/mm)'); ax1.legend(plegs);           ax2.legend(alegs); <p>To set the length scale of the distribution, the user must either supply 'sigma_[var]' or 'lambda'. See usage below:</p> In\u00a0[10]: Copied! <pre>params = {'sigma_x':2*unit_registry('mm'),\n          #'alpha': 0.75*unit_registry('dimensionless'),\n           'alpha': 0.003*unit_registry('dimensionless'),\n          'avg_x':0.25*unit_registry('mm')}\n\nsupG = SuperGaussian('x',verbose=1,**params)\nsupG.plot_pdf()\nsupG.plot_cdf()\nsupG.test_sampling()\n</pre> params = {'sigma_x':2*unit_registry('mm'),           #'alpha': 0.75*unit_registry('dimensionless'),            'alpha': 0.003*unit_registry('dimensionless'),           'avg_x':0.25*unit_registry('mm')}  supG = SuperGaussian('x',verbose=1,**params) supG.plot_pdf() supG.plot_cdf() supG.test_sampling() <pre>Super Gaussian\n      sigma_x = 2 mm, power = 333.333\n</pre> <p>Disgten supports importing a 1D PDF saved in column form in.  The input form of the file should have space separated headers such as $x$ and $Px$, with corresponding column data below it.  The PDF is normalized numerically using the numpy.trapz numerical integration routine. The CDF is computed using the scipy.cumtrapz cumulative numerical intgration routine.</p> <p>The following example shows a gaussian PDF with cuts added to it.</p> In\u00a0[11]: Copied! <pre>from distgen.dist import File1d\nvar = 't'\nverbose=1\nparams={'file':'../examples/data/cutgauss.1d.txt','units':'ps'}\nfile1d = File1d(var,verbose=verbose,**params)\nfile1d.plot_pdf()\nfile1d.plot_cdf()\nfile1d.test_sampling()\n</pre> from distgen.dist import File1d var = 't' verbose=1 params={'file':'../examples/data/cutgauss.1d.txt','units':'ps'} file1d = File1d(var,verbose=verbose,**params) file1d.plot_pdf() file1d.plot_cdf() file1d.test_sampling() <pre>t-distribution file: \"../examples/data/cutgauss.1d.txt\"\n</pre> In\u00a0[12]: Copied! <pre>from distgen.dist import TemporalLaserPulseStacking\nverbose=1\nparams={'crystal_length_1': 15.096*unit_registry('mm'),\n        'crystal_length_2': 7.548*unit_registry('mm'), \n        'crystal_length_3': 3.774*unit_registry('mm'), \n        'crystal_length_4': 1.887*unit_registry('mm'), \n        'crystal_angle_1':  0.6*unit_registry('deg'), \n        'crystal_angle_2':  1.8*unit_registry('deg'), \n        'crystal_angle_3': -0.9*unit_registry('deg'),  \n        'crystal_angle_4': -0.5*unit_registry('deg'), }\n    \nlaser_pulse = TemporalLaserPulseStacking(verbose=verbose,**params)\nlaser_pulse.plot_pdf()\nlaser_pulse.plot_cdf()\nlaser_pulse.test_sampling()\n</pre> from distgen.dist import TemporalLaserPulseStacking verbose=1 params={'crystal_length_1': 15.096*unit_registry('mm'),         'crystal_length_2': 7.548*unit_registry('mm'),          'crystal_length_3': 3.774*unit_registry('mm'),          'crystal_length_4': 1.887*unit_registry('mm'),          'crystal_angle_1':  0.6*unit_registry('deg'),          'crystal_angle_2':  1.8*unit_registry('deg'),          'crystal_angle_3': -0.9*unit_registry('deg'),           'crystal_angle_4': -0.5*unit_registry('deg'), }      laser_pulse = TemporalLaserPulseStacking(verbose=verbose,**params) laser_pulse.plot_pdf() laser_pulse.plot_cdf() laser_pulse.test_sampling() <pre>crystal temporal laser shaping\n      crystal 1 length = 15.096 mm, angle = 0.6 deg\n      crystal 2 length = 7.548 mm, angle = 1.8 deg\n      crystal 3 length = 3.774 mm, angle = -0.9 deg\n      crystal 4 length = 1.887 mm, angle = -0.5 deg\n      Pulses propagated: min t = -23.9053 ps, max t = 23.9053 ps\n</pre> In\u00a0[13]: Copied! <pre>from distgen.dist import Tukey\nvar = 'y'\nverbose=1\nparams={'length':2*unit_registry('mm'),'ratio':0.75*unit_registry('dimensionless')}\ntukey = Tukey(var,verbose=1,**params)\ntukey.plot_pdf()\ntukey.plot_cdf()\ntukey.test_sampling()\n</pre> from distgen.dist import Tukey var = 'y' verbose=1 params={'length':2*unit_registry('mm'),'ratio':0.75*unit_registry('dimensionless')} tukey = Tukey(var,verbose=1,**params) tukey.plot_pdf() tukey.plot_cdf() tukey.test_sampling() <pre>Tukey\n      length = 2 mm, ratio = 0.75\n</pre> In\u00a0[14]: Copied! <pre>from distgen.dist import Superposition\n\nparams = {\n    'weights':{'d1':1, 'd2':2},\n    'dists':{\n        'd1':{\n            'avg_z':-2*unit_registry('mm'),\n            'sigma_z':1*unit_registry('mm'),\n            'type': 'gaussian'\n        } ,\n        'd2':{\n            'avg_z':+2*unit_registry('mm'),\n            'sigma_z':1*unit_registry('mm'),\n            'type': 'gaussian'\n        } \n    }\n}\n\nsup = Superposition('z', 1, **params)\nsup.plot_pdf()\nsup.plot_cdf()\nsup.test_sampling()\n</pre> from distgen.dist import Superposition  params = {     'weights':{'d1':1, 'd2':2},     'dists':{         'd1':{             'avg_z':-2*unit_registry('mm'),             'sigma_z':1*unit_registry('mm'),             'type': 'gaussian'         } ,         'd2':{             'avg_z':+2*unit_registry('mm'),             'sigma_z':1*unit_registry('mm'),             'type': 'gaussian'         }      } }  sup = Superposition('z', 1, **params) sup.plot_pdf() sup.plot_cdf() sup.test_sampling() <pre>superpostion\n      1. distribution name: d1, type: Gaussian\n         avg_z = -2 mm, sigma_z = 1.000 mm\n      2. distribution name: d2, type: Gaussian\n         avg_z = 2 mm, sigma_z = 1.000 mm\n</pre> In\u00a0[15]: Copied! <pre>from distgen.dist import Product\n\nparams = {\n    'dists':{\n        'd1':{\n            'min_z':-3*unit_registry('mm'),\n            'max_z':3*unit_registry('mm'),\n            'type': 'uniform'\n        } ,\n        'd2':{\n            'avg_z':+0*unit_registry('mm'),\n            'sigma_z':3*unit_registry('mm'),\n            'type': 'gaussian'\n        } \n    }\n}\n\npro = Product('z', 1, **params)\npro.plot_pdf()\npro.plot_cdf()\npro.test_sampling()\n</pre> from distgen.dist import Product  params = {     'dists':{         'd1':{             'min_z':-3*unit_registry('mm'),             'max_z':3*unit_registry('mm'),             'type': 'uniform'         } ,         'd2':{             'avg_z':+0*unit_registry('mm'),             'sigma_z':3*unit_registry('mm'),             'type': 'gaussian'         }      } }  pro = Product('z', 1, **params) pro.plot_pdf() pro.plot_cdf() pro.test_sampling() <pre>\ndistribution name: d1\nuniform\n      min_z = -3 mm, max_z = 3 mm\n\ndistribution name: d2\nGaussian\n      avg_z = 0 mm, sigma_z = 3.000 mm\n</pre> In\u00a0[16]: Copied! <pre>from distgen.dist import Deformable\n\nparams = {'alpha':0.750*unit_registry(''),\n          'slope_fraction':-1,\n          'sigma_x':2*unit_registry('mm'),\n          'avg_x':  0*unit_registry('mm')}\n\ndeform = Deformable('x', verbose=1, **params)\ndeform.plot_pdf()\ndeform.plot_cdf()\ndeform.test_sampling()\n</pre> from distgen.dist import Deformable  params = {'alpha':0.750*unit_registry(''),           'slope_fraction':-1,           'sigma_x':2*unit_registry('mm'),           'avg_x':  0*unit_registry('mm')}  deform = Deformable('x', verbose=1, **params) deform.plot_pdf() deform.plot_cdf() deform.test_sampling() <pre>Super Gaussian\n      sigma_x = 2 mm, power = 1.33333\nLinear\n</pre> In\u00a0[17]: Copied! <pre>from distgen.dist import Interpolation1d\n\nparams = {'avg_t': 0.0*unit_registry('ps'),\n          'sigma_t':2*unit_registry('ps'),\n          'Pt':[1, 2.2, 3.3, 4, 3, 2, 6, 7, 7.5, 8, 7.5, 1],\n          'method':'spline',\n          'n_pts':1000\n         }\n\ni1d = Interpolation1d('t', verbose=1, **params)\n\ni1d.plot_pdf()\ni1d.plot_cdf()\ni1d.test_sampling()\n</pre> from distgen.dist import Interpolation1d  params = {'avg_t': 0.0*unit_registry('ps'),           'sigma_t':2*unit_registry('ps'),           'Pt':[1, 2.2, 3.3, 4, 3, 2, 6, 7, 7.5, 8, 7.5, 1],           'method':'spline',           'n_pts':1000          }  i1d = Interpolation1d('t', verbose=1, **params)  i1d.plot_pdf() i1d.plot_cdf() i1d.test_sampling() In\u00a0[18]: Copied! <pre>params = {'avg_t': 0.0*unit_registry('ps'),\n          'sigma_t':2*unit_registry('ps'),\n          'Pt':{'pt1':1,\n                'pt2':2.2, \n                'pt3':3.3, \n                'pt4':4, \n                'pt5':3, \n                'pt6':2, \n                'pt7':6, \n                'pt8':7, \n                'pt9':7.5, \n                'pt10':8, \n                'pt11':7.5, \n                'pt12':1\n               },\n          'method':'spline',\n          'n_pts':1000\n         }\n\ni1d = Interpolation1d('t', verbose=1, **params)\n\ni1d.plot_pdf()\ni1d.plot_cdf()\ni1d.test_sampling()\n</pre> params = {'avg_t': 0.0*unit_registry('ps'),           'sigma_t':2*unit_registry('ps'),           'Pt':{'pt1':1,                 'pt2':2.2,                  'pt3':3.3,                  'pt4':4,                  'pt5':3,                  'pt6':2,                  'pt7':6,                  'pt8':7,                  'pt9':7.5,                  'pt10':8,                  'pt11':7.5,                  'pt12':1                },           'method':'spline',           'n_pts':1000          }  i1d = Interpolation1d('t', verbose=1, **params)  i1d.plot_pdf() i1d.plot_cdf() i1d.test_sampling() In\u00a0[19]: Copied! <pre>from distgen.dist import UniformRad\nverbose=1\nparams={'min_r':1*unit_registry('mm'),'max_r':2*unit_registry('mm')}\nurad = UniformRad(verbose=1,**params)\nurad.plot_pdf()\nurad.plot_cdf()\nurad.test_sampling()\n</pre> from distgen.dist import UniformRad verbose=1 params={'min_r':1*unit_registry('mm'),'max_r':2*unit_registry('mm')} urad = UniformRad(verbose=1,**params) urad.plot_pdf() urad.plot_cdf() urad.test_sampling() <pre>radial uniform\n      min_r = 1 mm, max_r = 2 mm\n</pre> In\u00a0[20]: Copied! <pre>from distgen.dist import LinearRad\nverbose=1\nparams={'min_r':0*unit_registry('mm'),\n        'max_r':2*unit_registry('mm'),\n        'slope_fraction':1\n       }\n\nlin = LinearRad(verbose=verbose,**params)\nlin.plot_pdf()\nlin.plot_cdf()\nlin.test_sampling()\n</pre> from distgen.dist import LinearRad verbose=1 params={'min_r':0*unit_registry('mm'),         'max_r':2*unit_registry('mm'),         'slope_fraction':1        }  lin = LinearRad(verbose=verbose,**params) lin.plot_pdf() lin.plot_cdf() lin.test_sampling()  <pre>LinearRad\n</pre> In\u00a0[21]: Copied! <pre>from distgen.dist import NormRad\nverbose=1\nparams={'sigma_xy':1*unit_registry('mm')}\nnrad = NormRad(verbose=1,**params)\nnrad.plot_pdf()\nnrad.plot_cdf()\nnrad.test_sampling()\n</pre> from distgen.dist import NormRad verbose=1 params={'sigma_xy':1*unit_registry('mm')} nrad = NormRad(verbose=1,**params) nrad.plot_pdf() nrad.plot_cdf() nrad.test_sampling() <pre>radial Gaussian\n</pre> <p>For laser scientists it can be convenient to to work with a pinhole radius and a fraction of the laser intensity to clip a transverse normal laser mode at.  In this case the user can supply a truncation radius ($=r_R$) and a truncation fraction $f = \\exp\\left(-\\frac{r_R^2}{2\\sigma}\\right)$ from which distgen determines the underlying $\\sigma$.  The example below demonstrates this usage:</p> In\u00a0[22]: Copied! <pre>from distgen.dist import NormRad\nverbose=1\nparams={'truncation_radius':1*unit_registry('mm'),'truncation_fraction':0.5*unit_registry('dimensionless')}\nnrad = NormRad(verbose=1,**params)\nnrad.plot_pdf()\nnrad.plot_cdf()\nnrad.test_sampling()\n</pre> from distgen.dist import NormRad verbose=1 params={'truncation_radius':1*unit_registry('mm'),'truncation_fraction':0.5*unit_registry('dimensionless')} nrad = NormRad(verbose=1,**params) nrad.plot_pdf() nrad.plot_cdf() nrad.test_sampling() <pre>radial Gaussian\n</pre> In\u00a0[23]: Copied! <pre>from distgen.dist import NormRad\nverbose=1\nparams={'sigma_xy':2*unit_registry('mm'),'n_sigma_cutoff':1}\nnrad = NormRad(verbose=1,**params)\nnrad.plot_pdf()\nnrad.plot_cdf()\nnrad.test_sampling()\n</pre> from distgen.dist import NormRad verbose=1 params={'sigma_xy':2*unit_registry('mm'),'n_sigma_cutoff':1} nrad = NormRad(verbose=1,**params) nrad.plot_pdf() nrad.plot_cdf() nrad.test_sampling() <pre>radial Gaussian\n</pre> In\u00a0[24]: Copied! <pre>from distgen.dist import TukeyRad\nverbose=1\nparams={'length':1*unit_registry('mm'),'ratio':0.75*unit_registry('dimensionless')}\nrtukey = TukeyRad(verbose=1,**params)\nrtukey.plot_pdf()\nrtukey.plot_cdf()\nrtukey.test_sampling()\n</pre> from distgen.dist import TukeyRad verbose=1 params={'length':1*unit_registry('mm'),'ratio':0.75*unit_registry('dimensionless')} rtukey = TukeyRad(verbose=1,**params) rtukey.plot_pdf() rtukey.plot_cdf() rtukey.test_sampling() <pre>TukeyRad\n      legnth = 1.000 mm, ratio = 0.750\n</pre> In\u00a0[25]: Copied! <pre>from distgen.dist import SuperGaussianRad\nverbose=1\nparams={'sigma_xy':1*unit_registry('mm'),\n        'alpha':0.0*unit_registry('dimensionless')}\nsupG = SuperGaussianRad(verbose=1,**params)\nsupG.plot_pdf()\nsupG.plot_cdf()\nsupG.test_sampling()\n</pre> from distgen.dist import SuperGaussianRad verbose=1 params={'sigma_xy':1*unit_registry('mm'),         'alpha':0.0*unit_registry('dimensionless')} supG = SuperGaussianRad(verbose=1,**params) supG.plot_pdf() supG.plot_cdf() supG.test_sampling() <pre>SuperGaussianRad\n      lambda = 1.41421 mm, power = INF\n</pre> In\u00a0[26]: Copied! <pre>from distgen.dist import RadFile\n\nparams = {'file':'../examples/data/cutgauss.rad.txt','units':'mm'}\n\nrfd = RadFile(verbose=1, **params)\nrfd.plot_pdf()\nrfd.plot_cdf()\nrfd.test_sampling()\n</pre> from distgen.dist import RadFile  params = {'file':'../examples/data/cutgauss.rad.txt','units':'mm'}  rfd = RadFile(verbose=1, **params) rfd.plot_pdf() rfd.plot_cdf() rfd.test_sampling() <pre>radial file\n      r-dist file: \"../examples/data/cutgauss.rad.txt\"\n</pre> In\u00a0[27]: Copied! <pre>from distgen.dist import DeformableRad\n\nparams = {\n    'alpha':0.05*unit_registry(''),\n    'slope_fraction':-1,\n    'sigma_xy':2*unit_registry('mm'),\n}\n\ndeform = DeformableRad(verbose=1, **params)\ndeform.plot_pdf()\ndeform.plot_cdf()\ndeform.test_sampling()\n</pre> from distgen.dist import DeformableRad  params = {     'alpha':0.05*unit_registry(''),     'slope_fraction':-1,     'sigma_xy':2*unit_registry('mm'), }  deform = DeformableRad(verbose=1, **params) deform.plot_pdf() deform.plot_cdf() deform.test_sampling() <pre>SuperGaussianRad\n      lambda = 2.86117 mm, power = 20\nLinearRad\n</pre>"},{"location":"regression_tests/dist/#dist-regression-tests","title":"Dist Regression Tests\u00b6","text":""},{"location":"regression_tests/dist/#random-number-generation","title":"Random Number Generation\u00b6","text":""},{"location":"regression_tests/dist/#1d-distributions","title":"1D Distributions\u00b6","text":"<p>Distgen supports several one dimensional distribution types.</p>"},{"location":"regression_tests/dist/#uniform-1d","title":"Uniform 1D\u00b6","text":"<p>The uniform distirbuition is defined by a probability distribution function:</p> <p>$\\rho(x) = \\frac{1}{b-a}$ for $a\\leq x\\leq b$ and zero elsewhere.</p> <p>The corresponding CDF is</p> <p>$P(x) = \\frac{x-a}{b-a}$ for $a\\leq x\\leq b$ and zero elsewhere.</p> <p>The first and second moments of this distribution are:</p> <p>$\\langle x \\rangle = \\frac{1}{2}(a+b)$ and $\\sigma_x = \\frac{b-a}{\\sqrt{12}}$</p>"},{"location":"regression_tests/dist/#linear","title":"Linear\u00b6","text":"<p>The linear distirbuition is defined by a probability distribution function:</p> <p>$\\rho(x) \\propto \\frac{\\rho_b-\\rho_a}{b-a}(x-a) + \\rho_a$ for $a\\leq x\\leq b$ and zero elsewhere.</p> <p>The corresponding CDF is</p> <p>$P(x) \\propto \\frac{1}{2}\\frac{\\rho_b-\\rho_a}{b-a}(x-a)$ for $a\\leq x\\leq b$ and zero elsewhere.</p> <p>The first and second moments of this distribution are:</p> <p>$\\langle x \\rangle \\propto \\frac{\\rho_b-\\rho_a}{b-a}\\left(\\frac{1}{3}(b^3-a^3) -a(b^2-a^2)\\right) + \\frac{1}{2}\\rho_a(b^2-a^2)$.</p> <p>and $\\sigma_x = ?$.</p>"},{"location":"regression_tests/dist/#normal-distribution-including-truncation","title":"Normal Distribution (including truncation)\u00b6","text":"<p>The general form of a normal distribution PDF with truncation is given by</p> <p>$\\rho(x) = \\frac{1}{\\sigma}\\frac{\\phi\\left(\\frac{x-\\mu}{\\sigma}\\right)}{\\Phi\\left(\\frac{b-\\mu}{\\sigma}\\right)-\\Phi\\left(\\frac{a-\\mu}{\\sigma}\\right)}$.</p> <p>In this expression $\\phi(\\xi) = \\frac{1}{\\sqrt{2\\pi}}e^{-\\frac{1}{2}\\xi^2}$ is the canonical normal distribution, $\\Phi(\\xi) = \\frac{1}{2}\\left[1 + \\text{erf}\\left(\\frac{\\xi}{\\sqrt{2}}\\right) \\right]$ is the canonical normal CDF, and $a=-N_{\\text{cutoff}}\\cdot\\sigma$ and $b=-N_{\\text{cutoff}}\\cdot\\sigma$ are the left and right truncation points.  The CDF if given by</p> <p>$P(x) = \\frac{\\Phi\\left(\\frac{x-\\mu}{\\sigma}\\right) - \\Phi\\left(\\frac{a-\\mu}{\\sigma}\\right)}{\\Phi\\left(\\frac{b-\\mu}{\\sigma}\\right)-\\Phi\\left(\\frac{a-\\mu}{\\sigma}\\right)}$.</p> <p>Defining $\\alpha = \\frac{a-\\mu}{\\sigma}$ and $\\beta = \\frac{b-\\mu}{\\sigma}$, the first and second moments of the distribution are:</p> <p>$\\langle x\\rangle = \\mu + \\frac{\\phi\\left(\\alpha\\right) - \\phi\\left(\\beta\\right)}{\\Phi\\left(\\beta\\right)-\\Phi\\left(\\alpha\\right)}\\sigma$ and $\\sigma_x = \\sigma \\left\\{1 + \\frac{\\alpha\\phi\\left(\\alpha\\right) - \\beta\\phi(\\beta) }{\\Phi(\\beta) - \\Phi(\\alpha)} - \\left(\\frac{\\phi\\left(\\alpha\\right) - \\phi(\\beta)}{\\Phi(\\beta) - \\Phi(\\alpha)}\\right)^{2} \\right\\}^{1/2} $.</p> <p>When using this distribution, if the $N_{\\text{cutoff}}$ is not set then the distribution reduces to an infinite range normal distribution, as first shown below:</p>"},{"location":"regression_tests/dist/#super-gaussian","title":"Super Gaussian\u00b6","text":"<p>In additional to the regular Gaussian function, it is also possible to sample a super-Gaussian distribution defined by</p> <p>$\\rho(x; \\lambda, p) = \\frac{1}{2\\sqrt{2}\\Gamma\\left(1+\\frac{1}{2p}\\right)\\lambda } \\exp\\left[-\\left(\\frac{(x-\\mu)^2 }{2\\lambda^2}\\right)^{p}\\right]$</p> <p>Here $\\sigma_1$ is the length scale and $p$ is the power of the super-Gaussian. Note when $p=1$ reduces to a Normal distirbution, in which case $\\sigma_x=\\lambda$.  As $p\\rightarrow\\infty$ the distribution reduces to a flat-top (uniform). The full range of powers is given by $p\\in\\left(0,\\infty\\right]$.</p> <p>The first and second moments of the distribution are given by:</p> <p>$\\langle x\\rangle = \\mu$, and $\\sigma_x = \\left(\\frac{2\\Gamma\\left(1+\\frac{3}{2p}\\right)}{3\\Gamma\\left(1+\\frac{1}{2p}\\right)}\\right)^{1/2}\\lambda$.</p> <p>Often, it is convenient to scan the distribution from the uniform limit to the Gaussian limit.  To do some, the input $p$ can be parameterized by $\\alpha\\in[0,1]$ where $p = 1/\\alpha$.  Here $\\alpha=0$ corresponds to a flat-top (uniform) and $\\alpha=1$ corresponds to a Gaussian.  Examples of both types of usage are shown below.</p>"},{"location":"regression_tests/dist/#1d-pdf-from-a-file","title":"1D PDF from a file\u00b6","text":""},{"location":"regression_tests/dist/#laser-pulse-stacking","title":"Laser pulse stacking\u00b6","text":""},{"location":"regression_tests/dist/#tukey-1d","title":"Tukey 1D\u00b6","text":""},{"location":"regression_tests/dist/#superposition-1d","title":"Superposition 1D\u00b6","text":"<p>This distribution allows the user to superimpose an arbitrary number of 1D PDFs.  The general form is:</p> <p>$\\rho(x) = \\sum_i w_i \\frac{\\rho_i(x)}{\\max(\\rho_i)}$.</p> <p>Here the $w_i$ are user specified weights.  If no weight is specified for a given $rho_i$, then the weight will default to one.</p>"},{"location":"regression_tests/dist/#product-dist-1d","title":"Product Dist 1D\u00b6","text":"<p>This distribution allows the user to multiply an arbitrary number of 1D PDFs.  The general form is:</p> <p>$\\rho(x) = \\prod_i \\rho_i(x)$.</p>"},{"location":"regression_tests/dist/#deformable","title":"Deformable\u00b6","text":""},{"location":"regression_tests/dist/#interpolation1d","title":"Interpolation1D\u00b6","text":""},{"location":"regression_tests/dist/#radial-distributions","title":"Radial Distributions\u00b6","text":""},{"location":"regression_tests/dist/#radial-linear","title":"Radial Linear\u00b6","text":""},{"location":"regression_tests/dist/#radial-normal-distribution-with-truncation","title":"Radial Normal Distribution (with truncation)\u00b6","text":"<p>The radial normal distribution including truncation(s) has a probability function given by</p> <p>$\\rho_r(r) = \\frac{1}{\\sigma^2}\\frac{\\phi(r/\\sigma)}{\\phi\\left(\\frac{r_L}{\\sigma}\\right)-\\phi\\left(\\frac{r_R}{\\sigma}\\right)} $ for $0 \\leq r_L \\leq r \\leq r_R$ and zero everywhere else.</p> <p>In this expresion $\\phi(\\xi) = \\frac{1}{2\\pi}\\exp\\left(-\\xi^2/2\\right)$ is the canonical raidial normal distirbution (no truncation), and the scale parameter $\\sigma$ follows from the product of two normal distributions in $x$ and $y$ when $\\sigma=\\sigma_x=\\sigma_y$.  The corresponding CDF is given by</p> <p>$P(r)= \\frac{\\phi\\left(\\frac{r_L}{\\sigma}\\right)-\\phi\\left(\\frac{r}{\\sigma}\\right)}{\\phi\\left(\\frac{r_L}{\\sigma}\\right)-\\phi\\left(\\frac{r_R}{\\sigma}\\right)} $ for $0 \\leq r_L \\leq r$.</p> <p>The corresponding first and second moments are:</p> <p>$\\langle r\\rangle = \\frac{\\frac{r_L}{\\sigma}\\phi\\left(\\frac{r_L}{\\sigma}\\right) -\\frac{r_R}{\\sigma}\\phi\\left(\\frac{r_R}{\\sigma}\\right) +\\frac{1}{2\\sqrt{2\\pi}}\\left( \\text{erf}\\left(\\frac{r_R}{\\sigma\\sqrt{2}}\\right) - \\text{erf}\\left(\\frac{r_L}{\\sigma\\sqrt{2}}\\right) \\right)  } {\\phi\\left(\\frac{r_L}{\\sigma}\\right)-\\phi\\left(\\frac{r_R}{\\sigma}\\right)}$,</p> <p>$r_{rms} = \\sqrt{ 2\\sigma^2 + r_L^2 - \\frac{(r_R^2-r_L^2)\\phi(r_R/\\sigma)}{\\phi\\left(\\frac{r_L}{\\sigma}\\right)-\\phi\\left(\\frac{r_R}{\\sigma}\\right)} }$.</p> <p>Note that in the limits $r_L\\rightarrow 0$ and $r_R -&gt; \\infty$ the above expressions reduce to the underlying radial normal distribution:</p> <p>$\\rho_r(r)\\rightarrow \\frac{\\phi\\left(\\frac{r}{\\sigma}\\right)}{\\sigma^2}$, $P(r)\\rightarrow 1 - \\phi\\left(\\frac{r}{\\sigma}\\right)$, $\\langle r\\rangle\\rightarrow \\sqrt{\\frac{\\pi}{2}}\\sigma$, and $r_{rms}\\rightarrow \\sqrt{2}\\sigma$.  This limiting case is shown first below.</p>"},{"location":"regression_tests/dist/#radial-tukey","title":"Radial Tukey\u00b6","text":""},{"location":"regression_tests/dist/#radial-super-gaussian","title":"Radial Super Gaussian\u00b6","text":"<p>This implements a radial version of the Super Gaussian function discussed above.  Here the radial function takes the form:</p> <p>$2\\pi\\rho(r;\\lambda,p) = \\frac{1}{\\Gamma\\left(1+\\frac{1}{p}\\right)\\lambda^2} \\exp\\left[-\\left(\\frac{r^2}{2\\lambda^2}\\right)^p\\right]$.</p> <p>The first and (rms) second moment of the distribution are given by:</p> <p>$\\langle r\\rangle = \\frac{2\\sqrt{2}}{3}\\frac{\\Gamma\\left(1+\\frac{3}{2p}\\right)}{\\Gamma\\left(1+\\frac{1}{p}\\right)}\\lambda$,</p> <p>$r_{\\text{rms}} = \\sqrt{\\frac{\\Gamma\\left(1+\\frac{2}{p}\\right)}{\\Gamma\\left(1+\\frac{1}{p}\\right)}}\\lambda$.</p>"},{"location":"regression_tests/dist/#radial-file-distribution","title":"Radial File Distribution\u00b6","text":""},{"location":"regression_tests/dist/#deformable","title":"Deformable\u00b6","text":""},{"location":"regression_tests/dist/#angular-distributions-todo","title":"Angular Distributions (TODO)\u00b6","text":"<p>Angular distributions define one dimensional probability functions for the cylindrical variable $\\theta$.</p>"}]}