{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Distgen","text":"<p>Distgen is a particle generator for accelerator physics applications. Distgen supports nearly arbitrary generation of 6D + time particle coordinates.</p>"},{"location":"installation/","title":"Installing Distgen","text":""},{"location":"installation/#using-conda","title":"Using conda","text":"<pre><code>conda install -c conda-forge pytao\n</code></pre>"},{"location":"installation/#using-setuptools","title":"Using setuptools","text":"<pre><code>python setup.py install\n</code></pre>"},{"location":"installation/#developers","title":"Developers","text":"<p>Clone this repository: <pre><code>git clone https://github.com/ColwynGulliford/distgen.git\n</code></pre></p> <p>Create an environment <code>distgen-dev</code> with all the dependencies: <pre><code>conda env create -f environment-dev.yml\n</code></pre></p> <p>Install as editable: <pre><code>conda activate distgen-dev\npip install --no-dependencies -e .\n</code></pre></p> <p>Create documentation: <pre><code>mkdocs serve\n</code></pre></p>"},{"location":"examples/basic/","title":"Distgen basic usage","text":"In\u00a0[1]: Copied! <pre># Useful for debugging\n%load_ext autoreload\n%autoreload 2\n%config InlineBackend.figure_format = 'retina'\n\nfrom matplotlib import pyplot as plt\nimport numpy as np\nimport os\nimport yaml\n</pre> # Useful for debugging %load_ext autoreload %autoreload 2 %config InlineBackend.figure_format = 'retina'  from matplotlib import pyplot as plt import numpy as np import os import yaml <p>Distgen supports nearly arbitrary generation of 6D + time particle coordinates.</p> <p>Generator class defines the main object that creates a beam distribution.  Typical usage is to supply the <code>Generator.__init__(input, verbose)</code> with an input file name and a verbose integer value to control the level of output printed to the user.  Input file types can be either json or YAML. The user may also supply a dictionary as the input argument.</p> In\u00a0[2]: Copied! <pre>from distgen import Generator\n</pre> from distgen import Generator In\u00a0[3]: Copied! <pre>gen = Generator('data/rad.gaussian.in.yaml', verbose=0)\n</pre> gen = Generator('data/rad.gaussian.in.yaml', verbose=0)  <p>Printing a Generator object displays the basic input data read from a distgen input file:</p> In\u00a0[4]: Copied! <pre>print(gen)\n</pre> print(gen) <pre>&lt;disgten.Generator with input: \nn_particle: 200000\noutput:\n  file: rad.gaussian.out.txt\n  type: gpt\nr_dist:\n  sigma_xy:\n    units: millimeter\n    value: 2\n  type: radial_gaussian\nrandom:\n  type: hammersley\nspecies: electron\nstart:\n  MTE:\n    units: millielectron_volt\n    value: 150\n  type: cathode\nt_dist:\n  max_t:\n    units: picosecond\n    value: 2\n  min_t:\n    units: picosecond\n    value: -2\n  type: uniform\ntotal_charge:\n  units: picocoulomb\n  value: 10\ntransforms: null\n\n&gt;\n</pre> <p>This data is stored internally in fully parsed form.  To get this structure it, use the convenience property <code>Generator.input</code>.  Note: there is no setter.</p> In\u00a0[5]: Copied! <pre>gen.input\n</pre> gen.input Out[5]: <pre>{'n_particle': 200000,\n 'species': 'electron',\n 'output': {'file': 'rad.gaussian.out.txt', 'type': 'gpt'},\n 'r_dist': {'sigma_xy': {'value': 2, 'units': 'millimeter'},\n  'type': 'radial_gaussian'},\n 'random': {'type': 'hammersley'},\n 'start': {'MTE': {'value': 150, 'units': 'millielectron_volt'},\n  'type': 'cathode'},\n 't_dist': {'max_t': {'value': 2, 'units': 'picosecond'},\n  'min_t': {'value': -2, 'units': 'picosecond'},\n  'type': 'uniform'},\n 'total_charge': {'value': 10, 'units': 'picocoulomb'},\n 'transforms': None}</pre> <p>The input structure allows for four top levels: generator, beam, {variable}_dists, transforms, and output.  Any other input will throw an exception when attempting to create the beam:</p> In\u00a0[6]: Copied! <pre>try:\n    gen['foo']='bar'\nexcept Exception as ex:\n    print(ex)\n</pre> try:     gen['foo']='bar' except Exception as ex:     print(ex) <pre>Unexpected distgen input parameter: foo\n</pre> <p>Distgen generator.input is a nested dictionary by design.  While this logically organizes the input, it can be somewhat cumbersome for changing input.  Thus the generator.input dictionary can be accessed with pure strings via the [...] method with a flattened dictionary (nested keys separated by ':'):</p> In\u00a0[7]: Copied! <pre>gen['start']\n</pre> gen['start'] Out[7]: <pre>{'MTE': {'value': 150, 'units': 'millielectron_volt'}, 'type': 'cathode'}</pre> In\u00a0[8]: Copied! <pre>gen['start:MTE']\n</pre> gen['start:MTE'] Out[8]: <pre>{'value': 150, 'units': 'millielectron_volt'}</pre> <p>Brackets can also be used to set parameters.  When setting a parameter that has associated units, one must either specify whether setting the value or units, or pass in only the value:</p> In\u00a0[9]: Copied! <pre>gen['start:MTE:value']=120\nprint('New MTE setting:', gen['start:MTE'])\n</pre> gen['start:MTE:value']=120 print('New MTE setting:', gen['start:MTE']) <pre>New MTE setting: {'value': 120, 'units': 'millielectron_volt'}\n</pre> In\u00a0[10]: Copied! <pre>gen['start:MTE:units']='eV'\nprint('New MTE setting:', gen['start:MTE'])\n</pre> gen['start:MTE:units']='eV' print('New MTE setting:', gen['start:MTE']) <pre>New MTE setting: {'value': 120, 'units': 'electron_volt'}\n</pre> In\u00a0[11]: Copied! <pre>gen['start:MTE']=100\nprint('New MTE setting:', gen['start:MTE'])\n</pre> gen['start:MTE']=100 print('New MTE setting:', gen['start:MTE']) <pre>New MTE setting: {'value': 100, 'units': 'electron_volt'}\n</pre> <p>To create a distribution, run <code>Generator.beam()</code>:</p> In\u00a0[12]: Copied! <pre>gen = Generator('data/rad.gaussian.in.yaml', verbose=1) \nbeam = gen.beam()\n</pre> gen = Generator('data/rad.gaussian.in.yaml', verbose=1)  beam = gen.beam() <pre>Distribution format: gpt\nOutput file: rad.gaussian.out.txt\n\nCreating beam distribution....\n   Beam starting from: cathode\n   Total charge: 10 pC.\n   Number of macroparticles: 200000.\n   Assuming cylindrical symmetry...\n</pre> <pre>   r distribution: radial Gaussian\n   theta distribution: uniform theta\n      min_theta = 0 rad, max_theta = 6.28319 rad\n   t distribution: uniform\n      min_t = -2 ps, max_t = 2 ps, avg_t = 0 ps, sigma_t:  1.1547 ps\n   px distribution: Gaussian\n      avg_px = 0 eV/c, sigma_px = 276.857 eV/c\n</pre> <pre>   py distribution: Gaussian\n      avg_py = 0 eV/c, sigma_py = 276.857 eV/c\n   pz distribution: Gaussian\n      avg_pz = 0 eV/c, sigma_pz = 276.857 eV/c\n</pre> <pre>   Shifting avg_x = -7.82345E-05 mm -&gt; 0 mm\n   Scaling sigma_x = 1.99984 mm -&gt; 2 mm\n   Shifting avg_y = -1.09911E-05 mm -&gt; 0 mm\n   Scaling sigma_y = 1.99994 mm -&gt; 2 mm\n   Shifting avg_px = -0.0212516 eV/c -&gt; 0 eV/c\n   Scaling sigma_px = 276.849 eV/c -&gt; 276.857 eV/c\n   Shifting avg_py = -0.0259627 eV/c -&gt; 0 eV/c\n   Scaling sigma_py = 276.844 eV/c -&gt; 276.857 eV/c\n   Shifting avg_pz = -0.0372953 eV/c -&gt; 0 eV/c\n   Scaling sigma_pz = 276.843 eV/c -&gt; 276.857 eV/c\n   Shifting avg_t = -4.90022E-05 ps -&gt; 0 ps\n   Scaling sigma_t = 1.1547 ps -&gt; 1.1547 ps\n   Cathode start: fixing pz momenta to forward hemisphere\n      avg_pz -&gt; 220.904 eV/c, sigma_pz -&gt; 166.887 eV/c\n...done. Time Elapsed: 226.796 ms.\n\n</pre> <p>Alternatively, call <code>.run()</code>, which creates an openPMD-beamphysics style ParticleGroup</p> In\u00a0[13]: Copied! <pre>gen.verbose=False\ngen.run()\ngen.particles\n</pre> gen.verbose=False gen.run() gen.particles Out[13]: <pre>&lt;ParticleGroup with 200000 particles at 0x7f2b6a91e4c0&gt;</pre> <p>Internally, Distgen uses the Pint module to handle/check units automatically, see PINT.</p> In\u00a0[14]: Copied! <pre>from distgen import PHYSICAL_CONSTANTS\n</pre> from distgen import PHYSICAL_CONSTANTS In\u00a0[15]: Copied! <pre>PHYSICAL_CONSTANTS['elementary charge']\n</pre> PHYSICAL_CONSTANTS['elementary charge'] Out[15]:  1.602176634\u00d710<sup>-19</sup> coulomb  In\u00a0[16]: Copied! <pre>PHYSICAL_CONSTANTS.species_list\n</pre> PHYSICAL_CONSTANTS.species_list Out[16]: <pre>['electron', 'photon', 'positron', 'proton', 'muon', 'neutron', 'tau', 'H2+']</pre> <p>Species specific data can be accessed via the <code>.species</code> function, which returns a dictionary of species specific parameters:</p> In\u00a0[17]: Copied! <pre>PHYSICAL_CONSTANTS.species('electron')\n</pre> PHYSICAL_CONSTANTS.species('electron') Out[17]: <pre>{'charge': &lt;Quantity(-1.60217663e-19, 'coulomb')&gt;,\n 'mass': &lt;Quantity(9.1093837e-31, 'kilogram')&gt;,\n 'mc2': &lt;Quantity(510998.95, 'electron_volt')&gt;,\n 'g_factor': &lt;Quantity(-2.0023193, 'dimensionless')&gt;}</pre> <p>The particle coordinates created by the Generator class are stored internally a beam obect.  The main underlying coordinates are the 6D phase space coordinates $x$, $y$, $z$, $p_x$, $p_y$, $p_z$, and time $t$.  These can be accessed via the [...] operator.  The bunch charge is given by beam.q.</p> In\u00a0[18]: Copied! <pre>gen = Generator('data/rad.gaussian.in.yaml', verbose=0) \nbeam = gen.beam()\nprint(\"X coordinates:\", beam['x'])\nprint(\"Bunch charge:\", beam['q'])\n</pre> gen = Generator('data/rad.gaussian.in.yaml', verbose=0)  beam = gen.beam() print(\"X coordinates:\", beam['x']) print(\"Bunch charge:\", beam['q']) <pre>X coordinates: [1.289022452108133 3.050762686067514 2.1456876750642953 ... 2.6094886627111644 1.7667918315956421 3.722370619054455] millimeter\nBunch charge: 10 picocoulomb\n</pre> <p>Currently, the code assumes one particle species (default: electrons) per beam object.  The bunch contains an array of particle weights (currently uniform) for use with averaging.  The particle weights $w$ are normalized $\\sum_i{w_i}=1$ and are used for computing expectation values over the particle ensemble.</p> <p>Simple examples include beam.avg: $\\langle\\mathcal{O}\\rangle = \\sum_i w_i\\mathcal{O}_i$ and beam.std(): $\\sigma_{\\mathcal{O}} = \\sqrt{\\sum_i{w_i(\\mathcal{O}_i-\\langle\\mathcal{O}\\rangle)^2}}$.</p> <p>Other examples include the normalized and geometric emittance and the twiss parameters $\\beta$ and $\\alpha$  (See the distgen.beam.py).</p> In\u00a0[19]: Copied! <pre>print(\"Beam species:\",beam.species)\nprint(\"Weights:\",beam[\"w\"])\nprint(\"Normalization sum(weights): \",np.sum(beam[\"w\"]))\nprint(f'Avgerage of X: {beam.avg(\"x\"):G~P}')\nprint(f'Standard Deviation of X: {beam.std(\"x\",desired_units=\"mm\"):G~P}')\n</pre> print(\"Beam species:\",beam.species) print(\"Weights:\",beam[\"w\"]) print(\"Normalization sum(weights): \",np.sum(beam[\"w\"])) print(f'Avgerage of X: {beam.avg(\"x\"):G~P}') print(f'Standard Deviation of X: {beam.std(\"x\",desired_units=\"mm\"):G~P}') <pre>Beam species: electron\nWeights: [5e-06 5e-06 5e-06 ... 5e-06 5e-06 5e-06] dimensionless\nNormalization sum(weights):  1.0 dimensionless\nAvgerage of X: -3.46945E-17 mm\nStandard Deviation of X: 2 mm\n</pre> In\u00a0[20]: Copied! <pre>gen.run()\npg = gen.particles\npg.plot('x', 'px')\n</pre> gen.run() pg = gen.particles pg.plot('x', 'px') In\u00a0[21]: Copied! <pre>gen = Generator('data/rad.gaussian.in.yaml', verbose=0) \ntry:\n    gen['r_dist:foo']='bar' \n    gen.beam()\nexcept Exception as ex:\n    print(ex)\n</pre> gen = Generator('data/rad.gaussian.in.yaml', verbose=0)  try:     gen['r_dist:foo']='bar'      gen.beam() except Exception as ex:     print(ex) <pre>Incorrect param given to NormRad.__init__(**kwargs): foo\nAllowed params: ['sigma_xy', 'truncation_fraction', 'truncation_radius_left', 'truncation_radius_right', 'n_sigma_cutoff_left', 'n_sigma_cutoff_left', 'n_sigma_cutoff', 'truncation_radius', 'truncation_radius_left', 'truncation_radius_right', 'verbose', 'type', 'indent']\n</pre> <p>As will missing required parameters:</p> In\u00a0[22]: Copied! <pre>gen = Generator('data/beer.can.in.yaml', verbose=0) \ntry:\n    gen['r_dist']={}\n    gen.beam()   \nexcept Exception as ex:\n    print(ex)\n</pre> gen = Generator('data/beer.can.in.yaml', verbose=0)  try:     gen['r_dist']={}     gen.beam()    except Exception as ex:     print(ex) <pre>No distribution type for r specified.\n</pre> In\u00a0[23]: Copied! <pre>from distgen.writers import writer\n\ngen = Generator('data/beer.can.in.yaml', verbose=0) \nbeam = gen.beam()\n\n# Typically the user can just call the general write function and specify the desired format:\nwriter(\"gpt\", beam, \"gpt.out.txt\", verbose=1)\nwriter(\"astra\", beam, \"astra.out.txt\", verbose=1)\nwriter(\"openPMD\", beam, \"openPMD.out.h5\", verbose=1)\n</pre> from distgen.writers import writer  gen = Generator('data/beer.can.in.yaml', verbose=0)  beam = gen.beam()  # Typically the user can just call the general write function and specify the desired format: writer(\"gpt\", beam, \"gpt.out.txt\", verbose=1) writer(\"astra\", beam, \"astra.out.txt\", verbose=1) writer(\"openPMD\", beam, \"openPMD.out.h5\", verbose=1) <pre>Printing 200000 particles to \"gpt.out.txt\": </pre> <pre>done. Time ellapsed: 1.22252 s.\nPrinting 200000 particles to \"astra.out.txt\": </pre> <pre>done. Time ellapsed: 1.39952 s.\nPrinting 200000 particles to \"openPMD.out.h5\": done. Time ellapsed: 17.8008 ms.\n</pre> In\u00a0[24]: Copied! <pre># The distgen module has some basic plotting routines\nfrom distgen.plot import *\n\nunits = {'x':'mm','y':'mm','z':'mm', 'r':'mm', \n         'px':'keV/c','py':'keV/c','pz':'keV/c',\n         't':'ps','q':'pC','thetax':'mrad','I':'A'}\n\ngen = Generator('data/beer.can.in.yaml', verbose=0) \nbeam = gen.beam()\n\nfig=plt.figure(1)\n# X-Y Plot\nplot_dist2d(beam, \n            'x', units['x'],\n            'y', units['y'],\n            style='scatter_hist2d',\n            nbins=100,\n            axis='equal',\n            title_on=True);\n</pre> # The distgen module has some basic plotting routines from distgen.plot import *  units = {'x':'mm','y':'mm','z':'mm', 'r':'mm',           'px':'keV/c','py':'keV/c','pz':'keV/c',          't':'ps','q':'pC','thetax':'mrad','I':'A'}  gen = Generator('data/beer.can.in.yaml', verbose=0)  beam = gen.beam()  fig=plt.figure(1) # X-Y Plot plot_dist2d(beam,              'x', units['x'],             'y', units['y'],             style='scatter_hist2d',             nbins=100,             axis='equal',             title_on=True); <p>For plotting the histogram of the radial coordinate $r$, use <code>plot_radial_dist</code>:</p> In\u00a0[25]: Copied! <pre>gen = Generator('data/beer.can.in.yaml', verbose=0) \nbeam = gen.beam()\n\nplot_radial_dist(beam, units['r'], scale='charge', nbins=100, title_on=True);\n</pre> gen = Generator('data/beer.can.in.yaml', verbose=0)  beam = gen.beam()  plot_radial_dist(beam, units['r'], scale='charge', nbins=100, title_on=True); <p>For plotting 1D projections of the beam distribution, use <code>plot_dist1d</code>:</p> In\u00a0[26]: Copied! <pre>gen = Generator('data/beer.can.in.yaml', verbose=0) \nbeam = gen.beam()\n\nplot_dist1d(beam, 'x', units['x'], scale='number', nbins=50, title_on=True)\n</pre> gen = Generator('data/beer.can.in.yaml', verbose=0)  beam = gen.beam()  plot_dist1d(beam, 'x', units['x'], scale='number', nbins=50, title_on=True) <p>For plotting the current profile, use <code>plot_current_profile</code>:</p> In\u00a0[27]: Copied! <pre>gen = Generator('data/beer.can.in.yaml', verbose=0) \nbeam = gen.beam()\n\nplot_current_profile(beam, units['t'], units['I'], title_on=True, nbins=100);\n</pre> gen = Generator('data/beer.can.in.yaml', verbose=0)  beam = gen.beam()  plot_current_profile(beam, units['t'], units['I'], title_on=True, nbins=100); In\u00a0[28]: Copied! <pre>from distgen.drivers import run_distgen\n\nwith open('data/rad.gaussian.in.yaml') as fid:\n    p = yaml.safe_load(fid)\n\np\n</pre> from distgen.drivers import run_distgen  with open('data/rad.gaussian.in.yaml') as fid:     p = yaml.safe_load(fid)  p Out[28]: <pre>{'n_particle': 200000,\n 'species': 'electron',\n 'output': {'file': 'rad.gaussian.out.txt', 'type': 'gpt'},\n 'r_dist': {'sigma_xy': '2 mm', 'type': 'radial_gaussian'},\n 'random': {'type': 'hammersley'},\n 'start': {'MTE': '150 meV', 'type': 'cathode'},\n 't_dist': {'max_t': '2 ps', 'min_t': '-2 ps', 'type': 'uniform'},\n 'total_charge': '10 pC'}</pre> In\u00a0[29]: Copied! <pre>beam = run_distgen(inputs=p, verbose=1)\n</pre> beam = run_distgen(inputs=p, verbose=1) <pre>Distribution format: gpt\nOutput file: /home/runner/work/distgen/distgen/docs/examples/rad.gaussian.out.txt\n\nCreating beam distribution....\n   Beam starting from: cathode\n   Total charge: 10 pC.\n   Number of macroparticles: 200000.\n   Assuming cylindrical symmetry...\n   r distribution: radial Gaussian\n   theta distribution: uniform theta\n      min_theta = 0 rad, max_theta = 6.28319 rad\n   t distribution: uniform\n      min_t = -2 ps, max_t = 2 ps, avg_t = 0 ps, sigma_t:  1.1547 ps\n   px distribution: Gaussian\n      avg_px = 0 eV/c, sigma_px = 276.857 eV/c\n   py distribution: Gaussian\n      avg_py = 0 eV/c, sigma_py = 276.857 eV/c\n   pz distribution: Gaussian\n      avg_pz = 0 eV/c, sigma_pz = 276.857 eV/c\n   Shifting avg_x = -7.82345E-05 mm -&gt; 0 mm\n   Scaling sigma_x = 1.99984 mm -&gt; 2 mm\n   Shifting avg_y = -1.09911E-05 mm -&gt; 0 mm\n   Scaling sigma_y = 1.99994 mm -&gt; 2 mm\n   Shifting avg_px = -0.0212516 eV/c -&gt; 0 eV/c\n   Scaling sigma_px = 276.849 eV/c -&gt; 276.857 eV/c\n   Shifting avg_py = -0.0259627 eV/c -&gt; 0 eV/c\n   Scaling sigma_py = 276.844 eV/c -&gt; 276.857 eV/c\n   Shifting avg_pz = -0.0372953 eV/c -&gt; 0 eV/c\n   Scaling sigma_pz = 276.843 eV/c -&gt; 276.857 eV/c\n   Shifting avg_t = -4.90022E-05 ps -&gt; 0 ps\n   Scaling sigma_t = 1.1547 ps -&gt; 1.1547 ps\n   Cathode start: fixing pz momenta to forward hemisphere\n      avg_pz -&gt; 220.904 eV/c, sigma_pz -&gt; 166.887 eV/c\n...done. Time Elapsed: 187.931 ms.\n\nPrinting 200000 particles to \"/home/runner/work/distgen/distgen/docs/examples/rad.gaussian.out.txt\": </pre> <pre>done. Time ellapsed: 1.22334 s.\n\nBeam stats:\n   avg_x = 0 mm, sigma_x = 2 mm\n   avg_y = 2.06253E-16 mm, sigma_y = 2 mm\n   avg_z = 0 mm, sigma_z = 0 mm\n   avg_px = -6.66134E-16 eV/c, sigma_px = 276.857 eV/c\n   avg_py = -6.55986E-15 eV/c, sigma_py = 276.857 eV/c\n   avg_pz = 220.904 eV/c, sigma_pz = 166.887 eV/c\n   avg_t = -2.04087E-17 ps, sigma_t = 1.1547 ps\n</pre> <p>Below the function is called with 'inputs' pointing to an input file.  The function can also take  accept a flattened settings dict, which updates inputs:</p> In\u00a0[30]: Copied! <pre>new_settings = {'start:MTE:value':0.1}\nbeam = run_distgen(settings=new_settings, inputs=p, verbose=1)\n</pre> new_settings = {'start:MTE:value':0.1} beam = run_distgen(settings=new_settings, inputs=p, verbose=1) <pre>Replacing parameter start:MTE:value with value 0.1.\nDistribution format: gpt\nOutput file: /home/runner/work/distgen/distgen/docs/examples/rad.gaussian.out.txt\n\nCreating beam distribution....\n   Beam starting from: cathode\n   Total charge: 10 pC.\n   Number of macroparticles: 200000.\n   Assuming cylindrical symmetry...\n   r distribution: radial Gaussian\n   theta distribution: uniform theta\n      min_theta = 0 rad, max_theta = 6.28319 rad\n   t distribution: uniform\n      min_t = -2 ps, max_t = 2 ps, avg_t = 0 ps, sigma_t:  1.1547 ps\n   px distribution: Gaussian\n      avg_px = 0 eV/c, sigma_px = 7.148 eV/c\n   py distribution: Gaussian\n      avg_py = 0 eV/c, sigma_py = 7.148 eV/c\n   pz distribution: Gaussian\n      avg_pz = 0 eV/c, sigma_pz = 7.148 eV/c\n   Shifting avg_x = -7.82345E-05 mm -&gt; 0 mm\n   Scaling sigma_x = 1.99984 mm -&gt; 2 mm\n   Shifting avg_y = -1.09911E-05 mm -&gt; 0 mm\n   Scaling sigma_y = 1.99994 mm -&gt; 2 mm\n   Shifting avg_px = -0.000548713 eV/c -&gt; 0 eV/c\n   Scaling sigma_px = 7.14822 eV/c -&gt; 7.14842 eV/c\n</pre> <pre>   Shifting avg_py = -0.000670353 eV/c -&gt; 0 eV/c\n   Scaling sigma_py = 7.14809 eV/c -&gt; 7.14842 eV/c\n   Shifting avg_pz = -0.000962959 eV/c -&gt; 0 eV/c\n   Scaling sigma_pz = 7.14807 eV/c -&gt; 7.14842 eV/c\n   Shifting avg_t = -4.90022E-05 ps -&gt; 0 ps\n   Scaling sigma_t = 1.1547 ps -&gt; 1.1547 ps\n   Cathode start: fixing pz momenta to forward hemisphere\n      avg_pz -&gt; 5.70372 eV/c, sigma_pz -&gt; 4.309 eV/c\n...done. Time Elapsed: 183.655 ms.\n\nPrinting 200000 particles to \"/home/runner/work/distgen/distgen/docs/examples/rad.gaussian.out.txt\": </pre> <pre>done. Time ellapsed: 1.25842 s.\n\nBeam stats:\n   avg_x = 0 mm, sigma_x = 2 mm\n   avg_y = 2.06253E-16 mm, sigma_y = 2 mm\n   avg_z = 0 mm, sigma_z = 0 mm\n   avg_px = -1.08149E-16 eV/c, sigma_px = 7.14842 eV/c\n   avg_py = -8.1261E-17 eV/c, sigma_py = 7.14842 eV/c\n   avg_pz = 5.70372 eV/c, sigma_pz = 4.309 eV/c\n   avg_t = -2.04087E-17 ps, sigma_t = 1.1547 ps\n</pre> <p>Finally, is also possible to run distgen as an executible script using <code>/bin/DistGen.py</code></p> In\u00a0[31]: Copied! <pre>import subprocess\noutput=subprocess.check_output(['Distgen','-f','data/rad.gaussian.in.yaml','-v','2'])\noutput=str(output.decode('utf-8')).split(\"\\n\")\nfor line in output:\n    print(line)\n</pre> import subprocess output=subprocess.check_output(['Distgen','-f','data/rad.gaussian.in.yaml','-v','2']) output=str(output.decode('utf-8')).split(\"\\n\") for line in output:     print(line) <pre>Distribution format: gpt\nOutput file: rad.gaussian.out.txt\n\nCreating beam distribution....\n   Beam starting from: cathode\n   Total charge: 10 pC.\n   Number of macroparticles: 200000.\n   Assuming cylindrical symmetry...\n   r distribution: radial Gaussian\n   theta distribution: uniform theta\n      min_theta = 0 rad, max_theta = 6.28319 rad\n   t distribution: uniform\n      min_t = -2 ps, max_t = 2 ps, avg_t = 0 ps, sigma_t:  1.1547 ps\n   px distribution: Gaussian\n      avg_px = 0 eV/c, sigma_px = 276.857 eV/c\n   py distribution: Gaussian\n      avg_py = 0 eV/c, sigma_py = 276.857 eV/c\n   pz distribution: Gaussian\n      avg_pz = 0 eV/c, sigma_pz = 276.857 eV/c\n   Shifting avg_x = -7.82345E-05 mm -&gt; 0 mm\n   Scaling sigma_x = 1.99984 mm -&gt; 2 mm\n   Shifting avg_y = -1.09911E-05 mm -&gt; 0 mm\n   Scaling sigma_y = 1.99994 mm -&gt; 2 mm\n   Shifting avg_px = -0.0212516 eV/c -&gt; 0 eV/c\n   Scaling sigma_px = 276.849 eV/c -&gt; 276.857 eV/c\n   Shifting avg_py = -0.0259627 eV/c -&gt; 0 eV/c\n   Scaling sigma_py = 276.844 eV/c -&gt; 276.857 eV/c\n   Shifting avg_pz = -0.0372953 eV/c -&gt; 0 eV/c\n   Scaling sigma_pz = 276.843 eV/c -&gt; 276.857 eV/c\n   Shifting avg_t = -4.90022E-05 ps -&gt; 0 ps\n   Scaling sigma_t = 1.1547 ps -&gt; 1.1547 ps\n   Cathode start: fixing pz momenta to forward hemisphere\n      avg_pz -&gt; 220.904 eV/c, sigma_pz -&gt; 166.887 eV/c\n...done. Time Elapsed: 274.554 ms.\n\nPrinting 200000 particles to \"rad.gaussian.out.txt\": done. Time ellapsed: 1.23575 s.\n\nBeam stats:\n   avg_x = 0 mm, sigma_x = 2 mm\n   avg_y = 2.06253E-16 mm, sigma_y = 2 mm\n   avg_z = 0 mm, sigma_z = 0 mm\n   avg_px = -6.66134E-16 eV/c, sigma_px = 276.857 eV/c\n   avg_py = -6.55986E-15 eV/c, sigma_py = 276.857 eV/c\n   avg_pz = 220.904 eV/c, sigma_pz = 166.887 eV/c\n   avg_t = -2.04087E-17 ps, sigma_t = 1.1547 ps\n\n</pre> <p>Currently Distgen supports several cathode emission models.  Currently these all assume the particles are emitted on a flat surface at z = 0 m. The particle time coordinates in this case effectively respresents the emission time of the particle from the cathode, and thus the time distribution should be set by the user.  For photocathodes, the time coordinate can be related to the laser pulse longitudinal intensity. To designate emission from a cathode, please set the input key <code>start:type</code> = <code>cathode</code></p> <p>WARNING: the user is ultimately responsible to make sure the cathode model is physically consistent with the particle species generated.</p> In\u00a0[32]: Copied! <pre>from distgen import Generator\ngen = Generator(input_file=\"data/rad.gaussian.in.yaml\", verbose=1)\n</pre> from distgen import Generator gen = Generator(input_file=\"data/rad.gaussian.in.yaml\", verbose=1) In\u00a0[33]: Copied! <pre>beam = gen.beam()\n</pre> beam = gen.beam() <pre>Distribution format: gpt\nOutput file: rad.gaussian.out.txt\n\nCreating beam distribution....\n   Beam starting from: cathode\n   Total charge: 10 pC.\n   Number of macroparticles: 200000.\n   Assuming cylindrical symmetry...\n   r distribution: radial Gaussian\n   theta distribution: uniform theta\n      min_theta = 0 rad, max_theta = 6.28319 rad\n   t distribution: uniform\n      min_t = -2 ps, max_t = 2 ps, avg_t = 0 ps, sigma_t:  1.1547 ps\n   px distribution: Gaussian\n      avg_px = 0 eV/c, sigma_px = 276.857 eV/c\n   py distribution: Gaussian\n      avg_py = 0 eV/c, sigma_py = 276.857 eV/c\n   pz distribution: Gaussian\n      avg_pz = 0 eV/c, sigma_pz = 276.857 eV/c\n</pre> <pre>   Shifting avg_x = -7.82345E-05 mm -&gt; 0 mm\n   Scaling sigma_x = 1.99984 mm -&gt; 2 mm\n   Shifting avg_y = -1.09911E-05 mm -&gt; 0 mm\n   Scaling sigma_y = 1.99994 mm -&gt; 2 mm\n   Shifting avg_px = -0.0212516 eV/c -&gt; 0 eV/c\n   Scaling sigma_px = 276.849 eV/c -&gt; 276.857 eV/c\n   Shifting avg_py = -0.0259627 eV/c -&gt; 0 eV/c\n   Scaling sigma_py = 276.844 eV/c -&gt; 276.857 eV/c\n   Shifting avg_pz = -0.0372953 eV/c -&gt; 0 eV/c\n   Scaling sigma_pz = 276.843 eV/c -&gt; 276.857 eV/c\n   Shifting avg_t = -4.90022E-05 ps -&gt; 0 ps\n   Scaling sigma_t = 1.1547 ps -&gt; 1.1547 ps\n   Cathode start: fixing pz momenta to forward hemisphere\n      avg_pz -&gt; 220.904 eV/c, sigma_pz -&gt; 166.887 eV/c\n...done. Time Elapsed: 187.515 ms.\n\n</pre> In\u00a0[34]: Copied! <pre>fig, ax = plt.subplots(1, 2, sharex='col',constrained_layout=True)\n\nplot_dist2d(beam, 'x', units['x'], 'px', units['px'], ax=ax[0]);\nax[0].set_title('x-Px Phase Space')\n\nplot_dist2d(beam, 't', units['t'], 'pz', units['pz'], ax=ax[1]);\nax[1].set_title('t-Pz Phase Space');\n</pre> fig, ax = plt.subplots(1, 2, sharex='col',constrained_layout=True)  plot_dist2d(beam, 'x', units['x'], 'px', units['px'], ax=ax[0]); ax[0].set_title('x-Px Phase Space')  plot_dist2d(beam, 't', units['t'], 'pz', units['pz'], ax=ax[1]); ax[1].set_title('t-Pz Phase Space'); In\u00a0[35]: Copied! <pre>gen = Generator('data/fermi_dirac_3step_barrier_photocathode.in.yaml', verbose=1)\n\nbeam = gen.beam()\n</pre> gen = Generator('data/fermi_dirac_3step_barrier_photocathode.in.yaml', verbose=1)  beam = gen.beam() <pre>Distribution format: None\n   Warning: no output file specified, defaulting to \"None\".\nOutput file: None\n\nCreating beam distribution....\n   Beam starting from: cathode\n   Total charge: 10 pC.\n   Number of macroparticles: 200000.\n   Assuming cylindrical symmetry...\n   Assuming cylindrical momentum symmetry...\n   r distribution: radial Gaussian\n   theta distribution: uniform theta\n      min_theta = 0 rad, max_theta = 6.28319 rad\n   |p| and polar angle distribution: Fermi-Dirac 3 Step Barrier Photocathode Model\n      laser wavelength = 495.937 nm, photon energy = 2.5 eV\n      cathode temperature = 300 K, cathode work function = 2 eV, Fermi energy = 6 eV\n</pre> <pre>   azimuthal angle distribution: uniform theta\n      min_theta = 0 rad, max_theta = 6.28319 rad\n   t distribution: uniform\n      min_t = -17.3205 ps, max_t = 17.3205 ps, avg_t = 0 ps, sigma_t:  10 ps\n   Shifting avg_x = -1.75251E-06 mm -&gt; 0 mm\n   Scaling sigma_x = 0.999928 mm -&gt; 1 mm\n   Shifting avg_y = 2.14895E-05 mm -&gt; 0 mm\n   Scaling sigma_y = 0.999965 mm -&gt; 1 mm\n   Shifting avg_px = 0.00586744 eV/c -&gt; 0 eV/c\n   Shifting avg_py = -0.00957189 eV/c -&gt; 0 eV/c\n   Shifting avg_t = -0.000333868 ps -&gt; 0 ps\n   Scaling sigma_t = 9.99998 ps -&gt; 10 ps\n...done. Time Elapsed: 760.139 ms.\n\n</pre> In\u00a0[36]: Copied! <pre>fig, ax = plt.subplots(1, 2, sharex='col',constrained_layout=True, figsize=(8,5))\n\nplot_dist2d(beam, 'px', units['px'], 'pz', units['pz'], ax=ax[0]);\nax[0].set_title('px-pz')\n\nplot_dist2d(beam, 't', units['t'], 'x', units['x'], ax=ax[1]);\nax[1].set_title('t-x');\n</pre> fig, ax = plt.subplots(1, 2, sharex='col',constrained_layout=True, figsize=(8,5))  plot_dist2d(beam, 'px', units['px'], 'pz', units['pz'], ax=ax[0]); ax[0].set_title('px-pz')  plot_dist2d(beam, 't', units['t'], 'x', units['x'], ax=ax[1]); ax[1].set_title('t-x'); In\u00a0[37]: Copied! <pre>from distgen.physical_constants import PHYSICAL_CONSTANTS\n\nc = PHYSICAL_CONSTANTS['speed of light in vacuum']\nMC2 = PHYSICAL_CONSTANTS.species('electron')['mc2']\n\nMTE = (c*beam['px'].std())**2 / MC2\n\nprint('estimated MTE:', MTE.to('meV'))\n</pre> from distgen.physical_constants import PHYSICAL_CONSTANTS  c = PHYSICAL_CONSTANTS['speed of light in vacuum'] MC2 = PHYSICAL_CONSTANTS.species('electron')['mc2']  MTE = (c*beam['px'].std())**2 / MC2  print('estimated MTE:', MTE.to('meV')) <pre>estimated MTE: 169.86710712122817 millielectron_volt\n</pre> In\u00a0[38]: Copied! <pre>KE = np.linspace(0, 300, 10000)\n\nE0=0\nA1, m1 = 0.8, 8\nA2, m2 = 0.1, 90\n\nPKE = A1*np.exp(-np.abs(KE-E0)/m1) + A2*np.exp(-np.abs(KE-E0)/m2) \nPKE = PKE/np.trapezoid(PKE, KE)  # Numerically intergate to normalize\n\nplt.plot(KE, PKE);\nplt.xlabel('KE (eV)');\nplt.ylabel('$\\\\rho(KE)$ (1/eV)');\n</pre> KE = np.linspace(0, 300, 10000)  E0=0 A1, m1 = 0.8, 8 A2, m2 = 0.1, 90  PKE = A1*np.exp(-np.abs(KE-E0)/m1) + A2*np.exp(-np.abs(KE-E0)/m2)  PKE = PKE/np.trapezoid(PKE, KE)  # Numerically intergate to normalize  plt.plot(KE, PKE); plt.xlabel('KE (eV)'); plt.ylabel('$\\\\rho(KE)$ (1/eV)'); In\u00a0[39]: Copied! <pre>input_yaml = \"\"\"\nn_particle: 100000\nspecies: electron\nstart: \n  type: cathode\nrandom:\n  type: hammersley\ntotal_charge:\n  units: C\n  value: 1.60217663e-17\n\"\"\"\n\ninput = yaml.safe_load(input_yaml)\ninput['KE_dist'] = {'type': 'dist1d', 'KE':KE, 'PKE':PKE, 'units':'eV'}\n\ngen = Generator(input)\nP = gen.run()\n</pre> input_yaml = \"\"\" n_particle: 100000 species: electron start:    type: cathode random:   type: hammersley total_charge:   units: C   value: 1.60217663e-17 \"\"\"  input = yaml.safe_load(input_yaml) input['KE_dist'] = {'type': 'dist1d', 'KE':KE, 'PKE':PKE, 'units':'eV'}  gen = Generator(input) P = gen.run() In\u00a0[40]: Copied! <pre>P.plot('kinetic_energy')\n</pre> P.plot('kinetic_energy') In\u00a0[41]: Copied! <pre>fig = plt.figure()\nax = fig.add_subplot(projection='3d')\n\nx = P['px']/P.p\ny = P['py']/P.p\nz = P['pz']/P.p\n\nax.scatter(x[::100], y[::100], z[::100], '.');\nax.set_xlabel(r'$\\hat{p}_x$')\nax.set_ylabel(r'$\\hat{p}_y$')\nax.set_zlabel(r'$\\hat{p}_z$')\n</pre> fig = plt.figure() ax = fig.add_subplot(projection='3d')  x = P['px']/P.p y = P['py']/P.p z = P['pz']/P.p  ax.scatter(x[::100], y[::100], z[::100], '.'); ax.set_xlabel(r'$\\hat{p}_x$') ax.set_ylabel(r'$\\hat{p}_y$') ax.set_zlabel(r'$\\hat{p}_z$') Out[41]: <pre>Text(0.5, 0, '$\\\\hat{p}_z$')</pre> <p>Distgen also allows the user to start a beam at an arbitrary time.  In this case, distgen will ignore any user distribution settings for the time coordinate of the beam particles.  The beam has some initial Gaussian momentum.  To make this more interesting, the beam is boosted to 1 GeV, the Twiss Parameters set, and a cosine like energy spread applied:</p> In\u00a0[42]: Copied! <pre>from distgen.physical_constants import unit_registry, PHYSICAL_CONSTANTS\n\npi, c = PHYSICAL_CONSTANTS.pi, PHYSICAL_CONSTANTS['speed of light in vacuum']\n\ngen = Generator(\"data/gaussian.in.yaml\", verbose=0) \n\nf = 1.3*unit_registry('GHz')\nw = 2*pi*f/c\n\nlinac_params = {\n    'type':'cosine z:pz',\n    'amplitude':{'value':1,'units':'GeV/c'},\n    'omega':{'value':w.magnitude, 'units':str(w.units)},\n    'phase':{'value':-1, 'units':'deg'}\n}\n\nxbeta_params = {\n    'type':'set_twiss x',\n    'beta': {'value':12.5, 'units':'m'},\n    'alpha':{'value':-1, 'units':''},\n    'emittance':  {'value':2,'units':'nm'},\n}\nybeta_params = {\n    'type':'set_twiss y',\n    'beta': {'value':12.5, 'units':'m'},\n    'alpha':{'value':-1, 'units':''},\n    'emittance':  {'value':2,'units':'nm'},\n}\n\ngen['transforms']={'t1':linac_params, 't2':xbeta_params, 't3':ybeta_params, 'order':['t1','t2','t3']}\n  \nbeam = gen.beam()\n\nprint('YAML transforms input\\n', yaml.dump(gen.input['transforms']))\n\nprint('\\nFinal Horizontal Twiss params:')\nprint(f'beta: {beam.Beta(\"x\"):G~P}, alpha: {beam.Alpha(\"x\"):G~P}, eps: {beam.emitt(\"x\",\"geometric\").to(\"nm\"):G~P}')\n#print(f'beta: {beam.Beta(\"x\"):G~P}, alpha: {beam.Alpha(\"x\"):G~P}, eps: {beam.emitt(\"x\",\"geometric\").to(\"nm\"):Gf~P}')\n\nprint('\\nFinal Vertical Twiss params:')\nprint(f'beta: {beam.Beta(\"y\"):G~P}, alpha: {beam.Alpha(\"y\"):G~P}, eps: {beam.emitt(\"y\",\"geometric\").to(\"nm\"):G~P}')\n</pre> from distgen.physical_constants import unit_registry, PHYSICAL_CONSTANTS  pi, c = PHYSICAL_CONSTANTS.pi, PHYSICAL_CONSTANTS['speed of light in vacuum']  gen = Generator(\"data/gaussian.in.yaml\", verbose=0)   f = 1.3*unit_registry('GHz') w = 2*pi*f/c  linac_params = {     'type':'cosine z:pz',     'amplitude':{'value':1,'units':'GeV/c'},     'omega':{'value':w.magnitude, 'units':str(w.units)},     'phase':{'value':-1, 'units':'deg'} }  xbeta_params = {     'type':'set_twiss x',     'beta': {'value':12.5, 'units':'m'},     'alpha':{'value':-1, 'units':''},     'emittance':  {'value':2,'units':'nm'}, } ybeta_params = {     'type':'set_twiss y',     'beta': {'value':12.5, 'units':'m'},     'alpha':{'value':-1, 'units':''},     'emittance':  {'value':2,'units':'nm'}, }  gen['transforms']={'t1':linac_params, 't2':xbeta_params, 't3':ybeta_params, 'order':['t1','t2','t3']}    beam = gen.beam()  print('YAML transforms input\\n', yaml.dump(gen.input['transforms']))  print('\\nFinal Horizontal Twiss params:') print(f'beta: {beam.Beta(\"x\"):G~P}, alpha: {beam.Alpha(\"x\"):G~P}, eps: {beam.emitt(\"x\",\"geometric\").to(\"nm\"):G~P}') #print(f'beta: {beam.Beta(\"x\"):G~P}, alpha: {beam.Alpha(\"x\"):G~P}, eps: {beam.emitt(\"x\",\"geometric\").to(\"nm\"):Gf~P}')  print('\\nFinal Vertical Twiss params:') print(f'beta: {beam.Beta(\"y\"):G~P}, alpha: {beam.Alpha(\"y\"):G~P}, eps: {beam.emitt(\"y\",\"geometric\").to(\"nm\"):G~P}') <pre>YAML transforms input\n order:\n- t1\n- t2\n- t3\nt1:\n  amplitude:\n    units: gigaelectron_volt / speed_of_light\n    value: 1.0\n  omega:\n    units: gigahertz * radian * second / meter\n    value: 2.724598528537186e-08\n  phase:\n    units: degree\n    value: -1.0\n  type: cosine z:pz\nt2:\n  alpha:\n    units: dimensionless\n    value: -1.0\n  beta:\n    units: meter\n    value: 12.5\n  emittance:\n    units: nanometer\n    value: 2.0\n  type: set_twiss x\nt3:\n  alpha:\n    units: dimensionless\n    value: -1.0\n  beta:\n    units: meter\n    value: 12.5\n  emittance:\n    units: nanometer\n    value: 2.0\n  type: set_twiss y\n\n\nFinal Horizontal Twiss params:\nbeta: 12500 mm, alpha: -1, eps: 2 nm\n\nFinal Vertical Twiss params:\nbeta: 12500 mm, alpha: -1, eps: 2 nm\n</pre> In\u00a0[43]: Copied! <pre>fig, ax = plt.subplots(1, 3, constrained_layout=True)\nplot_dist2d(beam, 'x', units['x'], 'y', units['y'], axis='equal', ax=ax[0]);\nplot_dist2d(beam, 'x', units['x'], 'thetax', units['thetax'], ax=ax[1]);\nplot_dist2d(beam, 'z', units['z'],  'pz','GeV/c', ax=ax[2]);\n</pre> fig, ax = plt.subplots(1, 3, constrained_layout=True) plot_dist2d(beam, 'x', units['x'], 'y', units['y'], axis='equal', ax=ax[0]); plot_dist2d(beam, 'x', units['x'], 'thetax', units['thetax'], ax=ax[1]); plot_dist2d(beam, 'z', units['z'],  'pz','GeV/c', ax=ax[2]); In\u00a0[44]: Copied! <pre>filename = \"data/gaussian.in.yaml\"\ngen = Generator(filename, verbose=0) \n\ngen['pz_dist:avg_pz'] = 1  # Set beam 1 at pz = 1 GeV\ngen['z_dist:avg_z'] = -10  # Set beam 1 at z = -10 mmm\n\nxbeta_params = {\n    'type':'set_twiss x',\n    'beta': {'value':12.5, 'units':'m'},\n    'alpha':{'value':-1, 'units':''},\n    'emittance':  {'value':2,'units':'nm'},\n}\n\nybeta_params = {\n    'type':'set_twiss y',\n    'beta': {'value':12.5, 'units':'m'},\n    'alpha':{'value':-1, 'units':''},\n    'emittance':  {'value':2,'units':'nm'},\n}\n\ngen['transforms']={'t1':xbeta_params, 't2':ybeta_params, 'order':['t1','t2']}\n\npg1 = gen.run()\n</pre> filename = \"data/gaussian.in.yaml\" gen = Generator(filename, verbose=0)   gen['pz_dist:avg_pz'] = 1  # Set beam 1 at pz = 1 GeV gen['z_dist:avg_z'] = -10  # Set beam 1 at z = -10 mmm  xbeta_params = {     'type':'set_twiss x',     'beta': {'value':12.5, 'units':'m'},     'alpha':{'value':-1, 'units':''},     'emittance':  {'value':2,'units':'nm'}, }  ybeta_params = {     'type':'set_twiss y',     'beta': {'value':12.5, 'units':'m'},     'alpha':{'value':-1, 'units':''},     'emittance':  {'value':2,'units':'nm'}, }  gen['transforms']={'t1':xbeta_params, 't2':ybeta_params, 'order':['t1','t2']}  pg1 = gen.run() In\u00a0[45]: Copied! <pre>pg1.plot('x', 'px')\n</pre> pg1.plot('x', 'px') In\u00a0[46]: Copied! <pre>pg1.plot('z')\n</pre> pg1.plot('z') <p>Next, make second beam.  Here shift the z position of the beam and change the $\\alpha$ Twiss parameter's sign to create a different momenta distribution:</p> In\u00a0[47]: Copied! <pre>gen['z_dist:avg_z'] = 10   # Set beam 1 at z = +10 mmm\n\nxbeta_params['alpha']['value'], ybeta_params['alpha']['value'] = +1, +1\n\ngen['transforms']={'t1':xbeta_params, 't2':ybeta_params, 'order':['t1','t2']}\n\npg2 = gen.run()\n</pre> gen['z_dist:avg_z'] = 10   # Set beam 1 at z = +10 mmm  xbeta_params['alpha']['value'], ybeta_params['alpha']['value'] = +1, +1  gen['transforms']={'t1':xbeta_params, 't2':ybeta_params, 'order':['t1','t2']}  pg2 = gen.run()  <p>The particle group objects support addition:</p> In\u00a0[48]: Copied! <pre>pg = pg1 + pg2\n</pre> pg = pg1 + pg2 In\u00a0[49]: Copied! <pre>pg.plot('x','px')\n</pre> pg.plot('x','px') In\u00a0[50]: Copied! <pre>pg.plot('z')\n</pre> pg.plot('z') <p>It is also possible to superimpose built in distgen particle distributions.  Please see the <code>examples_dists.ipynb</code> for details on how to use this functionality.</p> In\u00a0[51]: Copied! <pre>gen = Generator(\"data/gaussian.in.yaml\", verbose=0) \ngen.run()\n</pre> gen = Generator(\"data/gaussian.in.yaml\", verbose=0)  gen.run() Out[51]: <pre>&lt;ParticleGroup with 200000 particles at 0x7f2b6b6a1400&gt;</pre> <p>If no filename is given, a unique one will be written based on <code>.input</code></p> In\u00a0[52]: Copied! <pre>afile = gen.archive()\nafile\n</pre> afile = gen.archive() afile Out[52]: <pre>'distgen_b708aa4e92fde2d2b636f06d26cf4771.h5'</pre> <p>Loading into a new object</p> In\u00a0[53]: Copied! <pre>G2 = Generator(verbose=True)\nG2.load_archive(afile)\n</pre> G2 = Generator(verbose=True) G2.load_archive(afile) <pre>   Reading group ./ from archive file distgen_b708aa4e92fde2d2b636f06d26cf4771.h5</pre> <p>open h5 handles can also be written to, using the same routine.</p> In\u00a0[54]: Copied! <pre>import h5py\n\nwith h5py.File('archive.h5', 'w') as h5:\n    G2.archive(h5)\n</pre> import h5py  with h5py.File('archive.h5', 'w') as h5:     G2.archive(h5) In\u00a0[55]: Copied! <pre>os.remove('rad.gaussian.out.txt')\nos.remove('gpt.out.txt')\nos.remove('astra.out.txt')\nos.remove('openPMD.out.h5')\n#os.remove('beer.can.out.txt')\nos.remove(afile)\nos.remove('archive.h5')\n</pre> os.remove('rad.gaussian.out.txt') os.remove('gpt.out.txt') os.remove('astra.out.txt') os.remove('openPMD.out.h5') #os.remove('beer.can.out.txt') os.remove(afile) os.remove('archive.h5') In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/basic/#distgen-basic-usage","title":"Distgen basic usage\u00b6","text":""},{"location":"examples/basic/#generator","title":"Generator\u00b6","text":""},{"location":"examples/basic/#physical-constants","title":"Physical Constants\u00b6","text":"<p>All physical constants used by Distgen are accessed via the main PHYSICAL_CONSTANTS object.  Access to specific constants is done via [...], and returns the associated quantity (value with units) from the SciPy physical_constants module.</p>"},{"location":"examples/basic/#particle-species","title":"Particle Species\u00b6","text":"<p>As of v2.0.0, additional particle species can be generated.  The supported list is:</p>"},{"location":"examples/basic/#beam-object","title":"Beam Object\u00b6","text":""},{"location":"examples/basic/#generating-openpmd-beamphysics-particle-group-objects","title":"Generating OpenPMD-beamphysics Particle Group objects\u00b6","text":"<p>Distgen supports direct creation of OpenPMD beam physics particle group objects, a very useful object for handling beam distribitions and writing them to various codes.  Please see https://github.com/ChristopherMayes/openPMD-beamphysics for details.  To generate a OpenPMD-beamphysics particle group, use the <code>run()</code> command. The resulting ParticleGroup is saved as <code>Generator.particles</code>:</p>"},{"location":"examples/basic/#distribution-objects","title":"Distribution Objects\u00b6","text":"<p>Distgen handles distirbutions using classes controlled by Generator.  Currently there are three types supported: 1D distributions (Dist1d), radial distributions for the $r$ coordinate, and 2D distributions.  Each distribution type keeps an internal list of the required and optional parameters that must be passed to the object.  When a distribution object is initialized, the input parameters are checked against this list. Unexpected inputs will throw exceptions:</p>"},{"location":"examples/basic/#output-writer-functionality","title":"Output writer functionality\u00b6","text":"<p>Distgen supports writer functions for various output formats/codes.  Currently these include GPT and ASTRA, and the openPMD specification.  To write to a file, use distgen.writers.writer with appropriate code type specified as well as the beam object and desired output file.  The writer function accepts additional parameters required for any code dependent output.</p>"},{"location":"examples/basic/#plotting","title":"Plotting\u00b6","text":"<p>Distgen provides the user with some basic plotting routines for help in visualizing the beam coordinates.  The most common plot types include <code>plot_dist2d</code>, <code>plot_dist1d</code>, <code>plot_radial_dist</code>, and <code>plot_current_profile</code>.  Below shows an example of how to plot 2 coordinates, in this case $x$ and $y$.  The coloring scheme is a scatter histogram.</p>"},{"location":"examples/basic/#running-distgen-with-driver-functions","title":"Running Distgen with driver functions\u00b6","text":"<p>The main in python driver function for distgen is <code>distgen.drivers.run_distgen()</code>.  The function creates its own Generator object and returns a beam object.  Inputs can either be an inputfile or a parsed distgen supported input dictionary.  Here the function is run with an input dictionary created above.</p>"},{"location":"examples/basic/#scalingrotatingshifting-coordinates","title":"Scaling/Rotating/Shifting Coordinates\u00b6","text":"<p>The distgen module allows the user with several options for applying coordinate transformations.  Some of the basic operations include: shifting, scaling, and rotating coordinates.  See the transform.ipynb for a detailed description of this functionality.</p>"},{"location":"examples/basic/#cathode-distributions","title":"Cathode Distributions\u00b6","text":""},{"location":"examples/basic/#1-maxwell-boltzmann-default-thermalized-particle-momenta","title":"1. Maxwell-Boltzmann (default): thermalized particle momenta\u00b6","text":"<p>Particles emitted from this type of cathode are assumed to have a Maxwell-Boltzmann distribution for their total mometnum $|p|$ parameterized by an energy scale denoted $MTE$:</p> <p>$\\rho_p(|p|) = \\left(\\frac{1}{2\\pi mMTE}\\right)^{3/2} 4\\pi |p|^2 \\exp\\left(-\\frac{|p|^2}{2m MTE}\\right)$, with $\\int\\rho_p(|p|)d|p| = 1$.</p> <p>Assuming spherical symmetry, it is easy to show the corresponding PDF for the components of the momenta is given by:</p> <p>$\\rho(p_x,p_y,p_z) = \\left(\\frac{1}{2\\pi mMTE}\\right)^{3/2}\\exp\\left(-\\frac{p_x^2+p_y^2+p_z^2}{2m MTE}\\right)$, with $\\int\\rho(p_x,p_y,p_z) d^3p=1$.</p> <p>From the equipartition theorem the average energy $\\frac{3}{2}MTE$ is divided equally among each direction and thus the energy scale $MTE$ can be identified as the Mean Transverse Energy: $MTE=\\frac{\\langle p_x^2\\rangle}{2m} + \\frac{\\langle p_y^2\\rangle}{2m}$.</p> <p>This expression can be used to relate the MTE to the initial cathode emittance:</p> <p>$\\epsilon_{n,x} = \\sigma_{x}\\sqrt{ \\frac{MTE}{mc^2} }$</p> <p>assuming there is no distinction between the $p_x$ and $p_y$ distributions inherent to the emission process.  To account for the fact that particles with $p_z&lt;0$ are not emitted from the cathode, distgen takes $p_z = |p_z|$. Becauset this model serves as the default, simpy setting the input key <code>start:MTE</code> to a value (with units) will instruct the Generator to assume thermalized momenta. Note the absolute value of the $p_z$ components is taken.</p>"},{"location":"examples/basic/#fermi-dirac-3-step-barrier-photocathode","title":"Fermi-Dirac 3 Step Barrier Photocathode\u00b6","text":"<p>Calculates the PDF for electrons emitted from a photocathode following the model described in [1].</p> <p>The input parameters for this are the photon (laser) wavelength, as well as the cathode temperature, work function, and Fermi energy.</p> <p>Shortly, electrons are initially populated in momentum space as in the Sommerfeld model. They escape over the work function barrier when their longitudinal energy is high enough and lose momentum along the direction of the surface normal to satisfy energy conservation. This sampling concept is the same described in [2].</p> <pre><code>[1] Dowell, D. H., &amp; Schmerge, J. F. (2009). Quantum efficiency and thermal emittance of \n    metal photocathodes. Physical Review Special Topics - Accelerators and Beams, 12(7). \n    https://doi.org/10.1103/PhysRevSTAB.12.074201\n\n[2] Pierce, C. M., Durham, D. B., Riminucci, F., Dhuey, S., Bazarov, I., Maxson, J.,\n    Minor, A. M., &amp; Filippetto, D. (2023). Experimental Characterization of Photoemission\n    from Plasmonic Nanogroove Arrays. Physical Review Applied, 19(3), 034034.\n    https://doi.org/10.1103/PhysRevApplied.19.034034</code></pre>"},{"location":"examples/basic/#3-general-surface-emission-defined-by-p-or-ke-and-theta_p-phi_p-distributions","title":"3. General Surface Emission defined by |P| or KE and $\\theta_p$, $\\phi_p$ distribution(s)\u00b6","text":"<p>In addition to the two cathode emission models described above, the user may also specify a distribution for $|p|$ or the kinetic energy, as well as the momenta angle coordinates (azimuthal and polar momentum angles).  If no angular distribution parameters are set, then particles are emitted uniformly into the forward hemisphere.  In the example below, an initial KE distribution is created using a bi-exponential.</p>"},{"location":"examples/basic/#time-start","title":"Time Start\u00b6","text":""},{"location":"examples/basic/#combining-beams","title":"Combining Beams\u00b6","text":"<p>Currently distgen supports combining beams in to ways.  The first makes use of the OpenPMD-beamphysics Particle Group's addition property.  This is achieved by making two separate beams:</p>"},{"location":"examples/basic/#archiving","title":"Archiving\u00b6","text":"<p>All input and output can be saved and loaded to an hdf5 file using <code>.archive()</code> and <code>.load_archive</code> functions.</p> <p>Input is archived as a flattended dict, with keys separated by <code>:</code></p> <p>Particlces are archived as openPMD-beamphysics, but only if they are created with the <code>run()</code> command.</p>"},{"location":"examples/basic/#clean-up","title":"Clean up\u00b6","text":""},{"location":"examples/conversion_examples/","title":"Examples on converting to other formats","text":"In\u00a0[1]: Copied! <pre># Useful for debugging\n%load_ext autoreload\n%autoreload 2\n</pre> # Useful for debugging %load_ext autoreload %autoreload 2 In\u00a0[2]: Copied! <pre>from distgen.drivers import run_distgen\n\nimport os\n</pre> from distgen.drivers import run_distgen  import os In\u00a0[3]: Copied! <pre>beam = run_distgen(inputs='data/rad.gaussian.in.yaml', verbose=1)\n</pre> beam = run_distgen(inputs='data/rad.gaussian.in.yaml', verbose=1) <pre>Distribution format: gpt\nOutput file: rad.gaussian.out.txt\n\nCreating beam distribution....\n   Beam starting from: cathode\n   Total charge: 10 pC.\n   Number of macroparticles: 200000.\n   Assuming cylindrical symmetry...\n   r distribution: radial Gaussian\n   theta distribution: uniform theta\n      min_theta = 0 rad, max_theta = 6.28319 rad\n   t distribution: uniform\n      min_t = -2 ps, max_t = 2 ps, avg_t = 0 ps, sigma_t:  1.1547 ps\n   px distribution: Gaussian\n      avg_px = 0 eV/c, sigma_px = 276.857 eV/c\n   py distribution: Gaussian\n      avg_py = 0 eV/c, sigma_py = 276.857 eV/c\n   pz distribution: Gaussian\n      avg_pz = 0 eV/c, sigma_pz = 276.857 eV/c\n   Shifting avg_x = -7.82345E-05 mm -&gt; 0 mm\n   Scaling sigma_x = 1.99984 mm -&gt; 2 mm\n   Shifting avg_y = -1.09911E-05 mm -&gt; 0 mm\n   Scaling sigma_y = 1.99994 mm -&gt; 2 mm\n</pre> <pre>   Shifting avg_px = -0.0212516 eV/c -&gt; 0 eV/c\n   Scaling sigma_px = 276.849 eV/c -&gt; 276.857 eV/c\n   Shifting avg_py = -0.0259627 eV/c -&gt; 0 eV/c\n   Scaling sigma_py = 276.844 eV/c -&gt; 276.857 eV/c\n   Shifting avg_pz = -0.0372953 eV/c -&gt; 0 eV/c\n   Scaling sigma_pz = 276.843 eV/c -&gt; 276.857 eV/c\n   Shifting avg_t = -4.90022E-05 ps -&gt; 0 ps\n   Scaling sigma_t = 1.1547 ps -&gt; 1.1547 ps\n   Cathode start: fixing pz momenta to forward hemisphere\n      avg_pz -&gt; 220.904 eV/c, sigma_pz -&gt; 166.887 eV/c\n...done. Time Elapsed: 216.455 ms.\n\nPrinting 200000 particles to \"rad.gaussian.out.txt\": </pre> <pre>done. Time ellapsed: 1.22709 s.\n\nBeam stats:\n   avg_x = 0 mm, sigma_x = 2 mm\n   avg_y = 2.06253E-16 mm, sigma_y = 2 mm\n   avg_z = 0 mm, sigma_z = 0 mm\n   avg_px = -6.66134E-16 eV/c, sigma_px = 276.857 eV/c\n   avg_py = -6.55986E-15 eV/c, sigma_py = 276.857 eV/c\n   avg_pz = 220.904 eV/c, sigma_pz = 166.887 eV/c\n   avg_t = -2.04087E-17 ps, sigma_t = 1.1547 ps\n</pre> In\u00a0[4]: Copied! <pre># convert to simple data\nbeam.data()\n</pre> # convert to simple data beam.data() Out[4]: <pre>{'n_particle': 200000,\n 'species': 'electron',\n 'weight': array([5.e-17, 5.e-17, 5.e-17, ..., 5.e-17, 5.e-17, 5.e-17]),\n 'status': array([1, 1, 1, ..., 1, 1, 1]),\n 'x': array([0.00128902, 0.00305076, 0.00214569, ..., 0.00260949, 0.00176679,\n        0.00372237]),\n 'y': array([ 5.14825056e-08,  2.02660913e-07,  2.13199098e-07, ...,\n        -2.34926147e-07, -1.00008370e-07, -1.05941416e-07]),\n 'z': array([0., 0., 0., ..., 0., 0., 0.]),\n 'px': array([ -13.86451651,  129.51065025,  325.33389514, ...,  275.67822102,\n        -388.46055125, -161.11136234]),\n 'py': array([ 173.64325013,  321.97896692, -482.08502038, ...,  250.89066801,\n         486.05742377, -320.26104161]),\n 'pz': array([356.09464955, 242.9422157 , 160.51948115, ..., 162.23391877,\n        245.05703821, 359.35728695]),\n 't': array([-1.40736274e-12, -7.40252999e-14,  1.25931214e-12, ...,\n         9.71015844e-13, -1.25121322e-12,  8.21242174e-14])}</pre> In\u00a0[5]: Copied! <pre>from pmd_beamphysics import ParticleGroup\n</pre> from pmd_beamphysics import ParticleGroup In\u00a0[6]: Copied! <pre>P = ParticleGroup(data = beam.data())\n</pre> P = ParticleGroup(data = beam.data()) In\u00a0[7]: Copied! <pre>P.plot('x', 'y')\n</pre> P.plot('x', 'y') In\u00a0[8]: Copied! <pre># Resample to fewer particles\nP2 = P.resample(10000)\n</pre> # Resample to fewer particles P2 = P.resample(10000) In\u00a0[9]: Copied! <pre>P2.plot('x', 'y')\n</pre> P2.plot('x', 'y') In\u00a0[10]: Copied! <pre># Use the ParticleGroup to write to h5\nP2.write('distgen_particles.h5')\n</pre> # Use the ParticleGroup to write to h5 P2.write('distgen_particles.h5') In\u00a0[11]: Copied! <pre>P2.gamma\n</pre> P2.gamma Out[11]: <pre>array([1.00000029, 1.00000011, 1.0000004 , ..., 1.00000133, 1.00000022,\n       1.00000019])</pre> In\u00a0[12]: Copied! <pre>from h5py import File\nwith File('distgen_particles.h5', 'r') as h5:\n    P3 = ParticleGroup(h5)\n</pre> from h5py import File with File('distgen_particles.h5', 'r') as h5:     P3 = ParticleGroup(h5) In\u00a0[13]: Copied! <pre>P3.gamma\n</pre> P3.gamma Out[13]: <pre>array([1.00000029, 1.00000011, 1.0000004 , ..., 1.00000133, 1.00000022,\n       1.00000019])</pre> In\u00a0[14]: Copied! <pre># Cleanup\nos.remove('distgen_particles.h5')\nos.remove('rad.gaussian.out.txt')\n</pre> # Cleanup os.remove('distgen_particles.h5') os.remove('rad.gaussian.out.txt') In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/conversion_examples/#examples-on-converting-to-other-formats","title":"Examples on converting to other formats\u00b6","text":""},{"location":"examples/conversion_examples/#openpmd-beamphysics-data","title":"openPMD beamphysics data\u00b6","text":""},{"location":"examples/dist/","title":"Distributions","text":"In\u00a0[1]: Copied! <pre>%load_ext autoreload\n%autoreload 2\n%config InlineBackend.figure_format = 'retina'\n</pre> %load_ext autoreload %autoreload 2 %config InlineBackend.figure_format = 'retina' In\u00a0[2]: Copied! <pre>from distgen.physical_constants import unit_registry\nimport numpy as np\nfrom matplotlib import pyplot as plt\n</pre> from distgen.physical_constants import unit_registry import numpy as np from matplotlib import pyplot as plt <p>To sample various distributions requires generating random numbers and supplying them to the $CDF^{-1}$ functions for each corresponding distribution.  Currently, this is handled using</p> <p><code>distgen.dist.random_generator(shape, sequence, **params)</code>.</p> <p>Here <code>shape = (n_dimension, n_particle)</code> determines the shape of the random numbers returned.  The keyword 'sequence' can be used to set the sequence to Hammerlsey for quasi-random numbers.</p> <p>The difference is shown below:</p> In\u00a0[3]: Copied! <pre>from distgen.dist import random_generator\n\nshape = (2, 100)\n\np1 = random_generator(shape, 'hammersley')\np2 = random_generator(shape, 'pseudo')\n\nfig, ax = plt.subplots(1, 2, constrained_layout=True)\n\nax[0].plot(p1[0,:],p1[1,:],'.');\nax[0].set(xlabel='rx', ylabel='ry', title='hammersley');\n\nax[1].plot(p2[0,:],p2[1,:],'*');\nax[1].set(xlabel='rx', ylabel='ry', title='random.rand');\n</pre> from distgen.dist import random_generator  shape = (2, 100)  p1 = random_generator(shape, 'hammersley') p2 = random_generator(shape, 'pseudo')  fig, ax = plt.subplots(1, 2, constrained_layout=True)  ax[0].plot(p1[0,:],p1[1,:],'.'); ax[0].set(xlabel='rx', ylabel='ry', title='hammersley');  ax[1].plot(p2[0,:],p2[1,:],'*'); ax[1].set(xlabel='rx', ylabel='ry', title='random.rand'); <p>When using pseudo random numbers via NumPy, it is possible to set the generator seed:</p> In\u00a0[4]: Copied! <pre>fig, ax = plt.subplots(1, 1, constrained_layout=True)\n\np2 = random_generator(shape, 'pseudo', seed=0)\np3 = random_generator(shape, 'pseudo', seed=0)\n\nax.plot(p2[0,:],p2[1,:],'*');\nax.plot(p3[0,:],p3[1,:],'.');\nax.set(xlabel='rx', ylabel='ry', title='random.rand');\n</pre> fig, ax = plt.subplots(1, 1, constrained_layout=True)  p2 = random_generator(shape, 'pseudo', seed=0) p3 = random_generator(shape, 'pseudo', seed=0)  ax.plot(p2[0,:],p2[1,:],'*'); ax.plot(p3[0,:],p3[1,:],'.'); ax.set(xlabel='rx', ylabel='ry', title='random.rand'); In\u00a0[5]: Copied! <pre>from distgen import Generator\n</pre> from distgen import Generator In\u00a0[6]: Copied! <pre>gen = Generator('data/jpeg.image.in.yaml', verbose=0)\ngen.input\n</pre> gen = Generator('data/jpeg.image.in.yaml', verbose=0) gen.input Out[6]: <pre>{'n_particle': 1000000,\n 'species': 'electron',\n 'random': {'type': 'hammersley'},\n 'start': {'MTE': {'value': 150.0, 'units': 'millielectron_volt'},\n  'type': 'cathode'},\n 'total_charge': {'value': 10.0, 'units': 'picocoulomb'},\n 'xy_dist': {'file': '/home/runner/work/distgen/distgen/docs/examples/data/seaturtle.jpeg',\n  'max_x': {'value': 1.0, 'units': 'millimeter'},\n  'max_y': {'value': 1.0, 'units': 'millimeter'},\n  'min_x': {'value': -1.0, 'units': 'millimeter'},\n  'min_y': {'value': -1.0, 'units': 'millimeter'},\n  'threshold': 0.0,\n  'type': 'file2d'},\n 'output': {'type': None},\n 'transforms': None}</pre> In\u00a0[7]: Copied! <pre>gen.run().plot('x', 'y')\n</pre> gen.run().plot('x', 'y') In\u00a0[8]: Copied! <pre>inputs = gen.input.copy()\ninputs['random']={'type': 'pseudo', 'seed':0}\n\ngen = Generator(inputs, verbose=0)\ngen.run().plot('x', 'y')\n</pre> inputs = gen.input.copy() inputs['random']={'type': 'pseudo', 'seed':0}  gen = Generator(inputs, verbose=0) gen.run().plot('x', 'y') In\u00a0[9]: Copied! <pre>from distgen.dist import Uniform\nvar = 'x'\nverbose=1\nparams={'min_x':2*unit_registry('mm'),'max_x':4*unit_registry('mm')}\nuniform = Uniform(var,verbose=verbose,**params)\nuniform.plot_pdf()\nuniform.plot_cdf()\nuniform.test_sampling()\n</pre> from distgen.dist import Uniform var = 'x' verbose=1 params={'min_x':2*unit_registry('mm'),'max_x':4*unit_registry('mm')} uniform = Uniform(var,verbose=verbose,**params) uniform.plot_pdf() uniform.plot_cdf() uniform.test_sampling() <pre>uniform\n      min_x = 2 mm, max_x = 4 mm, avg_x = 3 mm, sigma_x:  0.57735 mm\n</pre> In\u00a0[10]: Copied! <pre>from distgen.dist import Norm\nvar = 'x'\nverbose=1\nparams={'sigma_x':2*unit_registry('mm'),'avg_x':-1*unit_registry('mm')}\nnorm = Norm(var,verbose=verbose,**params)\nnorm.plot_pdf()\nnorm.plot_cdf()\nnorm.test_sampling()\n</pre> from distgen.dist import Norm var = 'x' verbose=1 params={'sigma_x':2*unit_registry('mm'),'avg_x':-1*unit_registry('mm')} norm = Norm(var,verbose=verbose,**params) norm.plot_pdf() norm.plot_cdf() norm.test_sampling() <pre>Gaussian\n      avg_x = -1 mm, sigma_x = 2.000 mm\n</pre> <p>Below the $N_{\\text{cutoff}}$ parameter is set to cut the distribution symmetrically:</p> In\u00a0[11]: Copied! <pre>from distgen.dist import Norm\nvar = 'x'\nverbose=1\nparams={'sigma_x':2*unit_registry('mm'),'avg_x':0*unit_registry('mm'), 'n_sigma_cutoff':2}\nnorm = Norm(var,verbose=verbose,**params)\nnorm.plot_pdf()\nnorm.plot_cdf()\nnorm.test_sampling()\n</pre> from distgen.dist import Norm var = 'x' verbose=1 params={'sigma_x':2*unit_registry('mm'),'avg_x':0*unit_registry('mm'), 'n_sigma_cutoff':2} norm = Norm(var,verbose=verbose,**params) norm.plot_pdf() norm.plot_cdf() norm.test_sampling() <pre>Gaussian\n      avg_x = 0 mm, sigma_x = 2.000 mm\n      Left n_sigma_cutoff = 2, Right n_sigma_cutoff = -2\n</pre> <p>The distribution can be truncated asymmetrically using the $N_{\\text{cutoff},R}$ and $N_{\\text{cutoff},L}$ parameters, as shown below.  Note in this case, it is only required that $N_{\\text{cutoff},L} &lt; N_{\\text{cutoff},R}$, allowing for completley arbtitray location of the truncation points.  This requires a minus sign for the cut off parameters for truncation values less than zero.</p> In\u00a0[12]: Copied! <pre>from distgen.dist import Norm\nparams={'sigma_x':2*unit_registry('mm'),\n        'avg_x':0*unit_registry('mm'), \n        'n_sigma_cutoff_left':-1.5,\n        'n_sigma_cutoff_right':1}\n\nnorm = Norm('x',verbose=1,**params)\nnorm.plot_pdf()\nnorm.plot_cdf()\nnorm.test_sampling()\n</pre> from distgen.dist import Norm params={'sigma_x':2*unit_registry('mm'),         'avg_x':0*unit_registry('mm'),          'n_sigma_cutoff_left':-1.5,         'n_sigma_cutoff_right':1}  norm = Norm('x',verbose=1,**params) norm.plot_pdf() norm.plot_cdf() norm.test_sampling() <pre>Gaussian\n      avg_x = 0 mm, sigma_x = 2.000 mm\n      Left n_sigma_cutoff = 1, Right n_sigma_cutoff = -1.5\n</pre> In\u00a0[13]: Copied! <pre>from distgen.dist import SuperGaussian\n\nps = [0.5, 1 , 5, float('Inf')]\nalphas = [0, 0.25, 0.5, 1]\n\nfig, (ax1, ax2) = plt.subplots(1, 2,\n                               sharex='col',\n                               figsize=(12,4),\n                               constrained_layout=True)\n\nplegs = ['p = '+str(p) for p in ps]\nalegs = ['$\\\\alpha$ = '+str(a) for a in alphas]\n\nfor ii,p in enumerate(ps):\n    pparams = {'lambda':2*unit_registry('mm'),\n              'p':p*unit_registry('dimensionless'),}\n    \n    supG = SuperGaussian('x',verbose=0,**pparams)\n    x = supG.get_x_pts(1000)\n    rho = supG.pdf(x)\n    ax1.plot(x,rho);\n    \n    a=alphas[ii]\n    aparams = {'lambda':2*unit_registry('mm'),\n              'alpha':a*unit_registry('dimensionless'),}\n    \n    x = np.linspace(-3*aparams['lambda'], 3*aparams['lambda'],100)\n    supG = SuperGaussian('x',verbose=0,**aparams)\n    rho = supG.pdf(x)\n    ax2.plot(x,rho);\n    \nax1.set_xlabel('x (mm)');    ax2.set_xlabel('x (mm)');\nax1.set_ylabel('pdf (1/mm)');ax2.set_ylabel('pdf (1/mm)');\nax1.legend(plegs);           ax2.legend(alegs);\n</pre> from distgen.dist import SuperGaussian  ps = [0.5, 1 , 5, float('Inf')] alphas = [0, 0.25, 0.5, 1]  fig, (ax1, ax2) = plt.subplots(1, 2,                                sharex='col',                                figsize=(12,4),                                constrained_layout=True)  plegs = ['p = '+str(p) for p in ps] alegs = ['$\\\\alpha$ = '+str(a) for a in alphas]  for ii,p in enumerate(ps):     pparams = {'lambda':2*unit_registry('mm'),               'p':p*unit_registry('dimensionless'),}          supG = SuperGaussian('x',verbose=0,**pparams)     x = supG.get_x_pts(1000)     rho = supG.pdf(x)     ax1.plot(x,rho);          a=alphas[ii]     aparams = {'lambda':2*unit_registry('mm'),               'alpha':a*unit_registry('dimensionless'),}          x = np.linspace(-3*aparams['lambda'], 3*aparams['lambda'],100)     supG = SuperGaussian('x',verbose=0,**aparams)     rho = supG.pdf(x)     ax2.plot(x,rho);      ax1.set_xlabel('x (mm)');    ax2.set_xlabel('x (mm)'); ax1.set_ylabel('pdf (1/mm)');ax2.set_ylabel('pdf (1/mm)'); ax1.legend(plegs);           ax2.legend(alegs); <p>To set the length scale of the distribution, the user must either supply 'sigma_[var]' or 'lambda'. See usage below:</p> In\u00a0[14]: Copied! <pre>params = {'sigma_x':2*unit_registry('mm'),\n          #'alpha': 0.75*unit_registry('dimensionless'),\n           'alpha': 0.003*unit_registry('dimensionless'),\n          'avg_x':0.25*unit_registry('mm')}\n\nsupG = SuperGaussian('x',verbose=1,**params)\nsupG.plot_pdf()\nsupG.plot_cdf()\nsupG.test_sampling()\n</pre> params = {'sigma_x':2*unit_registry('mm'),           #'alpha': 0.75*unit_registry('dimensionless'),            'alpha': 0.003*unit_registry('dimensionless'),           'avg_x':0.25*unit_registry('mm')}  supG = SuperGaussian('x',verbose=1,**params) supG.plot_pdf() supG.plot_cdf() supG.test_sampling() <pre>Super Gaussian\n      sigma_x = 2 mm, power = 333.333\n</pre> <p>Disgten supports importing a 1D PDF saved in column form in.  The input form of the file should have space separated headers such as $x$ and $Px$, with corresponding column data below it.  The PDF is normalized numerically using the numpy.trapz numerical integration routine. The CDF is computed using the scipy.cumtrapz cumulative numerical intgration routine.</p> <p>The following example shows a gaussian PDF with cuts added to it.</p> In\u00a0[15]: Copied! <pre>from distgen.dist import File1d\nvar = 't'\nverbose=1\nparams={'file':'../examples/data/cutgauss.1d.txt','units':'ps'}\nfile1d = File1d(var,verbose=verbose,**params)\nfile1d.plot_pdf()\nfile1d.plot_cdf()\nfile1d.test_sampling()\n</pre> from distgen.dist import File1d var = 't' verbose=1 params={'file':'../examples/data/cutgauss.1d.txt','units':'ps'} file1d = File1d(var,verbose=verbose,**params) file1d.plot_pdf() file1d.plot_cdf() file1d.test_sampling() <pre>t-distribution file: \"../examples/data/cutgauss.1d.txt\"\n</pre> In\u00a0[16]: Copied! <pre>from distgen.dist import Sech2\n\nverbose=1\n#params={'tau':1.0*unit_registry('ps'), 'avg_t':1.0*unit_registry('ps')}\nparams={'sigma_t':1.0*unit_registry('ps'), 'avg_t':1.0*unit_registry('ps')}   \nlaser_pulse = Sech2(verbose=verbose, **params)\n\nlaser_pulse.plot_pdf()\nlaser_pulse.plot_cdf()\nlaser_pulse.test_sampling()\n</pre> from distgen.dist import Sech2  verbose=1 #params={'tau':1.0*unit_registry('ps'), 'avg_t':1.0*unit_registry('ps')} params={'sigma_t':1.0*unit_registry('ps'), 'avg_t':1.0*unit_registry('ps')}    laser_pulse = Sech2(verbose=verbose, **params)  laser_pulse.plot_pdf() laser_pulse.plot_cdf() laser_pulse.test_sampling()  <pre>Sech2\n      sigma_t = 1 ps, tau = 1.14377 ps\n</pre> In\u00a0[17]: Copied! <pre>from distgen.dist import TemporalLaserPulseStacking\nverbose=1\nparams={'crystal_length_1': 15.096*unit_registry('mm'),\n        'crystal_length_2': 7.548*unit_registry('mm'), \n        'crystal_length_3': 3.774*unit_registry('mm'), \n        'crystal_length_4': 1.887*unit_registry('mm'), \n        'crystal_angle_1':  0.6*unit_registry('deg'), \n        'crystal_angle_2':  1.8*unit_registry('deg'), \n        'crystal_angle_3': -0.9*unit_registry('deg'),  \n        'crystal_angle_4': -0.5*unit_registry('deg'), }\n    \nlaser_pulse = TemporalLaserPulseStacking(verbose=verbose,**params)\nlaser_pulse.plot_pdf()\nlaser_pulse.plot_cdf()\nlaser_pulse.test_sampling()\n</pre> from distgen.dist import TemporalLaserPulseStacking verbose=1 params={'crystal_length_1': 15.096*unit_registry('mm'),         'crystal_length_2': 7.548*unit_registry('mm'),          'crystal_length_3': 3.774*unit_registry('mm'),          'crystal_length_4': 1.887*unit_registry('mm'),          'crystal_angle_1':  0.6*unit_registry('deg'),          'crystal_angle_2':  1.8*unit_registry('deg'),          'crystal_angle_3': -0.9*unit_registry('deg'),           'crystal_angle_4': -0.5*unit_registry('deg'), }      laser_pulse = TemporalLaserPulseStacking(verbose=verbose,**params) laser_pulse.plot_pdf() laser_pulse.plot_cdf() laser_pulse.test_sampling() <pre>crystal temporal laser shaping\n      crystal 1 length = 15.096 mm, angle = 0.6 deg\n      crystal 2 length = 7.548 mm, angle = 1.8 deg\n      crystal 3 length = 3.774 mm, angle = -0.9 deg\n      crystal 4 length = 1.887 mm, angle = -0.5 deg\n      Pulses propagated: min t = -23.9053 ps, max t = 23.9053 ps\n</pre> In\u00a0[18]: Copied! <pre>from distgen.dist import Tukey\nvar = 'y'\nverbose=1\nparams={'length':2*unit_registry('mm'),'ratio':0.75*unit_registry('dimensionless')}\ntukey = Tukey(var,verbose=1,**params)\ntukey.plot_pdf()\ntukey.plot_cdf()\ntukey.test_sampling()\n</pre> from distgen.dist import Tukey var = 'y' verbose=1 params={'length':2*unit_registry('mm'),'ratio':0.75*unit_registry('dimensionless')} tukey = Tukey(var,verbose=1,**params) tukey.plot_pdf() tukey.plot_cdf() tukey.test_sampling() <pre>Tukey\n      length = 2 mm, ratio = 0.75\n</pre> In\u00a0[19]: Copied! <pre>from distgen.dist import Superposition\n\nparams = {\n    'dists':{\n        'd1':{\n            'avg_z':-1*unit_registry('mm'),\n            'sigma_z':1*unit_registry('mm'),\n            'type': 'gaussian'\n        } ,\n        'd2':{\n            'avg_z':+1*unit_registry('mm'),\n            'sigma_z':1*unit_registry('mm'),\n            'type': 'gaussian'\n        } \n    }\n}\n\nsup = Superposition('z', 1, **params)\nsup.plot_pdf()\nsup.plot_cdf()\nsup.test_sampling()\n</pre> from distgen.dist import Superposition  params = {     'dists':{         'd1':{             'avg_z':-1*unit_registry('mm'),             'sigma_z':1*unit_registry('mm'),             'type': 'gaussian'         } ,         'd2':{             'avg_z':+1*unit_registry('mm'),             'sigma_z':1*unit_registry('mm'),             'type': 'gaussian'         }      } }  sup = Superposition('z', 1, **params) sup.plot_pdf() sup.plot_cdf() sup.test_sampling() <pre>superpostion\n      1. distribution name: d1, type: Gaussian\n         avg_z = -1 mm, sigma_z = 1.000 mm\n      2. distribution name: d2, type: Gaussian\n         avg_z = 1 mm, sigma_z = 1.000 mm\n</pre> In\u00a0[20]: Copied! <pre>from distgen.dist import MaxwellBoltzmannDist\n\nparams = {'scale_p': 10*unit_registry('eV/c')}\n\nmb = MaxwellBoltzmannDist('p', verbose=0, **params)\n\nmb.plot_pdf()\nmb.plot_cdf()\nmb.test_sampling()\n</pre> from distgen.dist import MaxwellBoltzmannDist  params = {'scale_p': 10*unit_registry('eV/c')}  mb = MaxwellBoltzmannDist('p', verbose=0, **params)  mb.plot_pdf() mb.plot_cdf() mb.test_sampling() In\u00a0[21]: Copied! <pre>from distgen.dist import UniformRad\nverbose=1\nparams={'min_r':1*unit_registry('mm'),'max_r':2*unit_registry('mm')}\nurad = UniformRad(verbose=1,**params)\nurad.plot_pdf()\nurad.plot_cdf()\nurad.test_sampling()\n</pre> from distgen.dist import UniformRad verbose=1 params={'min_r':1*unit_registry('mm'),'max_r':2*unit_registry('mm')} urad = UniformRad(verbose=1,**params) urad.plot_pdf() urad.plot_cdf() urad.test_sampling() <pre>radial uniform\n      min_r = 1 mm, max_r = 2 mm\n</pre> In\u00a0[22]: Copied! <pre>from distgen.dist import NormRad\nverbose=1\nparams={'sigma_xy':1*unit_registry('mm')}\nnrad = NormRad(verbose=1,**params)\nnrad.plot_pdf()\nnrad.plot_cdf()\nnrad.test_sampling()\n</pre> from distgen.dist import NormRad verbose=1 params={'sigma_xy':1*unit_registry('mm')} nrad = NormRad(verbose=1,**params) nrad.plot_pdf() nrad.plot_cdf() nrad.test_sampling() <pre>radial Gaussian\n</pre> <p>For laser scientists it can be convenient to to work with a pinhole radius and a fraction of the laser intensity to clip a transverse normal laser mode at.  In this case the user can supply a truncation radius ($=r_R$) and a truncation fraction $f = \\exp\\left(-\\frac{r_R^2}{2\\sigma}\\right)$ from which distgen determines the underlying $\\sigma$.  The example below demonstrates this usage:</p> In\u00a0[23]: Copied! <pre>from distgen.dist import NormRad\nverbose=1\nparams={'truncation_radius':1*unit_registry('mm'),'truncation_fraction':0.5*unit_registry('dimensionless')}\nnrad = NormRad(verbose=1,**params)\nnrad.plot_pdf()\nnrad.plot_cdf()\nnrad.test_sampling()\n</pre> from distgen.dist import NormRad verbose=1 params={'truncation_radius':1*unit_registry('mm'),'truncation_fraction':0.5*unit_registry('dimensionless')} nrad = NormRad(verbose=1,**params) nrad.plot_pdf() nrad.plot_cdf() nrad.test_sampling() <pre>radial Gaussian\n</pre> In\u00a0[24]: Copied! <pre>from distgen.dist import NormRad\nverbose=1\nparams={'sigma_xy':2*unit_registry('mm'),'n_sigma_cutoff':1}\nnrad = NormRad(verbose=1,**params)\nnrad.plot_pdf()\nnrad.plot_cdf()\nnrad.test_sampling()\n</pre> from distgen.dist import NormRad verbose=1 params={'sigma_xy':2*unit_registry('mm'),'n_sigma_cutoff':1} nrad = NormRad(verbose=1,**params) nrad.plot_pdf() nrad.plot_cdf() nrad.test_sampling() <pre>radial Gaussian\n</pre> In\u00a0[25]: Copied! <pre>from distgen.dist import TukeyRad\nverbose=1\nparams={'length':1*unit_registry('mm'),'ratio':0.75*unit_registry('dimensionless')}\nrtukey = TukeyRad(verbose=1,**params)\nrtukey.plot_pdf()\nrtukey.plot_cdf()\nrtukey.test_sampling()\n</pre> from distgen.dist import TukeyRad verbose=1 params={'length':1*unit_registry('mm'),'ratio':0.75*unit_registry('dimensionless')} rtukey = TukeyRad(verbose=1,**params) rtukey.plot_pdf() rtukey.plot_cdf() rtukey.test_sampling() <pre>TukeyRad\n      legnth = 1.000 mm, ratio = 0.750\n</pre> In\u00a0[26]: Copied! <pre>from distgen.dist import SuperGaussianRad\nverbose=1\nparams={'sigma_xy':1*unit_registry('mm'),\n        'alpha':0.50*unit_registry('dimensionless')}\nsupG = SuperGaussianRad(verbose=1,**params)\nsupG.plot_pdf()\nsupG.plot_cdf()\nsupG.test_sampling()\n</pre> from distgen.dist import SuperGaussianRad verbose=1 params={'sigma_xy':1*unit_registry('mm'),         'alpha':0.50*unit_registry('dimensionless')} supG = SuperGaussianRad(verbose=1,**params) supG.plot_pdf() supG.plot_cdf() supG.test_sampling() <pre>SuperGaussianRad\n      lambda = 1.33134 mm, power = 2\n</pre> In\u00a0[27]: Copied! <pre>from distgen.dist import RadFile\n\nparams = {'file':'../examples/data/cutgauss.rad.txt','units':'mm'}\n\nrfd = RadFile(verbose=1, **params)\nrfd.plot_pdf()\nrfd.plot_cdf()\nrfd.test_sampling()\n</pre> from distgen.dist import RadFile  params = {'file':'../examples/data/cutgauss.rad.txt','units':'mm'}  rfd = RadFile(verbose=1, **params) rfd.plot_pdf() rfd.plot_cdf() rfd.test_sampling() <pre>radial file\n      r-dist file: \"../examples/data/cutgauss.rad.txt\"\n</pre>"},{"location":"examples/dist/#distributions","title":"Distributions\u00b6","text":""},{"location":"examples/dist/#random-number-generation","title":"Random Number Generation\u00b6","text":""},{"location":"examples/dist/#1d-distributions","title":"1D Distributions\u00b6","text":"<p>Distgen supports several one dimensional distribution types.</p>"},{"location":"examples/dist/#uniform-1d","title":"Uniform 1D\u00b6","text":"<p>The uniform distirbuition is defined by a probability distribution function:</p> <p>$\\rho(x) = \\frac{1}{b-a}$ for $a\\leq x\\leq b$ and zero elsewhere.</p> <p>The corresponding CDF is</p> <p>$P(x) = \\frac{x-a}{b-a}$ for $a\\leq x\\leq b$ and zero elsewhere.</p> <p>The first and second moments of this distribution are:</p> <p>$\\langle x \\rangle = \\frac{1}{2}(a+b)$ and $\\sigma_x = \\frac{b-a}{\\sqrt{12}}$</p>"},{"location":"examples/dist/#normal-distribution-including-truncation","title":"Normal Distribution (including truncation)\u00b6","text":"<p>The general form of a normal distribution PDF with truncation is given by</p> <p>$\\rho(x) = \\frac{1}{\\sigma}\\frac{\\phi\\left(\\frac{x-\\mu}{\\sigma}\\right)}{\\Phi\\left(\\frac{b-\\mu}{\\sigma}\\right)-\\Phi\\left(\\frac{a-\\mu}{\\sigma}\\right)}$.</p> <p>In this expression $\\phi(\\xi) = \\frac{1}{\\sqrt{2\\pi}}e^{-\\frac{1}{2}\\xi^2}$ is the canonical normal distribution, $\\Phi(\\xi) = \\frac{1}{2}\\left[1 + \\text{erf}\\left(\\frac{\\xi}{\\sqrt{2}}\\right) \\right]$ is the canonical normal CDF, and $a=-N_{\\text{cutoff}}\\cdot\\sigma$ and $b=-N_{\\text{cutoff}}\\cdot\\sigma$ are the left and right truncation points.  The CDF if given by</p> <p>$P(x) = \\frac{\\Phi\\left(\\frac{x-\\mu}{\\sigma}\\right) - \\Phi\\left(\\frac{a-\\mu}{\\sigma}\\right)}{\\Phi\\left(\\frac{b-\\mu}{\\sigma}\\right)-\\Phi\\left(\\frac{a-\\mu}{\\sigma}\\right)}$.</p> <p>Defining $\\alpha = \\frac{a-\\mu}{\\sigma}$ and $\\beta = \\frac{b-\\mu}{\\sigma}$, the first and second moments of the distribution are:</p> <p>$\\langle x\\rangle = \\mu + \\frac{\\phi\\left(\\alpha\\right) - \\phi\\left(\\beta\\right)}{\\Phi\\left(\\beta\\right)-\\Phi\\left(\\alpha\\right)}\\sigma$ and $\\sigma_x = \\sigma \\left\\{1 + \\frac{\\alpha\\phi\\left(\\alpha\\right) - \\beta\\phi(\\beta) }{\\Phi(\\beta) - \\Phi(\\alpha)} - \\left(\\frac{\\phi\\left(\\alpha\\right) - \\phi(\\beta)}{\\Phi(\\beta) - \\Phi(\\alpha)}\\right)^{2} \\right\\}^{1/2} $.</p> <p>When using this distribution, if the $N_{\\text{cutoff}}$ is not set then the distribution reduces to an infinite range normal distribution, as first shown below:</p>"},{"location":"examples/dist/#super-gaussian","title":"Super Gaussian\u00b6","text":"<p>In additional to the regular Gaussian function, it is also possible to sample a super-Gaussian distribution defined by</p> <p>$\\rho(x; \\lambda, p) = \\frac{1}{2\\sqrt{2}\\Gamma\\left(1+\\frac{1}{2p}\\right)\\lambda } \\exp\\left[-\\left(\\frac{(x-\\mu)^2 }{2\\lambda^2}\\right)^{p}\\right]$</p> <p>Here $\\sigma_1$ is the length scale and $p$ is the power of the super-Gaussian. Note when $p=1$ reduces to a Normal distirbution, in which case $\\sigma_x=\\lambda$.  As $p\\rightarrow\\infty$ the distribution reduces to a flat-top (uniform). The full range of powers is given by $p\\in\\left(0,\\infty\\right]$.</p> <p>The first and second moments of the distribution are given by:</p> <p>$\\langle x\\rangle = \\mu$, and $\\sigma_x = \\left(\\frac{2\\Gamma\\left(1+\\frac{3}{2p}\\right)}{3\\Gamma\\left(1+\\frac{1}{2p}\\right)}\\right)^{1/2}\\lambda$.</p> <p>Often, it is convenient to scan the distribution from the uniform limit to the Gaussian limit.  To do some, the input $p$ can be parameterized by $\\alpha\\in[0,1]$ where $p = 1/\\alpha$.  Here $\\alpha=0$ corresponds to a flat-top (uniform) and $\\alpha=1$ corresponds to a Gaussian.  Examples of both types of usage are shown below.</p>"},{"location":"examples/dist/#1d-pdf-from-a-file","title":"1D PDF from a file\u00b6","text":""},{"location":"examples/dist/#sech2-pulsed-laser-soliton","title":"$sech^2$ - Pulsed Laser Soliton\u00b6","text":""},{"location":"examples/dist/#laser-pulse-stacking","title":"Laser pulse stacking\u00b6","text":""},{"location":"examples/dist/#tukey-1d","title":"Tukey 1D\u00b6","text":""},{"location":"examples/dist/#superposition-1d","title":"Superposition 1D\u00b6","text":""},{"location":"examples/dist/#maxwell-boltzmann-distribution","title":"Maxwell-Boltzmann Distribution\u00b6","text":""},{"location":"examples/dist/#radial-distributions","title":"Radial Distributions\u00b6","text":""},{"location":"examples/dist/#radial-normal-distribution-with-truncation","title":"Radial Normal Distribution (with truncation)\u00b6","text":"<p>The radial normal distribution including truncation(s) has a probability function given by</p> <p>$\\rho_r(r) = \\frac{1}{\\sigma^2}\\frac{\\phi(r/\\sigma)}{\\phi\\left(\\frac{r_L}{\\sigma}\\right)-\\phi\\left(\\frac{r_R}{\\sigma}\\right)} $ for $0 \\leq r_L \\leq r \\leq r_R$ and zero everywhere else.</p> <p>In this expresion $\\phi(\\xi) = \\frac{1}{2\\pi}\\exp\\left(-\\xi^2/2\\right)$ is the canonical raidial normal distirbution (no truncation), and the scale parameter $\\sigma$ follows from the product of two normal distributions in $x$ and $y$ when $\\sigma=\\sigma_x=\\sigma_y$.  The corresponding CDF is given by</p> <p>$P(r)= \\frac{\\phi\\left(\\frac{r_L}{\\sigma}\\right)-\\phi\\left(\\frac{r}{\\sigma}\\right)}{\\phi\\left(\\frac{r_L}{\\sigma}\\right)-\\phi\\left(\\frac{r_R}{\\sigma}\\right)} $ for $0 \\leq r_L \\leq r$.</p> <p>The corresponding first and second moments are:</p> <p>$\\langle r\\rangle = \\frac{\\frac{r_L}{\\sigma}\\phi\\left(\\frac{r_L}{\\sigma}\\right) -\\frac{r_R}{\\sigma}\\phi\\left(\\frac{r_R}{\\sigma}\\right) +\\frac{1}{2\\sqrt{2\\pi}}\\left( \\text{erf}\\left(\\frac{r_R}{\\sigma\\sqrt{2}}\\right) - \\text{erf}\\left(\\frac{r_L}{\\sigma\\sqrt{2}}\\right) \\right)  } {\\phi\\left(\\frac{r_L}{\\sigma}\\right)-\\phi\\left(\\frac{r_R}{\\sigma}\\right)}$,</p> <p>$r_{rms} = \\sqrt{ 2\\sigma^2 + r_L^2 - \\frac{(r_R^2-r_L^2)\\phi(r_R/\\sigma)}{\\phi\\left(\\frac{r_L}{\\sigma}\\right)-\\phi\\left(\\frac{r_R}{\\sigma}\\right)} }$.</p> <p>Note that in the limits $r_L\\rightarrow 0$ and $r_R -&gt; \\infty$ the above expressions reduce to the underlying radial normal distribution:</p> <p>$\\rho_r(r)\\rightarrow \\frac{\\phi\\left(\\frac{r}{\\sigma}\\right)}{\\sigma^2}$, $P(r)\\rightarrow 1 - \\phi\\left(\\frac{r}{\\sigma}\\right)$, $\\langle r\\rangle\\rightarrow \\sqrt{\\frac{\\pi}{2}}\\sigma$, and $r_{rms}\\rightarrow \\sqrt{2}\\sigma$.  This limiting case is shown first below.</p>"},{"location":"examples/dist/#radial-tukey","title":"Radial Tukey\u00b6","text":""},{"location":"examples/dist/#radial-super-gaussian","title":"Radial Super Gaussian\u00b6","text":"<p>This implements a radial version of the Super Gaussian function discussed above.  Here the radial function takes the form:</p> <p>$2\\pi\\rho(r;\\lambda,p) = \\frac{1}{\\Gamma\\left(1+\\frac{1}{p}\\right)\\lambda^2} \\exp\\left[-\\left(\\frac{r^2}{2\\lambda^2}\\right)^p\\right]$. The corrsponding CDF is: ?</p> <p>The first and (rms) second moment of the distribution are given by:</p> <p>$\\langle r\\rangle = \\frac{2\\sqrt{2}}{3}\\frac{\\Gamma\\left(1+\\frac{3}{2p}\\right)}{\\Gamma\\left(1+\\frac{1}{p}\\right)}\\lambda$,</p> <p>$r_{\\text{rms}} = \\sqrt{\\frac{\\Gamma\\left(1+\\frac{2}{p}\\right)}{\\Gamma\\left(1+\\frac{1}{p}\\right)}}\\lambda$.</p>"},{"location":"examples/dist/#radial-file-distribution","title":"Radial File Distribution\u00b6","text":""},{"location":"examples/dist/#angular-distributions-todo","title":"Angular Distributions (TODO)\u00b6","text":"<p>Angular distributions define one dimensional probability functions for the cylindrical variable $\\theta$.</p>"},{"location":"examples/example_dists/","title":"Radial Distributions","text":"In\u00a0[1]: Copied! <pre># Useful for debugging\n%load_ext autoreload\n%autoreload 2\n%config InlineBackend.figure_format = 'retina'\n</pre> # Useful for debugging %load_ext autoreload %autoreload 2 %config InlineBackend.figure_format = 'retina' In\u00a0[2]: Copied! <pre>from distgen import Generator\nfrom distgen.plot import plot_dist2d, plot_dist1d, plot_current_profile\nfrom distgen.physical_constants import unit_registry\n\nfrom matplotlib import pyplot as plt\nimport os\nimport yaml\n\nfrom pprint import pprint\n</pre> from distgen import Generator from distgen.plot import plot_dist2d, plot_dist1d, plot_current_profile from distgen.physical_constants import unit_registry  from matplotlib import pyplot as plt import os import yaml  from pprint import pprint In\u00a0[3]: Copied! <pre>gen = Generator(verbose=0) \nunits = {'x':'mm', 'y':'mm', 'z':'mm', 'px':'keV/c', 'py':'keV/c', 't':'ps', 'q':'pC', 'I':'A'}\n</pre> gen = Generator(verbose=0)  units = {'x':'mm', 'y':'mm', 'z':'mm', 'px':'keV/c', 'py':'keV/c', 't':'ps', 'q':'pC', 'I':'A'} In\u00a0[4]: Copied! <pre>gen=Generator('data/rad.uniform.in.yaml',verbose=0)\ngen['r_dist:min_r']=0\nprint('\\nYAML input:')\nprint(yaml.dump({'r_dist':gen.input['r_dist']}))\n\nplot_dist2d(gen.beam(), 'x', units['x'], 'y', units['y'], axis='equal', title_on=True);\n</pre> gen=Generator('data/rad.uniform.in.yaml',verbose=0) gen['r_dist:min_r']=0 print('\\nYAML input:') print(yaml.dump({'r_dist':gen.input['r_dist']}))  plot_dist2d(gen.beam(), 'x', units['x'], 'y', units['y'], axis='equal', title_on=True); <pre>\nYAML input:\nr_dist:\n  max_r:\n    units: millimeter\n    value: 2\n  min_r:\n    units: millimeter\n    value: 0\n  type: radial_uniform\n\n</pre> In\u00a0[5]: Copied! <pre>gen=Generator('data/rad.uniform.in.yaml', verbose=0)\n\nprint('\\nYAML input:')\nprint(yaml.dump({'r_dist':gen.input['r_dist']}))\n\nplot_dist2d(gen.beam(), 'x', units['x'], 'y', units['y'], axis='equal', title_on=True);\n</pre> gen=Generator('data/rad.uniform.in.yaml', verbose=0)  print('\\nYAML input:') print(yaml.dump({'r_dist':gen.input['r_dist']}))  plot_dist2d(gen.beam(), 'x', units['x'], 'y', units['y'], axis='equal', title_on=True); <pre>\nYAML input:\nr_dist:\n  max_r:\n    units: millimeter\n    value: 2\n  min_r:\n    units: millimeter\n    value: 1\n  type: radial_uniform\n\n</pre> In\u00a0[6]: Copied! <pre># Radial gaussian distribution with sigma_xy 2 mm\ngen=Generator('data/rad.gaussian.in.yaml',verbose=0)\n\nprint('\\nYAML input:')\nprint(yaml.dump({'r_dist':gen.input['r_dist']}))\n\n# X-Y Plot\nplot_dist2d(gen.beam(), 'x', units['x'], 'y', units['y'], axis='equal', title_on=True);\n</pre> # Radial gaussian distribution with sigma_xy 2 mm gen=Generator('data/rad.gaussian.in.yaml',verbose=0)  print('\\nYAML input:') print(yaml.dump({'r_dist':gen.input['r_dist']}))  # X-Y Plot plot_dist2d(gen.beam(), 'x', units['x'], 'y', units['y'], axis='equal', title_on=True); <pre>\nYAML input:\nr_dist:\n  sigma_xy:\n    units: millimeter\n    value: 2\n  type: radial_gaussian\n\n</pre> <p>Example 2: Truncated Gaussian with a pinhole radius of 1 mm, clipped at 50% intensity</p> In\u00a0[7]: Copied! <pre># Truncated radial gaussian distribution with pihole diameter of 2 mm, gaussian clipped at 50% intensity\ngen=Generator('data/rad.trunc.gaussian.in.yaml',verbose=0)\n\nprint('\\nYAML input:')\nprint(yaml.dump({'r_dist':gen.input['r_dist']}))\n\n# X-Y Plot\nplot_dist2d(gen.beam(), 'x', units['x'], 'y',units['y'], axis='equal', title_on=True);\n</pre> # Truncated radial gaussian distribution with pihole diameter of 2 mm, gaussian clipped at 50% intensity gen=Generator('data/rad.trunc.gaussian.in.yaml',verbose=0)  print('\\nYAML input:') print(yaml.dump({'r_dist':gen.input['r_dist']}))  # X-Y Plot plot_dist2d(gen.beam(), 'x', units['x'], 'y',units['y'], axis='equal', title_on=True); <pre>\nYAML input:\nr_dist:\n  truncation_fraction:\n    units: dimensionless\n    value: 0.5\n  truncation_radius:\n    units: millimeter\n    value: 1\n  type: rg\n\n</pre> <p>Example 3: truncated Gaussian using underlying $\\sigma_{x,y}$ = 2 mm and n_sigma_cutoff = 1</p> In\u00a0[8]: Copied! <pre># Radial gaussian distribution with cut using n_sigma_cutoff\ngen=Generator('data/rad.gaussian.in.yaml', verbose=0)\ngen['r_dist:n_sigma_cutoff']=1\n\nprint(\"\\nYAML input:\")\nprint(yaml.dump({'r_dist':gen.input['r_dist']}))\n\n# X-Y Plot\nplot_dist2d(gen.beam(), 'x', units['x'], 'y', units['y'], axis='equal', title_on=True);\n</pre> # Radial gaussian distribution with cut using n_sigma_cutoff gen=Generator('data/rad.gaussian.in.yaml', verbose=0) gen['r_dist:n_sigma_cutoff']=1  print(\"\\nYAML input:\") print(yaml.dump({'r_dist':gen.input['r_dist']}))  # X-Y Plot plot_dist2d(gen.beam(), 'x', units['x'], 'y', units['y'], axis='equal', title_on=True); <pre>\nYAML input:\nr_dist:\n  n_sigma_cutoff: 1\n  sigma_xy:\n    units: millimeter\n    value: 2\n  type: radial_gaussian\n\n</pre> In\u00a0[9]: Copied! <pre># Radial distribution file: a radial gaussian with cuts in it\ngen=Generator('data/rad.file.in.yaml', verbose=0)\n\nprint('\\nYAML input:')\nprint(yaml.dump({'r_dist':gen.input['r_dist']}))\n\n# X-Y Plot\nplot_dist2d(gen.beam(), 'x', units['x'], 'y', units['y'], axis='equal');\n</pre> # Radial distribution file: a radial gaussian with cuts in it gen=Generator('data/rad.file.in.yaml', verbose=0)  print('\\nYAML input:') print(yaml.dump({'r_dist':gen.input['r_dist']}))  # X-Y Plot plot_dist2d(gen.beam(), 'x', units['x'], 'y', units['y'], axis='equal'); <pre>\nYAML input:\nr_dist:\n  file: /home/runner/work/distgen/distgen/docs/examples/data/cutgauss.rad.txt\n  type: radfile\n  units: mm\n\n</pre> In\u00a0[10]: Copied! <pre># Radial Tukey distribution\ngen=Generator('data/tukey.beer.can.in.yaml',verbose=0)\n\nprint('\\nYAML Input:')\nprint(yaml.dump({'r_dist':gen.input['r_dist']}))\n\nplot_dist2d(gen.beam(), 'x', units['x'], 'y', units['y'], axis='equal', title_on=True);\n</pre> # Radial Tukey distribution gen=Generator('data/tukey.beer.can.in.yaml',verbose=0)  print('\\nYAML Input:') print(yaml.dump({'r_dist':gen.input['r_dist']}))  plot_dist2d(gen.beam(), 'x', units['x'], 'y', units['y'], axis='equal', title_on=True); <pre>\nYAML Input:\nr_dist:\n  length:\n    units: millimeter\n    value: 5\n  ratio:\n    units: dimensionless\n    value: 0.25\n  type: radial_tukey\n\n</pre> In\u00a0[11]: Copied! <pre>gen=Generator('data/SG.beer.can.in.yaml',verbose=0)\n\nprint(\"\\nYAML Input:\")\nprint(yaml.dump({'r_dist':gen.input['r_dist']}))\n\nplot_dist2d(gen.beam(), 'x', units['x'], 'y', units['y'], axis='equal', title_on=True);\n</pre> gen=Generator('data/SG.beer.can.in.yaml',verbose=0)  print(\"\\nYAML Input:\") print(yaml.dump({'r_dist':gen.input['r_dist']}))  plot_dist2d(gen.beam(), 'x', units['x'], 'y', units['y'], axis='equal', title_on=True); <pre>\nYAML Input:\nr_dist:\n  alpha:\n    units: dimensionless\n    value: 0\n  sigma_xy:\n    units: millimeter\n    value: 1\n  type: rsg\n\n</pre> <p>Example 2: Gaussian limit (power = 1): $\\sigma_{x,y}$ = 1 mm</p> In\u00a0[12]: Copied! <pre>gen=Generator('data/SG.beer.can.in.yaml',verbose=0)\ngen['r_dist:alpha']=1.0\n\nprint('\\nYAML Input:')\nprint(yaml.dump({'r_dist':gen.input['r_dist']}))\n\nplot_dist2d(gen.beam(), 'x', units['x'], 'y', units['y'], axis='equal', title_on=True);\n</pre> gen=Generator('data/SG.beer.can.in.yaml',verbose=0) gen['r_dist:alpha']=1.0  print('\\nYAML Input:') print(yaml.dump({'r_dist':gen.input['r_dist']}))  plot_dist2d(gen.beam(), 'x', units['x'], 'y', units['y'], axis='equal', title_on=True); <pre>\nYAML Input:\nr_dist:\n  alpha:\n    units: dimensionless\n    value: 1.0\n  sigma_xy:\n    units: millimeter\n    value: 1\n  type: rsg\n\n</pre> <p>Example 3: sub-Gaussian (power &lt; 1): $\\sigma_{x,y} = 1$ mm, $p$ = 0.5</p> In\u00a0[13]: Copied! <pre>with open('data/SG.beer.can.in.yaml', 'r') as fid:\n    inputs = yaml.safe_load(fid)\n    \ndel inputs['r_dist']['alpha']\ninputs['r_dist']['p'] = {'value':0.5,'units':''}\n    \ngen=Generator(inputs, verbose=0)\n\nprint(\"\\nYAML Input:\")\nprint(yaml.dump({'r_dist':gen.input[\"r_dist\"]}))\n\nplot_dist2d(gen.beam(), 'x', units['x'], 'y', units['y'], axis=\"equal\", title_on=True);\n</pre> with open('data/SG.beer.can.in.yaml', 'r') as fid:     inputs = yaml.safe_load(fid)      del inputs['r_dist']['alpha'] inputs['r_dist']['p'] = {'value':0.5,'units':''}      gen=Generator(inputs, verbose=0)  print(\"\\nYAML Input:\") print(yaml.dump({'r_dist':gen.input[\"r_dist\"]}))  plot_dist2d(gen.beam(), 'x', units['x'], 'y', units['y'], axis=\"equal\", title_on=True); <pre>\nYAML Input:\nr_dist:\n  p:\n    units: dimensionless\n    value: 0.5\n  sigma_xy:\n    units: millimeter\n    value: 1\n  type: rsg\n\n</pre> In\u00a0[14]: Copied! <pre>gen=Generator('data/deformable.in.yaml',verbose=0)\n\nprint(\"\\nYAML Input:\")\nprint(yaml.dump({'r_dist':gen.input[\"r_dist\"]}))\n\nplot_dist2d(gen.beam(), 'x', units['x'], 'y', units['y'], axis=\"equal\", title_on=True);\n</pre> gen=Generator('data/deformable.in.yaml',verbose=0)  print(\"\\nYAML Input:\") print(yaml.dump({'r_dist':gen.input[\"r_dist\"]}))  plot_dist2d(gen.beam(), 'x', units['x'], 'y', units['y'], axis=\"equal\", title_on=True); <pre>\nYAML Input:\nr_dist:\n  alpha:\n    units: dimensionless\n    value: 0.1\n  sigma_xy:\n    units: millimeter\n    value: 1\n  slope_fraction:\n    units: dimensionless\n    value: -1\n  type: dr\n\n</pre> In\u00a0[15]: Copied! <pre>gen=Generator('data/interp_ex.yaml',verbose=0)\nprint(\"\\nYAML Input:\")\nprint(yaml.dump({'r_dist':gen.input[\"r_dist\"]}))\nPG = gen.run()\n</pre> gen=Generator('data/interp_ex.yaml',verbose=0) print(\"\\nYAML Input:\") print(yaml.dump({'r_dist':gen.input[\"r_dist\"]})) PG = gen.run() <pre>\nYAML Input:\nr_dist:\n  Pr:\n    pt01: 0.0\n    pt02: 1.1\n    pt03: 3.2\n    pt04: 8.0\n    pt05: 9.0\n    pt06: 8.0\n    pt07: 12.0\n    pt08: 3.0\n    pt09: 2.0\n    pt10: 3.0\n    pt11: 5.0\n    pt12: 1.0\n  method: spline\n  type: radial_interpolation\n\n</pre> In\u00a0[16]: Copied! <pre>PG.plot('r')\n</pre> PG.plot('r') In\u00a0[17]: Copied! <pre>PG.plot('x', 'y')\n</pre> PG.plot('x', 'y') In\u00a0[18]: Copied! <pre>PG['sigma_x'], PG['sigma_y']\n</pre> PG['sigma_x'], PG['sigma_y'] Out[18]: <pre>(np.float64(0.0012), np.float64(0.0012))</pre> In\u00a0[19]: Copied! <pre>from distgen.tools import SUPPORTED_IMAGE_EXTENSIONS\n</pre> from distgen.tools import SUPPORTED_IMAGE_EXTENSIONS In\u00a0[20]: Copied! <pre>SUPPORTED_IMAGE_EXTENSIONS\n</pre> SUPPORTED_IMAGE_EXTENSIONS Out[20]: <pre>['.dicom', '.dcm', '.jpeg', '.jpg', '.png', '.tiff']</pre> <p>The example below uses <code>.jpeg</code>.</p> In\u00a0[21]: Copied! <pre>gen=Generator('data/jpeg.image.in.yaml',verbose=0)\ngen.run()\n\nprint('\\nYAML input:')\nprint(yaml.dump({'xy_dist':gen.input['xy_dist']}))\n\ngen.particles.plot('x','y')\n</pre> gen=Generator('data/jpeg.image.in.yaml',verbose=0) gen.run()  print('\\nYAML input:') print(yaml.dump({'xy_dist':gen.input['xy_dist']}))  gen.particles.plot('x','y') <pre>\nYAML input:\nxy_dist:\n  file: /home/runner/work/distgen/distgen/docs/examples/data/seaturtle.jpeg\n  max_x:\n    units: millimeter\n    value: 1.0\n  max_y:\n    units: millimeter\n    value: 1.0\n  min_x:\n    units: millimeter\n    value: -1.0\n  min_y:\n    units: millimeter\n    value: -1.0\n  threshold: 0.0\n  type: file2d\n\n</pre> In\u00a0[22]: Copied! <pre>gen=Generator('data/dcm.image.in.yaml',verbose=0)\ngen.run()\n\nprint('\\nYAML input:')\nprint(yaml.dump({'xy_dist':gen.input['xy_dist']}))\n\ngen.particles.plot('x','y')\n</pre> gen=Generator('data/dcm.image.in.yaml',verbose=0) gen.run()  print('\\nYAML input:') print(yaml.dump({'xy_dist':gen.input['xy_dist']}))  gen.particles.plot('x','y') <pre>\nYAML input:\nxy_dist:\n  file: /home/runner/work/distgen/distgen/docs/examples/data/image-00319.dcm\n  max_x:\n    units: millimeter\n    value: 1\n  max_y:\n    units: millimeter\n    value: 1\n  min_x:\n    units: millimeter\n    value: -1\n  min_y:\n    units: millimeter\n    value: -1\n  threshold: 0.0\n  type: file2d\n\n</pre> <p>In addition to handling these standard images, distgen also supports the legacy ascii format from the original version of the code.  The example below makes use of this legacy format:</p> In\u00a0[23]: Copied! <pre># 2D XY distribution: Lase Image Example\n# Real laser spot image - using 1 million particles \ngen=Generator('data/laser.image.in.yaml',verbose=0)\n\nprint('\\nYAML input:')\nprint(yaml.dump({'xy_dist':gen.input['xy_dist']}))\n\n# X-Y Plot\nplot_dist2d(gen.beam(), 'x', units['x'], 'y', units['y'], nbins=100, axis='equal');\n</pre> # 2D XY distribution: Lase Image Example # Real laser spot image - using 1 million particles  gen=Generator('data/laser.image.in.yaml',verbose=0)  print('\\nYAML input:') print(yaml.dump({'xy_dist':gen.input['xy_dist']}))  # X-Y Plot plot_dist2d(gen.beam(), 'x', units['x'], 'y', units['y'], nbins=100, axis='equal'); <pre>\nYAML input:\nxy_dist:\n  file: /home/runner/work/distgen/distgen/docs/examples/data/laser.image.txt\n  type: file2d\n\n</pre> In\u00a0[24]: Copied! <pre>from distgen.tools import read_2d_file\n\nxs, ys, Pxy, xstr, ystr = read_2d_file('data/laser.image.txt')\n\ninputs={\n    \n    'n_particle': 200000,\n    'species': 'electron',\n    'total_charge': {'value':1, 'units':'pC'},\n    'random_type': 'hammersley',\n    'start': {\n        'MTE':{'units': 'meV', 'value': 150}, \n        'type': 'cathode'\n    },\n    'xy_dist':{\n        'type' : 'image2d',\n        'min_x': {'value':-2.0, 'units':'mm'},\n        'max_x': {'value':+2.0, 'units':'mm'},\n        'min_y': {'value':-2.0, 'units':'mm'},\n        'max_y': {'value':+2.0, 'units':'mm'},\n        'P':Pxy\n    }\n}\n\ngen=Generator(inputs, verbose=0)\n\ngen['xy_dist']\n#plot_dist2d(gen.beam(), 'x', units['x'], 'y', units['y'], nbins=100, axis='equal');\n</pre> from distgen.tools import read_2d_file  xs, ys, Pxy, xstr, ystr = read_2d_file('data/laser.image.txt')  inputs={          'n_particle': 200000,     'species': 'electron',     'total_charge': {'value':1, 'units':'pC'},     'random_type': 'hammersley',     'start': {         'MTE':{'units': 'meV', 'value': 150},          'type': 'cathode'     },     'xy_dist':{         'type' : 'image2d',         'min_x': {'value':-2.0, 'units':'mm'},         'max_x': {'value':+2.0, 'units':'mm'},         'min_y': {'value':-2.0, 'units':'mm'},         'max_y': {'value':+2.0, 'units':'mm'},         'P':Pxy     } }  gen=Generator(inputs, verbose=0)  gen['xy_dist'] #plot_dist2d(gen.beam(), 'x', units['x'], 'y', units['y'], nbins=100, axis='equal'); Out[24]: <pre>{'type': 'image2d',\n 'min_x': {'value': -2.0, 'units': 'millimeter'},\n 'max_x': {'value': 2.0, 'units': 'millimeter'},\n 'min_y': {'value': -2.0, 'units': 'millimeter'},\n 'max_y': {'value': 2.0, 'units': 'millimeter'},\n 'P': {'value': array([[0., 0., 0., ..., 0., 0., 0.],\n         [0., 0., 0., ..., 0., 0., 0.],\n         [0., 0., 0., ..., 0., 0., 0.],\n         ...,\n         [0., 0., 0., ..., 0., 0., 0.],\n         [0., 0., 0., ..., 0., 0., 0.],\n         [0., 0., 0., ..., 0., 0., 0.]]),\n  'units': '1 / millimeter ** 2'}}</pre> <p>Note that this allows the user to manipulate the 2d distribution and length scales:</p> In\u00a0[25]: Copied! <pre>gen=Generator(inputs, verbose=0)\n\nP2 = Pxy.magnitude\nP2 = P2.transpose()\n\n# Cut out a rectangle in the center\nP2[236-50:225+50, 236-50:225+50] = 0  \n\ngen['xy_dist:P']=P2\ngen['xy_dist:min_x:value'], gen['xy_dist:max_x:value']= -5000, +5000\ngen['xy_dist:min_x:units'], gen['xy_dist:max_x:units']= 'um', 'um'\ngen['xy_dist:min_y:units'], gen['xy_dist:max_y:units']= 'mm', 'mm'\n\nplot_dist2d(gen.beam(), 'x', units['x'], 'y', units['y'], nbins=100, axis='equal');\n</pre> gen=Generator(inputs, verbose=0)  P2 = Pxy.magnitude P2 = P2.transpose()  # Cut out a rectangle in the center P2[236-50:225+50, 236-50:225+50] = 0    gen['xy_dist:P']=P2 gen['xy_dist:min_x:value'], gen['xy_dist:max_x:value']= -5000, +5000 gen['xy_dist:min_x:units'], gen['xy_dist:max_x:units']= 'um', 'um' gen['xy_dist:min_y:units'], gen['xy_dist:max_y:units']= 'mm', 'mm'  plot_dist2d(gen.beam(), 'x', units['x'], 'y', units['y'], nbins=100, axis='equal'); In\u00a0[26]: Copied! <pre>gen = Generator('data/uniform_speckle.in.yaml')\n\nprint('\\nYAML input:')\nprint(yaml.dump({'xy_dist':gen.input['xy_dist']}))\n\ngen.run()\ngen.particles.plot('x', 'y')\n</pre> gen = Generator('data/uniform_speckle.in.yaml')  print('\\nYAML input:') print(yaml.dump({'xy_dist':gen.input['xy_dist']}))  gen.run() gen.particles.plot('x', 'y') <pre>\nYAML input:\nxy_dist:\n  max_x:\n    units: millimeter\n    value: 1\n  max_y:\n    units: millimeter\n    value: 2\n  min_x:\n    units: millimeter\n    value: -1\n  min_y:\n    units: millimeter\n    value: -2\n  pixel_threshold: 0.25\n  random_seed: 42\n  sigma: 100\n  type: uniform_laser_speckle\n\n</pre> In\u00a0[27]: Copied! <pre>gen['xy_dist:sigma'] = 10\ngen.run()\ngen.particles.plot('x', 'y')\n</pre> gen['xy_dist:sigma'] = 10 gen.run() gen.particles.plot('x', 'y') In\u00a0[28]: Copied! <pre>import numpy as np\nfrom matplotlib import pyplot as plt\n\nmask = np.kron([[1, 0] * 4, [0, 1] * 4] * 4, np.ones((50, 50)));\n\nys = np.linspace(-4, +4, mask.shape[0])\nxs = np.linspace(-2, +2, mask.shape[1])\n\nfig, ax = plt.subplots(1,3, constrained_layout=True, figsize=(8,4))\n\nax[0].imshow(mask, extent=[xs.min(),xs.max(), ys.min(), ys.max()]);\nax[0].set_aspect('equal',  adjustable='box')\nax[0].set_title('QE Map');\nax[0].set_xlabel('x (mm)');\nax[0].set_ylabel('y (mm)');\n\nlaser_inputs={\n    \n    'n_particle': 200000,\n    'species': 'electron',\n    'total_charge': {'value':1, 'units':'pC'},\n    'random_type': 'hammersley',\n    'start': {\n        'MTE':{'units': 'meV', 'value': 150}, \n        'type': 'cathode'},\n    \n    'r_dist': {\n        'type': 'rg',\n        'truncation_fraction': {'units': 'dimensionless', 'value': 0.5},\n        'truncation_radius': {'units': 'mm', 'value': 2}\n    },\n        \n}\n\ngen = Generator(laser_inputs)\nbeam1 = gen.beam()\n\nqe_and_laser_inputs={\n    \n    'n_particle': 200000,\n    'species': 'electron',\n    'total_charge': {'value':1, 'units':'pC'},\n    'random_type': 'hammersley',\n    'start': {\n        'MTE':{'units': 'meV', 'value': 150}, \n        'type': 'cathode'},\n    \n    'xy_dist':{\n        'type': 'product',\n        'dists': {\n            \n            'QE': {\n                'type': 'image2d',\n                'x':{'value':xs, 'units':'mm'},\n                'y':{'value':ys, 'units':'mm'},\n                'P':mask\n            \n            },\n            \n            'Laser':{\n                'type': 'rg',\n                'truncation_fraction': {'units': 'dimensionless', 'value': 0.5},\n                'truncation_radius': {'units': 'mm', 'value': 2}},\n        }\n    }\n}\n\ngen = Generator(qe_and_laser_inputs)\nbeam2 = gen.beam()\n\nplot_dist2d(beam1, 'x', units['x'], 'y', units['y'], nbins=100, axis='equal', ax=ax[1]);\nax[1].set_title('Laser Profile');\n\nplot_dist2d(beam2, 'x', units['x'], 'y', units['y'], nbins=100, axis='equal', ax=ax[2]);\nax[2].set_title('Laser &amp; QE Profile');\n</pre> import numpy as np from matplotlib import pyplot as plt  mask = np.kron([[1, 0] * 4, [0, 1] * 4] * 4, np.ones((50, 50)));  ys = np.linspace(-4, +4, mask.shape[0]) xs = np.linspace(-2, +2, mask.shape[1])  fig, ax = plt.subplots(1,3, constrained_layout=True, figsize=(8,4))  ax[0].imshow(mask, extent=[xs.min(),xs.max(), ys.min(), ys.max()]); ax[0].set_aspect('equal',  adjustable='box') ax[0].set_title('QE Map'); ax[0].set_xlabel('x (mm)'); ax[0].set_ylabel('y (mm)');  laser_inputs={          'n_particle': 200000,     'species': 'electron',     'total_charge': {'value':1, 'units':'pC'},     'random_type': 'hammersley',     'start': {         'MTE':{'units': 'meV', 'value': 150},          'type': 'cathode'},          'r_dist': {         'type': 'rg',         'truncation_fraction': {'units': 'dimensionless', 'value': 0.5},         'truncation_radius': {'units': 'mm', 'value': 2}     },          }  gen = Generator(laser_inputs) beam1 = gen.beam()  qe_and_laser_inputs={          'n_particle': 200000,     'species': 'electron',     'total_charge': {'value':1, 'units':'pC'},     'random_type': 'hammersley',     'start': {         'MTE':{'units': 'meV', 'value': 150},          'type': 'cathode'},          'xy_dist':{         'type': 'product',         'dists': {                          'QE': {                 'type': 'image2d',                 'x':{'value':xs, 'units':'mm'},                 'y':{'value':ys, 'units':'mm'},                 'P':mask                          },                          'Laser':{                 'type': 'rg',                 'truncation_fraction': {'units': 'dimensionless', 'value': 0.5},                 'truncation_radius': {'units': 'mm', 'value': 2}},         }     } }  gen = Generator(qe_and_laser_inputs) beam2 = gen.beam()  plot_dist2d(beam1, 'x', units['x'], 'y', units['y'], nbins=100, axis='equal', ax=ax[1]); ax[1].set_title('Laser Profile');  plot_dist2d(beam2, 'x', units['x'], 'y', units['y'], nbins=100, axis='equal', ax=ax[2]); ax[2].set_title('Laser &amp; QE Profile'); In\u00a0[29]: Copied! <pre>inputs=\"\"\"\nn_particle: 1000000\nspecies: electron\nxy_dist:\n  type: product\n  dists:\n    speckle:\n      max_x: +2 mm \n      min_x: -2 mm\n      max_y: +2 mm \n      min_y: -2 mm\n      sigma: 100\n      pixel_threshold: 0.25\n      random_seed: 42\n      type: uniform_laser_speckle\n    uniform:\n      max_r: 2 mm \n      min_r: 0 mm\n      type: radial_uniform     \nrandom:\n  type: hammersley\nstart:\n  MTE: 150 meV\n  type: cathode\nt_dist:\n  avg_t: 0.5 ns\n  sigma_t: 2 ns\n  type: gaussian\ntotal_charge: 10 pC\n\"\"\"\n\ngen = Generator(inputs)\ngen.run()\ngen.particles.plot('x', 'y', figsize=(5, 5))\n</pre> inputs=\"\"\" n_particle: 1000000 species: electron xy_dist:   type: product   dists:     speckle:       max_x: +2 mm        min_x: -2 mm       max_y: +2 mm        min_y: -2 mm       sigma: 100       pixel_threshold: 0.25       random_seed: 42       type: uniform_laser_speckle     uniform:       max_r: 2 mm        min_r: 0 mm       type: radial_uniform      random:   type: hammersley start:   MTE: 150 meV   type: cathode t_dist:   avg_t: 0.5 ns   sigma_t: 2 ns   type: gaussian total_charge: 10 pC \"\"\"  gen = Generator(inputs) gen.run() gen.particles.plot('x', 'y', figsize=(5, 5)) In\u00a0[30]: Copied! <pre>gen['xy_dist:dists:speckle:sigma']=5\ngen.run()\ngen.particles.plot('x', 'y', figsize=(5, 5))\n</pre> gen['xy_dist:dists:speckle:sigma']=5 gen.run() gen.particles.plot('x', 'y', figsize=(5, 5)) In\u00a0[31]: Copied! <pre>gen=Generator('data/x.uniform.y.file.t.gaussian.in.yaml',verbose=0)\n\nprint('\\nYAML Input:')\nprint(yaml.dump({'x_dist':gen.input['x_dist']}))\n\nplot_dist1d(gen.beam(), 'x', units['y'], nbins=100, title_on=True)\n</pre> gen=Generator('data/x.uniform.y.file.t.gaussian.in.yaml',verbose=0)  print('\\nYAML Input:') print(yaml.dump({'x_dist':gen.input['x_dist']}))  plot_dist1d(gen.beam(), 'x', units['y'], nbins=100, title_on=True) <pre>\nYAML Input:\nx_dist:\n  max_x:\n    units: millimeter\n    value: 2\n  min_x:\n    units: millimeter\n    value: -1\n  type: uniform\n\n</pre> <p>The user may also specify the distribution using the <code>sigma_{var}</code> and <code>avg_{var}</code> input params:</p> In\u00a0[32]: Copied! <pre>import numpy as np\ngen.input['t_dist']={\n    'type': 'uniform',\n    'sigma_t':{'value': float(1/np.sqrt(12)), 'units':'ps'},\n    'avg_t': '2 ps'\n}\n\ngen = Generator(gen.input, verbose=0)\n\nprint('\\nYAML Input:')\nprint(yaml.dump({'t_dist':gen.input['t_dist']}))\n\nplot_dist1d(gen.beam(), 't', units['t'], nbins=100, title_on=True)\n</pre> import numpy as np gen.input['t_dist']={     'type': 'uniform',     'sigma_t':{'value': float(1/np.sqrt(12)), 'units':'ps'},     'avg_t': '2 ps' }  gen = Generator(gen.input, verbose=0)  print('\\nYAML Input:') print(yaml.dump({'t_dist':gen.input['t_dist']}))  plot_dist1d(gen.beam(), 't', units['t'], nbins=100, title_on=True) <pre>\nYAML Input:\nt_dist:\n  avg_t:\n    units: picosecond\n    value: -0.5\n  sigma_t:\n    units: picosecond\n    value: 1.0\n  type: gaussian\n\n</pre> In\u00a0[33]: Copied! <pre>gen=Generator('data/x.uniform.y.file.t.gaussian.in.yaml',verbose=0)\n\nprint('\\nYAML Input:')\nprint(yaml.dump({'y_dist':gen.input['y_dist']}))\nplot_dist1d(gen.beam(), 'y', units['y'], nbins=1000)\n</pre> gen=Generator('data/x.uniform.y.file.t.gaussian.in.yaml',verbose=0)  print('\\nYAML Input:') print(yaml.dump({'y_dist':gen.input['y_dist']})) plot_dist1d(gen.beam(), 'y', units['y'], nbins=1000) <pre>\nYAML Input:\ny_dist:\n  file: /home/runner/work/distgen/distgen/docs/examples/data/cutgauss.1d.txt\n  type: file1d\n  units: mm\n\n</pre> <p>If not specified, the Gaussian is truncated at $\\mu\\pm5\\sigma$:</p> In\u00a0[34]: Copied! <pre>gen=Generator('data/x.uniform.y.file.t.gaussian.in.yaml',verbose=0)\n\nprint('\\nYAML Input:')\nprint(yaml.dump({'t_dist':gen.input['t_dist']}))\n\nplot_dist1d(gen.beam(), 't', units['t'], nbins=1000)\n</pre> gen=Generator('data/x.uniform.y.file.t.gaussian.in.yaml',verbose=0)  print('\\nYAML Input:') print(yaml.dump({'t_dist':gen.input['t_dist']}))  plot_dist1d(gen.beam(), 't', units['t'], nbins=1000) <pre>\nYAML Input:\nt_dist:\n  avg_t:\n    units: picosecond\n    value: -0.5\n  sigma_t:\n    units: picosecond\n    value: 1\n  type: gaussian\n\n</pre> <p>The user can specify <code>n_sigma_cutoff</code> to symmetrically truncate at $ \\mu\\pm N_{\\sigma~\\text{cutoff}}\\times\\sigma$:</p> In\u00a0[35]: Copied! <pre>gen=Generator('data/x.uniform.y.file.t.gaussian.in.yaml', verbose=0)\ngen['t_dist:avg_t']=1\ngen['t_dist:n_sigma_cutoff']=2\n\nprint('\\nYAML Input:')\nprint(yaml.dump({'t_dist':gen.input['t_dist']}))\n\nplot_dist1d(gen.beam(), 't', units['t'], nbins=1000)\n</pre> gen=Generator('data/x.uniform.y.file.t.gaussian.in.yaml', verbose=0) gen['t_dist:avg_t']=1 gen['t_dist:n_sigma_cutoff']=2  print('\\nYAML Input:') print(yaml.dump({'t_dist':gen.input['t_dist']}))  plot_dist1d(gen.beam(), 't', units['t'], nbins=1000) <pre>\nYAML Input:\nt_dist:\n  avg_t:\n    units: picosecond\n    value: 1\n  n_sigma_cutoff: 2\n  sigma_t:\n    units: picosecond\n    value: 1\n  type: gaussian\n\n</pre> In\u00a0[36]: Copied! <pre># Super Gaussian distribution\ngen=Generator('data/SG.beer.can.in.yaml', verbose=0)\n\nprint('\\nYAML Input:')\nprint(yaml.dump({'t_dist':gen.input['t_dist']}))\n\nplot_current_profile(gen.beam(), units['t'], units['I'], title_on=True)\n</pre> # Super Gaussian distribution gen=Generator('data/SG.beer.can.in.yaml', verbose=0)  print('\\nYAML Input:') print(yaml.dump({'t_dist':gen.input['t_dist']}))  plot_current_profile(gen.beam(), units['t'], units['I'], title_on=True) <pre>\nYAML Input:\nt_dist:\n  alpha:\n    units: dimensionless\n    value: 0.5\n  sigma_t:\n    units: picosecond\n    value: 8\n  type: sg\n\n</pre> In\u00a0[37]: Copied! <pre># Tukey distribution\ngen=Generator('data/tukey.beer.can.in.yaml', verbose=0)\n\nprint('\\nYAML Input:')\nprint(yaml.dump({'t_dist':gen.input['t_dist']}))\n\nplot_current_profile(gen.beam(), units['t'], units['I'], nbins=500, title_on=True)\n</pre> # Tukey distribution gen=Generator('data/tukey.beer.can.in.yaml', verbose=0)  print('\\nYAML Input:') print(yaml.dump({'t_dist':gen.input['t_dist']}))  plot_current_profile(gen.beam(), units['t'], units['I'], nbins=500, title_on=True) <pre>\nYAML Input:\nt_dist:\n  length:\n    units: picosecond\n    value: 5.0\n  ratio:\n    units: dimensionless\n    value: 0.75\n  type: tukey\n\n</pre> In\u00a0[38]: Copied! <pre>gen=Generator('data/multi.gaussian.in.yaml', verbose=0)\nprint('\\nYAML Input:')\nprint(yaml.dump({'z_dist':gen.input['z_dist']}))\nplot_dist1d(gen.beam(), 'z', units['z'] ,title_on=True)\nprint(gen['z_dist:weights'])\n</pre> gen=Generator('data/multi.gaussian.in.yaml', verbose=0) print('\\nYAML Input:') print(yaml.dump({'z_dist':gen.input['z_dist']})) plot_dist1d(gen.beam(), 'z', units['z'] ,title_on=True) print(gen['z_dist:weights']) <pre>\nYAML Input:\nz_dist:\n  dists:\n    d1:\n      avg_z:\n        units: millimeter\n        value: -2\n      sigma_z:\n        units: millimeter\n        value: 1.0\n      type: gaussian\n    d2:\n      avg_z:\n        units: millimeter\n        value: 2\n      sigma_z:\n        units: millimeter\n        value: 1\n      type: gaussian\n  type: superposition\n  weights:\n    d1: 1\n    d2: 1\n\n</pre> <pre>{'d1': 1, 'd2': 1}\n</pre> <p>Example 2: with user specified weighting:</p> In\u00a0[39]: Copied! <pre>gen['z_dist:weights']={'d1':2, 'd2':1}\nprint('\\nYAML Input:')\nprint(yaml.dump({'z_dist':gen.input['z_dist']}))\nplot_dist1d(gen.beam(), 'z', units['z'] ,title_on=True)\n</pre> gen['z_dist:weights']={'d1':2, 'd2':1} print('\\nYAML Input:') print(yaml.dump({'z_dist':gen.input['z_dist']})) plot_dist1d(gen.beam(), 'z', units['z'] ,title_on=True) <pre>\nYAML Input:\nz_dist:\n  dists:\n    d1:\n      avg_z:\n        units: millimeter\n        value: -2\n      sigma_z:\n        units: millimeter\n        value: 1.0\n      type: gaussian\n    d2:\n      avg_z:\n        units: millimeter\n        value: 2\n      sigma_z:\n        units: millimeter\n        value: 1\n      type: gaussian\n  type: superposition\n  weights:\n    d1: 2\n    d2: 1\n\n</pre> In\u00a0[40]: Copied! <pre>gen=Generator('data/product.gaussian.in.yaml', verbose=0)\nprint('\\nYAML Input:')\nprint(yaml.dump({'z_dist':gen.input['z_dist']}))\nplot_dist1d(gen.beam(), 'z', units['z'] ,title_on=True)\n</pre> gen=Generator('data/product.gaussian.in.yaml', verbose=0) print('\\nYAML Input:') print(yaml.dump({'z_dist':gen.input['z_dist']})) plot_dist1d(gen.beam(), 'z', units['z'] ,title_on=True) <pre>\nYAML Input:\nz_dist:\n  dists:\n    d1:\n      max_z:\n        units: millimeter\n        value: 3\n      min_z:\n        units: millimeter\n        value: -3\n      type: uniform\n    d2:\n      avg_z:\n        units: millimeter\n        value: 0\n      sigma_z:\n        units: millimeter\n        value: 2\n      type: gaussian\n  type: product\n\n</pre> In\u00a0[41]: Copied! <pre>gen=Generator('data/deformable.in.yaml', verbose=0)\nprint('\\nYAML Input:')\nprint(yaml.dump({'t_dist':gen.input['t_dist']}))\nplot_current_profile(gen.beam(), units['t'], units['I'] ,title_on=True)\n</pre> gen=Generator('data/deformable.in.yaml', verbose=0) print('\\nYAML Input:') print(yaml.dump({'t_dist':gen.input['t_dist']})) plot_current_profile(gen.beam(), units['t'], units['I'] ,title_on=True) <pre>\nYAML Input:\nt_dist:\n  alpha:\n    units: dimensionless\n    value: 0.25\n  avg_t:\n    units: picosecond\n    value: 0\n  sigma_t:\n    units: picosecond\n    value: 1\n  slope_fraction:\n    units: dimensionless\n    value: 1\n  type: deformable\n\n</pre> In\u00a0[42]: Copied! <pre>gen = Generator('data/interp_ex.yaml')\nprint('\\nYAML Input:')\nprint(yaml.dump({'t_dist':gen.input['t_dist']}))\n</pre> gen = Generator('data/interp_ex.yaml') print('\\nYAML Input:') print(yaml.dump({'t_dist':gen.input['t_dist']})) <pre>\nYAML Input:\nt_dist:\n  Pt:\n    pt01: 0.1\n    pt02: 0.3\n    pt03: 4.0\n    pt04: 2.9\n    pt05: 8.5\n    pt06: 2.0\n    pt07: 0.1\n    pt08: 1.0\n    pt09: 5.0\n    pt10: 10.0\n    pt11: 6.0\n    pt12: 1.0\n  avg_t:\n    units: nanosecond\n    value: 0.0\n  method: spline\n  sigma_t:\n    units: nanosecond\n    value: 0.08287285705\n  type: interp\n\n</pre> In\u00a0[43]: Copied! <pre>ax = plot_dist1d(gen.beam(), 't', units['t'] ,title_on=True)\n</pre> ax = plot_dist1d(gen.beam(), 't', units['t'] ,title_on=True) In\u00a0[44]: Copied! <pre>gen=Generator('data/t.crystals.in.yaml',verbose=0)\nprint('\\nYAML Input:')\nprint(yaml.dump({'t_dist':gen.input['t_dist']}))\nplot_current_profile(gen.beam(), units['t'], units['I'] ,title_on=True)\n</pre> gen=Generator('data/t.crystals.in.yaml',verbose=0) print('\\nYAML Input:') print(yaml.dump({'t_dist':gen.input['t_dist']})) plot_current_profile(gen.beam(), units['t'], units['I'] ,title_on=True) <pre>\nYAML Input:\nt_dist:\n  crystal_angle_1:\n    units: degree\n    value: 0.6\n  crystal_angle_2:\n    units: degree\n    value: 1.8\n  crystal_angle_3:\n    units: degree\n    value: -0.9\n  crystal_angle_4:\n    units: degree\n    value: -0.5\n  crystal_length_1:\n    units: millimeter\n    value: 15.096\n  crystal_length_2:\n    units: millimeter\n    value: 7.548\n  crystal_length_3:\n    units: millimeter\n    value: 3.774\n  crystal_length_4:\n    units: millimeter\n    value: 1.887\n  type: crystals\n\n</pre> In\u00a0[45]: Copied! <pre>gen=Generator('data/t-sech2.in.yaml',verbose=0)\nprint('\\nYAML Input:')\nprint(yaml.dump({'t_dist':gen.input['t_dist']}))\nplot_current_profile(gen.beam(), units['t'], units['I'] ,title_on=True)\n</pre> gen=Generator('data/t-sech2.in.yaml',verbose=0) print('\\nYAML Input:') print(yaml.dump({'t_dist':gen.input['t_dist']})) plot_current_profile(gen.beam(), units['t'], units['I'] ,title_on=True) <pre>\nYAML Input:\nt_dist:\n  n_tau_cutoff: 4\n  tau:\n    units: picosecond\n    value: 3\n  type: sech2\n\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/example_dists/#radial-distributions","title":"Radial Distributions\u00b6","text":""},{"location":"examples/example_dists/#radial-uniform","title":"Radial Uniform\u00b6","text":"<p>The radial uniform distribution is given by</p> <p>$\\rho_r(r)=\\frac{2}{r_R^2-r_L^2}$ for $0 \\leq r_L &lt; r &lt; r_R$ and zero otherewise.</p> <p>Typical usage is shown below for a uniformly filled beam as well as a ring:</p>"},{"location":"examples/example_dists/#radial-gaussian-with-truncation","title":"Radial Gaussian (with Truncation)\u00b6","text":"<p>The radial normal distribution including truncation(s) has a probability function given by</p> <p>$\\rho_r(r) = \\frac{1}{\\sigma^2}\\frac{\\phi(r/\\sigma)}{\\phi\\left(\\frac{r_L}{\\sigma}\\right)-\\phi\\left(\\frac{r_R}{\\sigma}\\right)} $ for $0 \\leq r_L \\leq r \\leq r_R$ and zero everywhere else.</p> <p>In this expresion $\\phi(\\xi) = \\frac{1}{2\\pi}\\exp\\left(-\\xi^2/2\\right)$ is the canonical raidial normal distirbution (no truncation), and the scale parameter $\\sigma$ follows from the product of two normal distributions in $x$ and $y$ when $\\sigma=\\sigma_x=\\sigma_y$.  The corresponding CDF is given by</p> <p>$P(r)= \\frac{\\phi\\left(\\frac{r_L}{\\sigma}\\right)-\\phi\\left(\\frac{r}{\\sigma}\\right)}{\\phi\\left(\\frac{r_L}{\\sigma}\\right)-\\phi\\left(\\frac{r_R}{\\sigma}\\right)} $ for $0 \\leq r_L \\leq r$.</p> <p>The corresponding first and second moments are:</p> <p>$\\langle r\\rangle = \\frac{\\frac{r_L}{\\sigma}\\phi\\left(\\frac{r_L}{\\sigma}\\right) -\\frac{r_R}{\\sigma}\\phi\\left(\\frac{r_R}{\\sigma}\\right) +\\frac{1}{2\\sqrt{2\\pi}}\\left( \\text{erf}\\left(\\frac{r_R}{\\sigma\\sqrt{2}}\\right) - \\text{erf}\\left(\\frac{r_L}{\\sigma\\sqrt{2}}\\right) \\right)  } {\\phi\\left(\\frac{r_L}{\\sigma}\\right)-\\phi\\left(\\frac{r_R}{\\sigma}\\right)}$,</p> <p>$r_{rms} = \\sqrt{ 2\\sigma^2 + r_L^2 - \\frac{(r_R^2-r_L^2)\\phi(r_R/\\sigma)}{\\phi\\left(\\frac{r_L}{\\sigma}\\right)-\\phi\\left(\\frac{r_R}{\\sigma}\\right)} }$.</p> <p>Note that in the limits $r_L\\rightarrow 0$ and $r_R -&gt; \\infty$ the above expressions reduce to the underlying radial normal distribution:</p> <p>$\\rho_r(r)\\rightarrow \\frac{\\phi\\left(\\frac{r}{\\sigma}\\right)}{\\sigma^2}$, $P(r)\\rightarrow 1 - \\phi\\left(\\frac{r}{\\sigma}\\right)$, $\\langle r\\rangle\\rightarrow \\sqrt{\\frac{\\pi}{2}}\\sigma$, and $r_{rms}\\rightarrow \\sqrt{2}\\sigma$.  This limiting case is shown first below.</p> <p>Here three examples are provided: a non-truncated Gaussian with $\\sigma_{x,y}$ = 2 mm, followed by a truncated Gaussian using a truncation fraction to specify the maximal radial cut, followed by a truncated Gaussian using n_sigma_cutoff to specify the radial cut.</p> <p>Example 1: canonical Gaussian with $\\sigma_{x,y}$ = 2mm</p>"},{"location":"examples/example_dists/#radial-file","title":"Radial File\u00b6","text":""},{"location":"examples/example_dists/#radial-tukey","title":"Radial Tukey\u00b6","text":""},{"location":"examples/example_dists/#radial-super-gaussian","title":"Radial Super Gaussian\u00b6","text":"<p>This implements a radial version of the Super Gaussian function.  Here the radial function takes the form:</p> <p>$2\\pi\\rho(r;\\lambda,p) = \\frac{1}{\\Gamma\\left(1+\\frac{1}{p}\\right)\\lambda^2} \\exp\\left[-\\left(\\frac{r^2}{2\\lambda^2}\\right)^p\\right]$.</p> <p>The first and (rms) second moment of the distribution are given by:</p> <p>$\\langle r\\rangle = \\frac{2\\sqrt{2}}{3}\\frac{\\Gamma\\left(1+\\frac{3}{2p}\\right)}{\\Gamma\\left(1+\\frac{1}{p}\\right)}\\lambda$,</p> <p>$r_{\\text{rms}} = \\sqrt{\\frac{\\Gamma\\left(1+\\frac{2}{p}\\right)}{\\Gamma\\left(1+\\frac{1}{p}\\right)}}\\lambda$.</p> <p>Example 1: hyper-Gaussian (uniform) limit (power $\\rightarrow\\infty$): $\\sigma_{x,y}$ = 1 mm</p>"},{"location":"examples/example_dists/#radial-deformable","title":"Radial Deformable\u00b6","text":""},{"location":"examples/example_dists/#radial-interpolation","title":"Radial Interpolation\u00b6","text":""},{"location":"examples/example_dists/#2d-distributions","title":"2D Distributions\u00b6","text":""},{"location":"examples/example_dists/#2d-file","title":"2D File\u00b6","text":"<p>The user can load images for use in generating particles.  Supported file formats include:</p>"},{"location":"examples/example_dists/#2d-image","title":"2D Image\u00b6","text":"<p>If the user has an image dataset already loaded into python, they can directly pass this to Distgen using the Image2d class.  An example of how to use this in practice is given below:</p>"},{"location":"examples/example_dists/#uniform-laser-speckle","title":"Uniform Laser Speckle\u00b6","text":"<p>This distribution provides a very simplistic method of simulating laser speckle.  The input distribution parameter <code>sigma</code> controls the size of the speckles.  Sigma is the size of a blurring Gaussian which is used to scale the FFT of the image before transforming back.  Smaller $\\sigma$ gives larger speckles. In addition the user can specify a pixel_threshold [0 1] that will zero a given pixel if the resulting speckle pattern amplitude is below the threshold.</p>"},{"location":"examples/example_dists/#product-2d","title":"Product 2D\u00b6","text":"<p>It is possible to multiply two or more 2d or radial distributions.  This is useful for creating particles from a laser and folding in a cathod QE map.  The example shows a truncated Gaussian laser profile combined with a simple checker board QE map:</p>"},{"location":"examples/example_dists/#superposition-2d","title":"Superposition 2D\u00b6","text":"<p>TODO</p>"},{"location":"examples/example_dists/#1d-distributions","title":"1D Distributions\u00b6","text":""},{"location":"examples/example_dists/#uniform","title":"Uniform\u00b6","text":"<p>The uniform distirbuition is defined by a probability distribution function:</p> <p>$\\rho(x) = \\frac{1}{b-a}$ for $a\\leq x\\leq b$ and zero elsewhere.</p> <p>The corresponding CDF is</p> <p>$P(x) = \\frac{x-a}{b-a}$ for $a\\leq x\\leq b$ and zero elsewhere.</p> <p>The first and second moments of this distribution are:</p> <p>$\\langle x \\rangle = \\frac{1}{2}(a+b)$ and $\\sigma_x = \\frac{b-a}{\\sqrt{12}}$.</p> <p>It is possible to set a uniform distribution using the <code>min_{var}</code> and <code>max_{var}</code> input variables:</p>"},{"location":"examples/example_dists/#linear","title":"Linear\u00b6","text":"<p>The linear distirbuition is defined by a probability distribution function:</p> <p>$\\rho(x) = \\frac{p_b-p_a}{b-a}(x-a) + p_a$ for $a\\leq x\\leq b$ and zero elsewhere.</p> <p>The corresponding CDF is</p> <p>$P(x) = \\frac{1}{2}\\frac{p_b-p_a}{b-a}(x-a)$ for $a\\leq x\\leq b$ and zero elsewhere.</p> <p>It is possible to set a uniform distribution using the <code>min_{var}</code> and <code>max_{var}</code>(equivalent to $a$ and $b$ above) input variables as well as the <code>slope_fraction</code> $\\in[-1,1]$.</p>"},{"location":"examples/example_dists/#1d-file","title":"1D File\u00b6","text":"<p>Disgten supports importing a 1D PDF saved in column form in.  The input form of the file should have space separated headers such as $x$ and $Px$, with corresponding column data below it.  The PDF is normalized numerically using the numpy.trapz numerical integration routine. The CDF is computed using the scipy.cumtrapz cumulative numerical intgration routine.</p> <p>The following example shows a gaussian PDF with cuts added to it.</p>"},{"location":"examples/example_dists/#gaussian-with-truncation","title":"Gaussian (with Truncation)\u00b6","text":""},{"location":"examples/example_dists/#super-gaussian","title":"Super Gaussian\u00b6","text":"<p>In additional to the regular Gaussian function, it is also possible to sample a super-Gaussian distribution defined by</p> <p>$\\rho(x; \\lambda, p) = \\frac{1}{2\\sqrt{2}\\Gamma\\left(1+\\frac{1}{2p}\\right)\\lambda } \\exp\\left[-\\left(\\frac{(x-\\mu)^2 }{2\\lambda^2}\\right)^{p}\\right]$</p> <p>Here $\\lambda$ is the length scale and $p$ is the power of the super-Gaussian. Note when $p=1$ this expression reduces to a Normal distirbution, in which case $\\sigma_x=\\lambda$.  As $p\\rightarrow\\infty$ the distribution reduces to a flat-top (uniform). The full range of powers is given by $p\\in\\left(0,\\infty\\right]$.</p> <p>The first and second moments of the distribution are given by:</p> <p>$\\langle x\\rangle = \\mu$, and $\\sigma_x = \\left(\\frac{2\\Gamma\\left(1+\\frac{3}{2p}\\right)}{3\\Gamma\\left(1+\\frac{1}{2p}\\right)}\\right)^{1/2}\\lambda$.</p> <p>Often, it is convenient to scan the distribution from the uniform limit to the Gaussian limit.  To do some, the input $p$ can be parameterized by $\\alpha\\in[0,1]$ where $p = 1/\\alpha$.  Here $\\alpha=0$ corresponds to a flat-top (uniform) and $\\alpha=1$ corresponds to a Gaussian.  Examples of both types of usage are shown below.\\</p> <p>Example 1: specifying $\\alpha = 1/p \\in[0,1]$:</p>"},{"location":"examples/example_dists/#tukey","title":"Tukey\u00b6","text":""},{"location":"examples/example_dists/#superposition-1d","title":"Superposition 1D\u00b6","text":"<p>This distribution allows the user to superimpose an arbitrary number of 1D PDFs.  The general form is:</p> <p>$\\rho(x) = \\sum_i w_i \\frac{\\rho_i(x)}{\\max(\\rho_i)}$.</p> <p>Here the $w_i$ are user specified weights.  If no weight is specified for a given $\\rho_i$, then the weight(s) will default to one.</p> <p>Example 1: equal weighting</p>"},{"location":"examples/example_dists/#product-1d","title":"Product 1D\u00b6","text":""},{"location":"examples/example_dists/#deformable","title":"Deformable\u00b6","text":""},{"location":"examples/example_dists/#interpolation","title":"Interpolation\u00b6","text":"<p>For the 1d interpolation distribution the user provides N points of the PDF for the desired variable and interpolation is employed to make a smooth curve.  The PDF knots can be passed in as a dictionary or as an array.  Passing in a corresponding coordinate vector is optional.  If a coordinate vector is not input, then the user must use a transform operator to scale the resulting distribution (shown below).</p>"},{"location":"examples/example_dists/#special-temporal-distributions","title":"Special Temporal Distributions\u00b6","text":""},{"location":"examples/example_dists/#pulse-stacking-temporal-crystals","title":"Pulse stacking temporal crystals\u00b6","text":""},{"location":"examples/example_dists/#sech2-pulse-laser-soliton","title":"$sech^2$ Pulse Laser Soliton\u00b6","text":"<p>Similar to Gaussian in shape, but more accurate for certain types of pulsed laser shapes.  The example below shows setting up the distribution using the pulse duraction $\\tau$.  It is possible to also use $\\sigma_t$ instead.</p>"},{"location":"examples/fermi_dirac_3step_barrier_photocathode_model/","title":"Fermi-Dirac 3 Step Barrier Momentum Distribution","text":"In\u00a0[1]: Copied! <pre>%load_ext autoreload\n%autoreload 2\n%config InlineBackend.figure_format = 'retina'\n</pre> %load_ext autoreload %autoreload 2 %config InlineBackend.figure_format = 'retina' In\u00a0[2]: Copied! <pre>from distgen.physical_constants import unit_registry, PHYSICAL_CONSTANTS\n\nh = PHYSICAL_CONSTANTS['Planck constant in eV/Hz']\nc = PHYSICAL_CONSTANTS['speed of light in vacuum']\nhc = h*c\n\nMC2 = PHYSICAL_CONSTANTS.species('electron')['mc2']\n\nimport scipy.constants as const\n</pre> from distgen.physical_constants import unit_registry, PHYSICAL_CONSTANTS  h = PHYSICAL_CONSTANTS['Planck constant in eV/Hz'] c = PHYSICAL_CONSTANTS['speed of light in vacuum'] hc = h*c  MC2 = PHYSICAL_CONSTANTS.species('electron')['mc2']  import scipy.constants as const In\u00a0[3]: Copied! <pre>from matplotlib import pyplot as plt\nimport numpy as np\n</pre> from matplotlib import pyplot as plt import numpy as np In\u00a0[4]: Copied! <pre>from distgen import Generator\n</pre> from distgen import Generator In\u00a0[5]: Copied! <pre>photon_energy = 2.5*unit_registry('eV')\nlaser_wavelength = hc/photon_energy \ncathode_temperature = 300 * unit_registry('K')\nfermi_energy = 6 * unit_registry('eV')\ncathode_work_function = 2 * unit_registry('eV')\n</pre> photon_energy = 2.5*unit_registry('eV') laser_wavelength = hc/photon_energy  cathode_temperature = 300 * unit_registry('K') fermi_energy = 6 * unit_registry('eV') cathode_work_function = 2 * unit_registry('eV') In\u00a0[6]: Copied! <pre>D = Generator('data/fermi_dirac_3step_barrier_photocathode.in.yaml', verbose=1)\n\nD['p_polar_angle_dist:photon_wavelength']=laser_wavelength.to('nm').magnitude\nD['p_polar_angle_dist:temperature']=cathode_temperature\nD['p_polar_angle_dist:fermi_energy']=fermi_energy\nD['p_polar_angle_dist:work_function']=cathode_work_function\n</pre> D = Generator('data/fermi_dirac_3step_barrier_photocathode.in.yaml', verbose=1)  D['p_polar_angle_dist:photon_wavelength']=laser_wavelength.to('nm').magnitude D['p_polar_angle_dist:temperature']=cathode_temperature D['p_polar_angle_dist:fermi_energy']=fermi_energy D['p_polar_angle_dist:work_function']=cathode_work_function In\u00a0[7]: Copied! <pre>P = D.run()\n</pre> P = D.run() <pre>Distribution format: None\n   Warning: no output file specified, defaulting to \"None\".\nOutput file: None\n\nCreating beam distribution....\n   Beam starting from: cathode\n   Total charge: 10 pC.\n   Number of macroparticles: 200000.\n   Assuming cylindrical symmetry...\n   Assuming cylindrical momentum symmetry...\n   r distribution: radial Gaussian\n   theta distribution: uniform theta\n      min_theta = 0 rad, max_theta = 6.28319 rad\n   |p| and polar angle distribution: Fermi-Dirac 3 Step Barrier Photocathode Model\n      laser wavelength = 495.937 nm, photon energy = 2.5 eV\n      cathode temperature = 300 K, cathode work function = 2 eV, Fermi energy = 6 eV\n</pre> <pre>   azimuthal angle distribution: uniform theta\n      min_theta = 0 rad, max_theta = 6.28319 rad\n   t distribution: uniform\n      min_t = -17.3205 ps, max_t = 17.3205 ps, avg_t = 0 ps, sigma_t:  10 ps\n   Shifting avg_x = -1.75251E-06 mm -&gt; 0 mm\n   Scaling sigma_x = 0.999928 mm -&gt; 1 mm\n   Shifting avg_y = 2.14895E-05 mm -&gt; 0 mm\n   Scaling sigma_y = 0.999965 mm -&gt; 1 mm\n   Shifting avg_px = 0.0058674 eV/c -&gt; 0 eV/c\n   Shifting avg_py = -0.0095719 eV/c -&gt; 0 eV/c\n   Shifting avg_t = -0.000333868 ps -&gt; 0 ps\n   Scaling sigma_t = 9.99998 ps -&gt; 10 ps\n...done. Time Elapsed: 801.532 ms.\n\n   Created particles in .particles: \n   ParticleGroup with 200000 particles with total charge 1.0000000000000003e-11 C\n</pre> In\u00a0[8]: Copied! <pre>P.plot('px', 'pz')\n</pre> P.plot('px', 'pz') In\u00a0[9]: Copied! <pre># Fetch constants from scipy\nkb = const.value('Boltzmann constant in eV/K')\nmc2 = const.value('electron mass energy equivalent in MeV')*1e6\n\n\ndef fermi_dirac(e, mu, t, t_cutoff=1e-3):\n    \"\"\"\n    Fermi-Dirac distribution\n    :param e: energy to evaluate at\n    :param mu: Fermi energy\n    :param t: Temperature\n    :param t_cutoff: Clip the temperature at this value to avoid divide by zero\n    :return: value of the Fermi-Dirac distribution\n    \"\"\"\n    return 1/(1 + np.exp(np.clip((e - mu)/(kb*np.clip(t, t_cutoff, None)), -256, 256)))\n\n\ndef dowell_schmerge_pdf_int(px, py, pz, fermi_energy, temp, photon_energy, workfun):\n    e = (px**2 + py**2 + pz**2)/2/mc2\n    p_excite = (1 - fermi_dirac(e + photon_energy, fermi_energy, temp))*fermi_dirac(e, fermi_energy, temp)\n    p_transport = pz &gt; 0\n    p_escape = pz**2/2/mc2 + photon_energy &gt;= fermi_energy + workfun\n    return p_excite*p_transport*p_escape\n\n\ndef ds_transform(px, py, pz, fermi_energy, photon_energy, workfun):\n    a = np.sqrt(1 - photon_energy/((px**2 + py**2 + pz**2)/2/mc2 + fermi_energy + workfun))\n    return px*a, py*a, np.sqrt(pz**2 + 2*mc2*(fermi_energy + workfun))*a\n\n\ndef ds_jacobian_factor(px, py, pz, fermi_energy, photon_energy, workfun):\n    num = pz*np.sqrt(px**2 + py**2 + pz**2 + 2*mc2*(fermi_energy + workfun - photon_energy))\n    den = np.sqrt((pz**2 + 2*mc2*(fermi_energy + workfun))*(px**2 + py**2 + pz**2 + 2*mc2*(fermi_energy + workfun)))\n    return num/den\n\n\ndef dowell_schmerge_pdf(px, py, pz, photon_energy, workfun, temp, fermi_energy):\n    \"\"\"\n    :params px: x component of momentum (in eV/c)\n    :params py: y component of momentum (in eV/c)\n    :params pz: z component of momentum (in eV/c)\n    :params photon_energy: photon energy of driving laser (in eV)\n    :params workfun: photocathode work function (in eV)\n    :params temp: photocathode temperature (in K)\n    :params fermi_energy: photocathode Fermi energy (in eV; note, PDF should be insensitive to this value)\n    :return: unnormalized density of the emitted electrons at this momentum\n    \"\"\"\n    a = ds_jacobian_factor(px, py, pz, fermi_energy, photon_energy, workfun)\n    return a*dowell_schmerge_pdf_int(*ds_transform(px, py, pz, fermi_energy, photon_energy, workfun), fermi_energy, temp, photon_energy, workfun)\n\n\ndef dowell_schmerge_pdf_bounds(photon_energy, workfun, temp, fermi_energy, n_tails=4):\n    \"\"\"\n    Calculates bounding box of the non-zero part of the PDF\n    :param temp: photocathode emperature (in K)\n    :param photon_energy: photon energy of the driving laser (in eV)\n    :param workfun: photocathode work function (in eV)\n    :param n_tails: amount of Fermi tail to include (in units of kB*T)\n    :return: (xl, xu), (yl, yu), (zl, zu), the lower (l) and upper (u) bounds along each axis (x, y, z)\n    \"\"\"\n    a = np.sqrt(2*mc2*(photon_energy - workfun + kb*temp*n_tails))\n    return [(-a, a), (-a, a), (0., a)]\n\n\ndef dowell_schmerge_pdf_spherical(p, theta, photon_energy, workfun, temp, fermi_energy):\n    return dowell_schmerge_pdf(p*np.cos(theta), 0., p*np.sin(theta), photon_energy, workfun, temp, fermi_energy)\n\n\ndef dowell_schmerge_pdf_bounds_spherical(photon_energy, workfun, temp, fermi_energy, n_tails=4):\n    (_, a), _, _ = dowell_schmerge_pdf_bounds(photon_energy, workfun, temp, fermi_energy, n_tails=n_tails)\n    return (0, a), (0, np.pi/2)\n</pre> # Fetch constants from scipy kb = const.value('Boltzmann constant in eV/K') mc2 = const.value('electron mass energy equivalent in MeV')*1e6   def fermi_dirac(e, mu, t, t_cutoff=1e-3):     \"\"\"     Fermi-Dirac distribution     :param e: energy to evaluate at     :param mu: Fermi energy     :param t: Temperature     :param t_cutoff: Clip the temperature at this value to avoid divide by zero     :return: value of the Fermi-Dirac distribution     \"\"\"     return 1/(1 + np.exp(np.clip((e - mu)/(kb*np.clip(t, t_cutoff, None)), -256, 256)))   def dowell_schmerge_pdf_int(px, py, pz, fermi_energy, temp, photon_energy, workfun):     e = (px**2 + py**2 + pz**2)/2/mc2     p_excite = (1 - fermi_dirac(e + photon_energy, fermi_energy, temp))*fermi_dirac(e, fermi_energy, temp)     p_transport = pz &gt; 0     p_escape = pz**2/2/mc2 + photon_energy &gt;= fermi_energy + workfun     return p_excite*p_transport*p_escape   def ds_transform(px, py, pz, fermi_energy, photon_energy, workfun):     a = np.sqrt(1 - photon_energy/((px**2 + py**2 + pz**2)/2/mc2 + fermi_energy + workfun))     return px*a, py*a, np.sqrt(pz**2 + 2*mc2*(fermi_energy + workfun))*a   def ds_jacobian_factor(px, py, pz, fermi_energy, photon_energy, workfun):     num = pz*np.sqrt(px**2 + py**2 + pz**2 + 2*mc2*(fermi_energy + workfun - photon_energy))     den = np.sqrt((pz**2 + 2*mc2*(fermi_energy + workfun))*(px**2 + py**2 + pz**2 + 2*mc2*(fermi_energy + workfun)))     return num/den   def dowell_schmerge_pdf(px, py, pz, photon_energy, workfun, temp, fermi_energy):     \"\"\"     :params px: x component of momentum (in eV/c)     :params py: y component of momentum (in eV/c)     :params pz: z component of momentum (in eV/c)     :params photon_energy: photon energy of driving laser (in eV)     :params workfun: photocathode work function (in eV)     :params temp: photocathode temperature (in K)     :params fermi_energy: photocathode Fermi energy (in eV; note, PDF should be insensitive to this value)     :return: unnormalized density of the emitted electrons at this momentum     \"\"\"     a = ds_jacobian_factor(px, py, pz, fermi_energy, photon_energy, workfun)     return a*dowell_schmerge_pdf_int(*ds_transform(px, py, pz, fermi_energy, photon_energy, workfun), fermi_energy, temp, photon_energy, workfun)   def dowell_schmerge_pdf_bounds(photon_energy, workfun, temp, fermi_energy, n_tails=4):     \"\"\"     Calculates bounding box of the non-zero part of the PDF     :param temp: photocathode emperature (in K)     :param photon_energy: photon energy of the driving laser (in eV)     :param workfun: photocathode work function (in eV)     :param n_tails: amount of Fermi tail to include (in units of kB*T)     :return: (xl, xu), (yl, yu), (zl, zu), the lower (l) and upper (u) bounds along each axis (x, y, z)     \"\"\"     a = np.sqrt(2*mc2*(photon_energy - workfun + kb*temp*n_tails))     return [(-a, a), (-a, a), (0., a)]   def dowell_schmerge_pdf_spherical(p, theta, photon_energy, workfun, temp, fermi_energy):     return dowell_schmerge_pdf(p*np.cos(theta), 0., p*np.sin(theta), photon_energy, workfun, temp, fermi_energy)   def dowell_schmerge_pdf_bounds_spherical(photon_energy, workfun, temp, fermi_energy, n_tails=4):     (_, a), _, _ = dowell_schmerge_pdf_bounds(photon_energy, workfun, temp, fermi_energy, n_tails=n_tails)     return (0, a), (0, np.pi/2) In\u00a0[10]: Copied! <pre># Plot the projection onto px, pz\nn_points = 200\n(bxm, bxp), (bym, byp), (bzm, bzp) = dowell_schmerge_pdf_bounds(photon_energy.magnitude, \n                                                                cathode_work_function.magnitude, \n                                                                cathode_temperature.magnitude, \n                                                                fermi_energy.magnitude)\npx, py, pz = np.mgrid[bxm:bxp:1j*n_points, bym:byp:1j*n_points, bzm:bzp:1j*n_points]\n\nrho = np.sum(dowell_schmerge_pdf(px, py, pz, photon_energy.magnitude, \n                                             cathode_work_function.magnitude, \n                                             cathode_temperature.magnitude, \n                                             fermi_energy.magnitude), axis=1)\nplt.pcolormesh(1e-3*px[:, 0, :], 1e-3*pz[:, 0, :], rho)\nplt.xlabel(\"p$_x$ (keV/c)\");\nplt.ylabel('p$_z$ (keV/c)');\n</pre> # Plot the projection onto px, pz n_points = 200 (bxm, bxp), (bym, byp), (bzm, bzp) = dowell_schmerge_pdf_bounds(photon_energy.magnitude,                                                                  cathode_work_function.magnitude,                                                                  cathode_temperature.magnitude,                                                                  fermi_energy.magnitude) px, py, pz = np.mgrid[bxm:bxp:1j*n_points, bym:byp:1j*n_points, bzm:bzp:1j*n_points]  rho = np.sum(dowell_schmerge_pdf(px, py, pz, photon_energy.magnitude,                                               cathode_work_function.magnitude,                                               cathode_temperature.magnitude,                                               fermi_energy.magnitude), axis=1) plt.pcolormesh(1e-3*px[:, 0, :], 1e-3*pz[:, 0, :], rho) plt.xlabel(\"p$_x$ (keV/c)\"); plt.ylabel('p$_z$ (keV/c)'); In\u00a0[11]: Copied! <pre># Plot the MTE vs photon energy and temp\ndef get_mte(fermi_energy, t, photon_energy, workfun, n_points=128):\n    #mc2 = 511e3\n    (bxm, bxp), (bym, byp), (bzm, bzp) = dowell_schmerge_pdf_bounds(photon_energy, workfun, t, fermi_energy)\n    px, py, pz = np.mgrid[bxm:bxp:1j*n_points, bym:byp:1j*n_points, bzm:bzp:1j*n_points]\n    rho = dowell_schmerge_pdf(px, py, pz, photon_energy, workfun, t, fermi_energy)\n    norm = np.trapezoid(np.trapezoid(np.trapezoid(rho, dx=px[1, 0, 0] - px[0, 0, 0], axis=0), dx=py[0, 1, 0] - py[0, 0, 0], axis=0), dx=pz[0, 0, 1] - pz[0, 0, 0])\n    px_sec_moment = np.trapezoid(np.trapezoid(np.trapezoid(px**2*rho, dx=px[1, 0, 0] - px[0, 0, 0], axis=0), dx=py[0, 1, 0] - py[0, 0, 0], axis=0), dx=pz[0, 0, 1] - pz[0, 0, 0])\n    return (px_sec_moment/norm)/mc2*1e3\n\nephoton = np.linspace(2.1, 2.9, 16)\nplt.plot(ephoton, (ephoton-2)/3*1e3, label='Dowell-Schmerge Formula (T=0 K)')\n\nfor temp in [0, 300, 600]:\n    mte = np.array([get_mte(6., temp, ep, 2.) for ep in ephoton])\n    plt.plot(ephoton, mte, marker='x', ls='none', label='Numerical Integral (T=%.0f K)' % temp)\n\nplt.plot(photon_energy, 1000*P['sigma_px']**2/MC2.magnitude, 'o', label='Distgen')\n\nplt.legend()\nplt.xlabel('Photon Energy (eV)')\nplt.ylabel('MTE (meV)')\n</pre> # Plot the MTE vs photon energy and temp def get_mte(fermi_energy, t, photon_energy, workfun, n_points=128):     #mc2 = 511e3     (bxm, bxp), (bym, byp), (bzm, bzp) = dowell_schmerge_pdf_bounds(photon_energy, workfun, t, fermi_energy)     px, py, pz = np.mgrid[bxm:bxp:1j*n_points, bym:byp:1j*n_points, bzm:bzp:1j*n_points]     rho = dowell_schmerge_pdf(px, py, pz, photon_energy, workfun, t, fermi_energy)     norm = np.trapezoid(np.trapezoid(np.trapezoid(rho, dx=px[1, 0, 0] - px[0, 0, 0], axis=0), dx=py[0, 1, 0] - py[0, 0, 0], axis=0), dx=pz[0, 0, 1] - pz[0, 0, 0])     px_sec_moment = np.trapezoid(np.trapezoid(np.trapezoid(px**2*rho, dx=px[1, 0, 0] - px[0, 0, 0], axis=0), dx=py[0, 1, 0] - py[0, 0, 0], axis=0), dx=pz[0, 0, 1] - pz[0, 0, 0])     return (px_sec_moment/norm)/mc2*1e3  ephoton = np.linspace(2.1, 2.9, 16) plt.plot(ephoton, (ephoton-2)/3*1e3, label='Dowell-Schmerge Formula (T=0 K)')  for temp in [0, 300, 600]:     mte = np.array([get_mte(6., temp, ep, 2.) for ep in ephoton])     plt.plot(ephoton, mte, marker='x', ls='none', label='Numerical Integral (T=%.0f K)' % temp)  plt.plot(photon_energy, 1000*P['sigma_px']**2/MC2.magnitude, 'o', label='Distgen')  plt.legend() plt.xlabel('Photon Energy (eV)') plt.ylabel('MTE (meV)') Out[11]: <pre>Text(0, 0.5, 'MTE (meV)')</pre> In\u00a0[12]: Copied! <pre>from distgen.dist import FermiDirac3StepBarrierMomentumDist\n</pre> from distgen.dist import FermiDirac3StepBarrierMomentumDist In\u00a0[13]: Copied! <pre>params = {'photon_wavelength':laser_wavelength, \n          'work_function':cathode_work_function, \n          'temperature':cathode_temperature, \n          'fermi_energy':fermi_energy}\n\ndscm = FermiDirac3StepBarrierMomentumDist(verbose=0, **params)\n</pre> params = {'photon_wavelength':laser_wavelength,            'work_function':cathode_work_function,            'temperature':cathode_temperature,            'fermi_energy':fermi_energy}  dscm = FermiDirac3StepBarrierMomentumDist(verbose=0, **params) In\u00a0[14]: Copied! <pre>from distgen.dist import random_generator\n</pre> from distgen.dist import random_generator In\u00a0[15]: Copied! <pre>n_sample = 1_000_000\nrns = random_generator( (3, n_sample), 'hammersley')\n</pre> n_sample = 1_000_000 rns = random_generator( (3, n_sample), 'hammersley') In\u00a0[16]: Copied! <pre>print(rns.shape)\n</pre> print(rns.shape) <pre>(3, 1000000)\n</pre> In\u00a0[17]: Copied! <pre>ps, phis = dscm.cdfinv(rns[0,:], rns[1,:])\nthetas = np.linspace(0, 2*np.pi, len(ps))*unit_registry('rad')\n</pre> ps, phis = dscm.cdfinv(rns[0,:], rns[1,:]) thetas = np.linspace(0, 2*np.pi, len(ps))*unit_registry('rad') In\u00a0[18]: Copied! <pre>px = ps*np.cos(thetas)*np.sin(phis)\npy = ps*np.sin(thetas)*np.sin(phis)\npz = ps*np.cos(phis)\n</pre> px = ps*np.cos(thetas)*np.sin(phis) py = ps*np.sin(thetas)*np.sin(phis) pz = ps*np.cos(phis) In\u00a0[19]: Copied! <pre>hist, xes, yes = np.histogram2d(px.magnitude, pz.magnitude, bins=200)\nxcs = (xes[:-1] + xes[1:]) / 2\nycs = (yes[:-1] + yes[1:]) / 2\n\nplt.imshow(hist.transpose(), origin='lower', extent=(xcs[0], xcs[-1], ycs[0], ycs[-1]))\nplt.xlabel('$p_x$ (eV/c)');\nplt.ylabel('$p_z$ (eV/c)');\n</pre> hist, xes, yes = np.histogram2d(px.magnitude, pz.magnitude, bins=200) xcs = (xes[:-1] + xes[1:]) / 2 ycs = (yes[:-1] + yes[1:]) / 2  plt.imshow(hist.transpose(), origin='lower', extent=(xcs[0], xcs[-1], ycs[0], ycs[-1])) plt.xlabel('$p_x$ (eV/c)'); plt.ylabel('$p_z$ (eV/c)'); In\u00a0[20]: Copied! <pre>np.mean(px**2)/MC2\n</pre> np.mean(px**2)/MC2 Out[20]:  0.16986022309479243 electron_volt/speed_of_light<sup>2</sup> In\u00a0[21]: Copied! <pre>print('estimated MTE:', 1000*P['sigma_px']**2 / MC2.magnitude, 'meV')\n</pre> print('estimated MTE:', 1000*P['sigma_px']**2 / MC2.magnitude, 'meV') <pre>estimated MTE: 169.8674510343648 meV\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/fermi_dirac_3step_barrier_photocathode_model/#fermi-dirac-3-step-barrier-momentum-distribution","title":"Fermi-Dirac 3 Step Barrier Momentum Distribution\u00b6","text":"<p>Calculates the PDF for electrons emitted from a photocathode following the model described in [1]. Shortly, electrons are initially populated in momentum space as in the Sommerfeld model. They escape over the work function barrier when their longitudinal energy is high enough and lose momentum along the direction of the surface normal to satisfy energy conservation. For the purposes of referencing in published research, this sampling concept is the same described in [2].</p> <pre><code>[1] Dowell, D. H., &amp; Schmerge, J. F. (2009). Quantum efficiency and thermal emittance of \n    metal photocathodes. Physical Review Special Topics - Accelerators and Beams, 12(7). \n    https://doi.org/10.1103/PhysRevSTAB.12.074201\n\n[2] Pierce, C. M., Durham, D. B., Riminucci, F., Dhuey, S., Bazarov, I., Maxson, J.,\n    Minor, A. M., &amp; Filippetto, D. (2023). Experimental Characterization of Photoemission\n    from Plasmonic Nanogroove Arrays. Physical Review Applied, 19(3), 034034.\n    https://doi.org/10.1103/PhysRevApplied.19.034034</code></pre>"},{"location":"examples/fermi_dirac_3step_barrier_photocathode_model/#full-distgen-example","title":"Full Distgen Example\u00b6","text":""},{"location":"examples/fermi_dirac_3step_barrier_photocathode_model/#original-implementation-courtesy-of-c-pierce","title":"Original Implementation (courtesy of C. Pierce)\u00b6","text":""},{"location":"examples/fermi_dirac_3step_barrier_photocathode_model/#internal-distgen-p-phi-distribution-object","title":"Internal Distgen |P|, $\\phi$ Distribution Object\u00b6","text":""},{"location":"examples/laser_speckle/","title":"Laser speckle","text":"In\u00a0[1]: Copied! <pre># Useful for debugging\n%load_ext autoreload\n%autoreload 2\n%config InlineBackend.figure_format = 'retina'\n</pre> # Useful for debugging %load_ext autoreload %autoreload 2 %config InlineBackend.figure_format = 'retina' In\u00a0[2]: Copied! <pre>from distgen import Generator\nfrom matplotlib import pyplot as plt\n</pre> from distgen import Generator from matplotlib import pyplot as plt In\u00a0[3]: Copied! <pre>from distgen.dist import UniformLaserSpeckle\n</pre> from distgen.dist import UniformLaserSpeckle In\u00a0[4]: Copied! <pre>params = {'min_x': '-1 mm', 'max_x': '+1 mm', 'min_y': '-2 mm', 'max_y': '+2 mm', 'sigma':10}\n          \n\nD = UniformLaserSpeckle(**params)\n</pre> params = {'min_x': '-1 mm', 'max_x': '+1 mm', 'min_y': '-2 mm', 'max_y': '+2 mm', 'sigma':10}             D = UniformLaserSpeckle(**params) In\u00a0[5]: Copied! <pre>plt.pcolormesh(D.Pxy.magnitude);\n</pre> plt.pcolormesh(D.Pxy.magnitude); In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/metrics/","title":"Metrics for comparing different distributions","text":"In\u00a0[1]: Copied! <pre># Useful for debugging\n%load_ext autoreload\n%autoreload 2\n%config InlineBackend.figure_format = 'retina'\n</pre> # Useful for debugging %load_ext autoreload %autoreload 2 %config InlineBackend.figure_format = 'retina' In\u00a0[2]: Copied! <pre>from distgen.dist import Uniform\nfrom distgen.dist import SuperGaussian\nfrom distgen.dist import Norm\nfrom distgen.physical_constants import unit_registry\n\nfrom matplotlib import pyplot as plt\n\nimport numpy as np\n</pre> from distgen.dist import Uniform from distgen.dist import SuperGaussian from distgen.dist import Norm from distgen.physical_constants import unit_registry  from matplotlib import pyplot as plt  import numpy as np In\u00a0[3]: Copied! <pre>L = 2*unit_registry('ps')\navg_t_sg = 0*unit_registry('ps')\nsigma_t_sg = L/np.sqrt(12)\n</pre> L = 2*unit_registry('ps') avg_t_sg = 0*unit_registry('ps') sigma_t_sg = L/np.sqrt(12) In\u00a0[4]: Copied! <pre>sg = SuperGaussian('t', avg_t=avg_t_sg, sigma_t=sigma_t_sg, p=12)\n</pre> sg = SuperGaussian('t', avg_t=avg_t_sg, sigma_t=sigma_t_sg, p=12) In\u00a0[5]: Copied! <pre>tsg, Psg = sg.get_x_pts(), sg.pdf()\nplt.plot(tsg, Psg);\n</pre> tsg, Psg = sg.get_x_pts(), sg.pdf() plt.plot(tsg, Psg); In\u00a0[6]: Copied! <pre>norm = Norm('t', avg_t=avg_t_sg, sigma_t=sigma_t_sg)\n</pre> norm = Norm('t', avg_t=avg_t_sg, sigma_t=sigma_t_sg) In\u00a0[7]: Copied! <pre>tn, Pn = norm.get_x_pts(), norm.pdf()\nplt.plot(tn, Pn);\n</pre> tn, Pn = norm.get_x_pts(), norm.pdf() plt.plot(tn, Pn); In\u00a0[8]: Copied! <pre>from distgen.metrics import kullback_liebler_div\n</pre> from distgen.metrics import kullback_liebler_div In\u00a0[9]: Copied! <pre>kullback_liebler_div(tn, Pn, tsg, Psg, as_float=False)\n</pre> kullback_liebler_div(tn, Pn, tsg, Psg, as_float=False) Out[9]:  4.301370109274345 dimensionless  <p>The functions work with raw NumPy arrays, and support both float output or Pint Quantity outputs:</p> In\u00a0[10]: Copied! <pre>kullback_liebler_div(tn.magnitude, Pn.magnitude, tsg.magnitude, Psg.magnitude, as_float=True)\n</pre> kullback_liebler_div(tn.magnitude, Pn.magnitude, tsg.magnitude, Psg.magnitude, as_float=True) Out[10]: <pre>np.float64(4.301370109274345)</pre> <p>In addition to the Kullback Liebler Divergence, the residual squared between two distributions is implemented:</p> In\u00a0[11]: Copied! <pre>from distgen.metrics import res2\n</pre> from distgen.metrics import res2 In\u00a0[12]: Copied! <pre>res2(tn, Pn, tsg, Psg, as_float=False, normalize=True)\n</pre> res2(tn, Pn, tsg, Psg, as_float=False, normalize=True) Out[12]:  0.11983271504891024 dimensionless  In\u00a0[13]: Copied! <pre>res2(tn.magnitude, Pn.magnitude, tsg.magnitude, Psg.magnitude, as_float=True)\n</pre> res2(tn.magnitude, Pn.magnitude, tsg.magnitude, Psg.magnitude, as_float=True) Out[13]: <pre>np.float64(0.058441901838167956)</pre> In\u00a0[14]: Copied! <pre>from distgen.metrics import resample_pq\n</pre> from distgen.metrics import resample_pq In\u00a0[15]: Copied! <pre>resample_pq(tn, Pn, tsg, Psg, plot=True);\n</pre> resample_pq(tn, Pn, tsg, Psg, plot=True); In\u00a0[16]: Copied! <pre>dist_yaml=\"\"\"\nn_particle: 30000\nspecies: electron\nr_dist:\n  truncation_fraction:\n    units: dimensionless\n    value: 0.5\n  truncation_radius:\n    units: mm\n    value: 2.3319043122\n  type: rg\nrandom_type: hammersley\nstart:\n  MTE:\n    units: meV\n    value: 130\n  type: cathode\nt_dist:\n  p:\n    units: ''\n    value: 1\n  sigma_t:\n    units: ps\n    value: 10\n  type: sg\ntotal_charge:\n  units: pC\n  value: 100\n\"\"\"\n</pre> dist_yaml=\"\"\" n_particle: 30000 species: electron r_dist:   truncation_fraction:     units: dimensionless     value: 0.5   truncation_radius:     units: mm     value: 2.3319043122   type: rg random_type: hammersley start:   MTE:     units: meV     value: 130   type: cathode t_dist:   p:     units: ''     value: 1   sigma_t:     units: ps     value: 10   type: sg total_charge:   units: pC   value: 100 \"\"\" In\u00a0[17]: Copied! <pre>from distgen import Generator\n</pre> from distgen import Generator In\u00a0[18]: Copied! <pre>D = Generator(dist_yaml)\n</pre> D = Generator(dist_yaml) In\u00a0[19]: Copied! <pre>P = D.run()\n</pre> P = D.run() In\u00a0[20]: Copied! <pre>P.plot('t')\n</pre> P.plot('t') In\u00a0[21]: Copied! <pre>from distgen.metrics import get_current_profile\nfrom distgen.metrics import rms_equivalent_current_nonuniformity\n</pre> from distgen.metrics import get_current_profile from distgen.metrics import rms_equivalent_current_nonuniformity In\u00a0[22]: Copied! <pre>t, I = get_current_profile(P)\n</pre> t, I = get_current_profile(P) In\u00a0[23]: Copied! <pre>plt.plot(t, I);\n</pre> plt.plot(t, I); In\u00a0[24]: Copied! <pre>ps = np.linspace(1, 12, 50)\n</pre> ps = np.linspace(1, 12, 50) In\u00a0[25]: Copied! <pre>kldivs = np.zeros(ps.shape)\nres2s = np.zeros(ps.shape)\n\nfor ii, p in enumerate(ps):\n    \n    D['t_dist:p']=p\n    \n    P = D.run()\n    \n    t, I = get_current_profile(P)\n    \n    plt.plot(t, I)\n    \n    kldivs[ii] = rms_equivalent_current_nonuniformity(P, method='kl_div', p=12)\n    \n    res2s[ii] = rms_equivalent_current_nonuniformity(P, method='res2')\n\nplt.xlabel('t (s)');\nplt.ylabel('$\\\\rho$ ($s^{-1}$)');\n</pre> kldivs = np.zeros(ps.shape) res2s = np.zeros(ps.shape)  for ii, p in enumerate(ps):          D['t_dist:p']=p          P = D.run()          t, I = get_current_profile(P)          plt.plot(t, I)          kldivs[ii] = rms_equivalent_current_nonuniformity(P, method='kl_div', p=12)          res2s[ii] = rms_equivalent_current_nonuniformity(P, method='res2')  plt.xlabel('t (s)'); plt.ylabel('$\\\\rho$ ($s^{-1}$)'); <p>$D_{KL} = \\int_{-\\infty}^{\\infty} P\\ln(P/Q)dt$</p> <p>Note, not defined for uniform beam where $Q_u = \\frac{1}{t_2-t_1}\\left[\\theta(t-t_1)-\\theta(t-t_2)\\right]$.  If comparing to uniform beam, replace target distribution with rms equivalent super-Gaussian with power $p$: $Q=Q_{SG}(t; p)$.  So KL-div nonuniformity:</p> <p>$\\lim_{p\\rightarrow\\infty}\\int_{-\\infty}^{\\infty} P\\ln[P/Q_{SG}(t;p)]dt$</p> In\u00a0[26]: Copied! <pre>plt.plot(ps, kldivs);\nplt.xlabel('super-Gaussian power');\nplt.ylabel('KL-Divergence');\n</pre> plt.plot(ps, kldivs); plt.xlabel('super-Gaussian power'); plt.ylabel('KL-Divergence'); <p>$\\frac{\\int_{-\\infty}^{\\infty} (P-Q)^2dt}{\\int_{-\\infty}^{\\infty} Q^2(t)dt}$</p> In\u00a0[27]: Copied! <pre>plt.plot(ps, res2s);\nplt.xlabel('super-Gaussian power');\nplt.ylabel('integrated squared residuals');\n</pre> plt.plot(ps, res2s); plt.xlabel('super-Gaussian power'); plt.ylabel('integrated squared residuals'); In\u00a0[28]: Copied! <pre>D['t_dist:p']=4\nP = D.run()\nP.plot('t')\n</pre> D['t_dist:p']=4 P = D.run() P.plot('t') In\u00a0[29]: Copied! <pre>D['t_dist:p']=6\nP = D.run()\nP.plot('t')\n</pre> D['t_dist:p']=6 P = D.run() P.plot('t') In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/metrics/#metrics-for-comparing-different-distributions","title":"Metrics for comparing different distributions\u00b6","text":"<p>In some cases, it is desired to target a particular distribution shape in an optimization.  To facilitate this the following two metrics are implemented:</p>"},{"location":"examples/metrics/#kullback-leibler-relative-entropy","title":"Kullback-Leibler (Relative Entropy)\u00b6","text":"<p>Defined as: $D_{KL}(P|Q) = \\int_{-\\infty}^{\\infty}p(x)\\ln{\\left(\\frac{p(x)}{q(x)}\\right)} dx$</p> <p>Note that this is not well defined in regions where the PDF $q(x)=0$.  This causes trouble for distributions like a uniform distribution.  For this, its suggested to use a SuperGaussian to approximate the uniform dist (see below).</p> <p>https://en.wikipedia.org/wiki/Kullback\u2013Leibler_divergence</p>"},{"location":"examples/metrics/#helper-functions","title":"Helper Functions\u00b6","text":""},{"location":"examples/parallel_distgen/","title":"Parallel distgen","text":"In\u00a0[1]: Copied! <pre># Useful for debugging\n%load_ext autoreload\n%autoreload 2\n%config InlineBackend.figure_format = 'retina'\n</pre> # Useful for debugging %load_ext autoreload %autoreload 2 %config InlineBackend.figure_format = 'retina' In\u00a0[2]: Copied! <pre>from distgen import Generator\n\nimport numpy as np\nfrom time import time\nfrom matplotlib import pyplot as plt\n</pre> from distgen import Generator  import numpy as np from time import time from matplotlib import pyplot as plt In\u00a0[3]: Copied! <pre>G = Generator('data/rad.gaussian.in.yaml', verbose=1)\n</pre> G = Generator('data/rad.gaussian.in.yaml', verbose=1) In\u00a0[4]: Copied! <pre>G.run()\n</pre> G.run() <pre>Distribution format: gpt\nOutput file: rad.gaussian.out.txt\n\nCreating beam distribution....\n   Beam starting from: cathode\n   Total charge: 10 pC.\n   Number of macroparticles: 200000.\n   Assuming cylindrical symmetry...\n   r distribution: radial Gaussian\n   theta distribution: uniform theta\n      min_theta = 0 rad, max_theta = 6.28319 rad\n   t distribution: uniform\n      min_t = -2 ps, max_t = 2 ps\n   px distribution: Gaussian\n      avg_px = 0 eV/c, sigma_px = 276.857 eV/c\n   py distribution: Gaussian\n      avg_py = 0 eV/c, sigma_py = 276.857 eV/c\n   pz distribution: Gaussian\n      avg_pz = 0 eV/c, sigma_pz = 276.857 eV/c\n   Shifting avg_x = -7.82345E-05 mm -&gt; 0 mm\n   Scaling sigma_x = 1.99984 mm -&gt; 2 mm\n   Shifting avg_y = -1.09911E-05 mm -&gt; 0 mm\n   Scaling sigma_y = 1.99994 mm -&gt; 2 mm\n   Shifting avg_px = -0.0212516 eV/c -&gt; 0 eV/c\n   Scaling sigma_px = 276.849 eV/c -&gt; 276.857 eV/c\n   Shifting avg_py = -0.0259627 eV/c -&gt; 0 eV/c\n   Scaling sigma_py = 276.844 eV/c -&gt; 276.857 eV/c\n   Shifting avg_pz = -0.0372953 eV/c -&gt; 0 eV/c\n   Scaling sigma_pz = 276.843 eV/c -&gt; 276.857 eV/c\n   Shifting avg_t = -4.90022E-05 ps -&gt; 0 ps\n   Scaling sigma_t = 1.1547 ps -&gt; 1.1547 ps\n   Cathode start: fixing pz momenta to forward hemisphere\n      avg_pz -&gt; 220.904 eV/c, sigma_pz -&gt; 166.887 eV/c\n...done. Time Elapsed: 755.348 ms.\n\n   Created particles in .particles: \n   ParticleGroup with 200000 particles with total charge 1.0000000000000003e-11 C\n</pre> Out[4]: <pre>&lt;ParticleGroup with 200000 particles at 0x16bfde850&gt;</pre> In\u00a0[5]: Copied! <pre>G['n_particle']=10_000_000\n</pre> G['n_particle']=10_000_000 In\u00a0[6]: Copied! <pre>G.run(max_workers=10)\n</pre> G.run(max_workers=10) <pre>Creating particles in parallel with 10 workers\n   Setting up workers...done.\n   Executing worker tasks...done\n   Collecting beamlets...   Created particles in .particles: \n   ParticleGroup with 10000000 particles with total charge 1.0000000000000125e-11 C\n</pre> Out[6]: <pre>&lt;ParticleGroup with 10000000 particles at 0x16b7c2f10&gt;</pre> In\u00a0[7]: Copied! <pre>n_particles = [100, 1_000, 10_000, 100_000, 1_000_000, 10_000_000, 25_000_000, 50_000_000]#, 100_000_000]\n</pre> n_particles = [100, 1_000, 10_000, 100_000, 1_000_000, 10_000_000, 25_000_000, 50_000_000]#, 100_000_000] In\u00a0[8]: Copied! <pre>s_times = []\n\nfor n_part in n_particles:\n\n    G['n_particle'] = n_part\n\n    # Run in serial:\n    ts0 = time()\n    G.run()\n    ts1 = time()\n\n    s_times.append(ts1-ts0)\n</pre> s_times = []  for n_part in n_particles:      G['n_particle'] = n_part      # Run in serial:     ts0 = time()     G.run()     ts1 = time()      s_times.append(ts1-ts0)       <pre>Distribution format: gpt\nOutput file: rad.gaussian.out.txt\n\nCreating beam distribution....\n   Beam starting from: cathode\n   Total charge: 10 pC.\n   Number of macroparticles: 100.\n   Assuming cylindrical symmetry...\n   r distribution: radial Gaussian\n   theta distribution: uniform theta\n      min_theta = 0 rad, max_theta = 6.28319 rad\n   t distribution: uniform\n      min_t = -2 ps, max_t = 2 ps\n   px distribution: Gaussian\n      avg_px = 0 eV/c, sigma_px = 276.857 eV/c\n   py distribution: Gaussian\n      avg_py = 0 eV/c, sigma_py = 276.857 eV/c\n   pz distribution: Gaussian\n      avg_pz = 0 eV/c, sigma_pz = 276.857 eV/c\n   Shifting avg_x = -0.0128692 mm -&gt; 0 mm\n   Scaling sigma_x = 1.98551 mm -&gt; 2 mm\n   Shifting avg_y = -0.00373924 mm -&gt; 0 mm\n   Scaling sigma_y = 1.96499 mm -&gt; 2 mm\n   Shifting avg_px = -5.75344 eV/c -&gt; 0 eV/c\n   Scaling sigma_px = 267.468 eV/c -&gt; 276.857 eV/c\n   Shifting avg_py = -6.91735 eV/c -&gt; 0 eV/c\n   Scaling sigma_py = 274.758 eV/c -&gt; 276.857 eV/c\n   Shifting avg_pz = -5.61571 eV/c -&gt; 0 eV/c\n   Scaling sigma_pz = 263.769 eV/c -&gt; 276.857 eV/c\n   Shifting avg_t = -0.0329218 ps -&gt; 0 ps\n   Scaling sigma_t = 1.15829 ps -&gt; 1.1547 ps\n   Cathode start: fixing pz momenta to forward hemisphere\n      avg_pz -&gt; 226.104 eV/c, sigma_pz -&gt; 159.771 eV/c\n...done. Time Elapsed: 17.3788 ms.\n\n   Created particles in .particles: \n   ParticleGroup with 100 particles with total charge 1e-11 C\nDistribution format: gpt\nOutput file: rad.gaussian.out.txt\n\nCreating beam distribution....\n   Beam starting from: cathode\n   Total charge: 10 pC.\n   Number of macroparticles: 1000.\n   Assuming cylindrical symmetry...\n   r distribution: radial Gaussian\n   theta distribution: uniform theta\n      min_theta = 0 rad, max_theta = 6.28319 rad\n   t distribution: uniform\n      min_t = -2 ps, max_t = 2 ps\n   px distribution: Gaussian\n      avg_px = 0 eV/c, sigma_px = 276.857 eV/c\n   py distribution: Gaussian\n      avg_py = 0 eV/c, sigma_py = 276.857 eV/c\n   pz distribution: Gaussian\n      avg_pz = 0 eV/c, sigma_pz = 276.857 eV/c\n   Shifting avg_x = -0.00349168 mm -&gt; 0 mm\n   Scaling sigma_x = 1.99119 mm -&gt; 2 mm\n   Shifting avg_y = -0.0017992 mm -&gt; 0 mm\n   Scaling sigma_y = 1.99479 mm -&gt; 2 mm\n   Shifting avg_px = -2.08758 eV/c -&gt; 0 eV/c\n   Scaling sigma_px = 276.15 eV/c -&gt; 276.857 eV/c\n   Shifting avg_py = -2.20483 eV/c -&gt; 0 eV/c\n   Scaling sigma_py = 275.013 eV/c -&gt; 276.857 eV/c\n   Shifting avg_pz = -2.66491 eV/c -&gt; 0 eV/c\n   Scaling sigma_pz = 274.96 eV/c -&gt; 276.857 eV/c\n   Shifting avg_t = -0.00602835 ps -&gt; 0 ps\n   Scaling sigma_t = 1.15477 ps -&gt; 1.1547 ps\n   Cathode start: fixing pz momenta to forward hemisphere\n      avg_pz -&gt; 221.563 eV/c, sigma_pz -&gt; 166.011 eV/c\n...done. Time Elapsed: 17.314 ms.\n\n   Created particles in .particles: \n   ParticleGroup with 1000 particles with total charge 1e-11 C\nDistribution format: gpt\nOutput file: rad.gaussian.out.txt\n\nCreating beam distribution....\n   Beam starting from: cathode\n   Total charge: 10 pC.\n   Number of macroparticles: 10000.\n   Assuming cylindrical symmetry...\n   r distribution: radial Gaussian\n   theta distribution: uniform theta\n      min_theta = 0 rad, max_theta = 6.28319 rad\n   t distribution: uniform\n      min_t = -2 ps, max_t = 2 ps\n   px distribution: Gaussian\n      avg_px = 0 eV/c, sigma_px = 276.857 eV/c\n   py distribution: Gaussian\n      avg_py = 0 eV/c, sigma_py = 276.857 eV/c\n   pz distribution: Gaussian\n      avg_pz = 0 eV/c, sigma_pz = 276.857 eV/c\n   Shifting avg_x = -0.00102054 mm -&gt; 0 mm\n   Scaling sigma_x = 1.99758 mm -&gt; 2 mm\n   Shifting avg_y = -0.000286803 mm -&gt; 0 mm\n   Scaling sigma_y = 1.99973 mm -&gt; 2 mm\n   Shifting avg_px = -0.256036 eV/c -&gt; 0 eV/c\n   Scaling sigma_px = 276.783 eV/c -&gt; 276.857 eV/c\n   Shifting avg_py = -0.399525 eV/c -&gt; 0 eV/c\n   Scaling sigma_py = 276.803 eV/c -&gt; 276.857 eV/c\n   Shifting avg_pz = -0.618933 eV/c -&gt; 0 eV/c\n   Scaling sigma_pz = 276.58 eV/c -&gt; 276.857 eV/c\n   Shifting avg_t = -0.000807357 ps -&gt; 0 ps\n   Scaling sigma_t = 1.15467 ps -&gt; 1.1547 ps\n   Cathode start: fixing pz momenta to forward hemisphere\n      avg_pz -&gt; 221.023 eV/c, sigma_pz -&gt; 166.729 eV/c\n...done. Time Elapsed: 49.3639 ms.\n\n   Created particles in .particles: \n   ParticleGroup with 10000 particles with total charge 1.0000000000000003e-11 C\nDistribution format: gpt\nOutput file: rad.gaussian.out.txt\n\nCreating beam distribution....\n   Beam starting from: cathode\n   Total charge: 10 pC.\n   Number of macroparticles: 100000.\n   Assuming cylindrical symmetry...\n   r distribution: radial Gaussian\n   theta distribution: uniform theta\n      min_theta = 0 rad, max_theta = 6.28319 rad\n   t distribution: uniform\n      min_t = -2 ps, max_t = 2 ps\n   px distribution: Gaussian\n      avg_px = 0 eV/c, sigma_px = 276.857 eV/c\n   py distribution: Gaussian\n      avg_py = 0 eV/c, sigma_py = 276.857 eV/c\n   pz distribution: Gaussian\n      avg_pz = 0 eV/c, sigma_pz = 276.857 eV/c\n   Shifting avg_x = -0.000144205 mm -&gt; 0 mm\n   Scaling sigma_x = 1.99971 mm -&gt; 2 mm\n   Shifting avg_y = -2.14199E-05 mm -&gt; 0 mm\n   Scaling sigma_y = 1.99989 mm -&gt; 2 mm\n   Shifting avg_px = -0.0379046 eV/c -&gt; 0 eV/c\n   Scaling sigma_px = 276.852 eV/c -&gt; 276.857 eV/c\n   Shifting avg_py = -0.0437018 eV/c -&gt; 0 eV/c\n   Scaling sigma_py = 276.825 eV/c -&gt; 276.857 eV/c\n   Shifting avg_pz = -0.06805 eV/c -&gt; 0 eV/c\n   Scaling sigma_pz = 276.827 eV/c -&gt; 276.857 eV/c\n   Shifting avg_t = -9.00043E-05 ps -&gt; 0 ps\n   Scaling sigma_t = 1.1547 ps -&gt; 1.1547 ps\n   Cathode start: fixing pz momenta to forward hemisphere\n      avg_pz -&gt; 220.913 eV/c, sigma_pz -&gt; 166.875 eV/c\n...done. Time Elapsed: 380.883 ms.\n\n   Created particles in .particles: \n   ParticleGroup with 100000 particles with total charge 1.0000000000000003e-11 C\nDistribution format: gpt\nOutput file: rad.gaussian.out.txt\n\nCreating beam distribution....\n   Beam starting from: cathode\n   Total charge: 10 pC.\n   Number of macroparticles: 1000000.\n   Assuming cylindrical symmetry...\n   r distribution: radial Gaussian\n   theta distribution: uniform theta\n      min_theta = 0 rad, max_theta = 6.28319 rad\n   t distribution: uniform\n      min_t = -2 ps, max_t = 2 ps\n   px distribution: Gaussian\n      avg_px = 0 eV/c, sigma_px = 276.857 eV/c\n   py distribution: Gaussian\n      avg_py = 0 eV/c, sigma_py = 276.857 eV/c\n   pz distribution: Gaussian\n      avg_pz = 0 eV/c, sigma_pz = 276.857 eV/c\n   Shifting avg_x = -1.5856E-05 mm -&gt; 0 mm\n   Scaling sigma_x = 1.99996 mm -&gt; 2 mm\n   Shifting avg_y = -2.52974E-06 mm -&gt; 0 mm\n   Scaling sigma_y = 1.99999 mm -&gt; 2 mm\n   Shifting avg_px = -0.00462116 eV/c -&gt; 0 eV/c\n   Scaling sigma_px = 276.855 eV/c -&gt; 276.857 eV/c\n   Shifting avg_py = -0.00944177 eV/c -&gt; 0 eV/c\n   Scaling sigma_py = 276.855 eV/c -&gt; 276.857 eV/c\n   Shifting avg_pz = -0.0119469 eV/c -&gt; 0 eV/c\n   Scaling sigma_pz = 276.855 eV/c -&gt; 276.857 eV/c\n   Shifting avg_t = -1.09788E-05 ps -&gt; 0 ps\n   Scaling sigma_t = 1.1547 ps -&gt; 1.1547 ps\n   Cathode start: fixing pz momenta to forward hemisphere\n      avg_pz -&gt; 220.901 eV/c, sigma_pz -&gt; 166.891 eV/c\n...done. Time Elapsed: 3.7998 s.\n\n   Created particles in .particles: \n   ParticleGroup with 1000000 particles with total charge 9.99999999999998e-12 C\nDistribution format: gpt\nOutput file: rad.gaussian.out.txt\n\nCreating beam distribution....\n   Beam starting from: cathode\n   Total charge: 10 pC.\n   Number of macroparticles: 10000000.\n   Assuming cylindrical symmetry...\n   r distribution: radial Gaussian\n   theta distribution: uniform theta\n      min_theta = 0 rad, max_theta = 6.28319 rad\n   t distribution: uniform\n      min_t = -2 ps, max_t = 2 ps\n   px distribution: Gaussian\n      avg_px = 0 eV/c, sigma_px = 276.857 eV/c\n   py distribution: Gaussian\n      avg_py = 0 eV/c, sigma_py = 276.857 eV/c\n   pz distribution: Gaussian\n      avg_pz = 0 eV/c, sigma_pz = 276.857 eV/c\n   Shifting avg_x = -2.57762E-06 mm -&gt; 0 mm\n   Scaling sigma_x = 1.99999 mm -&gt; 2 mm\n   Shifting avg_y = -4.00986E-07 mm -&gt; 0 mm\n   Scaling sigma_y = 2 mm -&gt; 2 mm\n   Shifting avg_px = -0.000374215 eV/c -&gt; 0 eV/c\n   Scaling sigma_px = 276.857 eV/c -&gt; 276.857 eV/c\n   Shifting avg_py = -0.000600273 eV/c -&gt; 0 eV/c\n   Scaling sigma_py = 276.857 eV/c -&gt; 276.857 eV/c\n   Shifting avg_pz = -0.00104701 eV/c -&gt; 0 eV/c\n   Scaling sigma_pz = 276.857 eV/c -&gt; 276.857 eV/c\n   Shifting avg_t = -1.23261E-06 ps -&gt; 0 ps\n   Scaling sigma_t = 1.1547 ps -&gt; 1.1547 ps\n   Cathode start: fixing pz momenta to forward hemisphere\n      avg_pz -&gt; 220.9 eV/c, sigma_pz -&gt; 166.892 eV/c\n...done. Time Elapsed: 39.5581 s.\n\n   Created particles in .particles: \n   ParticleGroup with 10000000 particles with total charge 1.0000000000000125e-11 C\nDistribution format: gpt\nOutput file: rad.gaussian.out.txt\n\nCreating beam distribution....\n   Beam starting from: cathode\n   Total charge: 10 pC.\n   Number of macroparticles: 25000000.\n   Assuming cylindrical symmetry...\n   r distribution: radial Gaussian\n   theta distribution: uniform theta\n      min_theta = 0 rad, max_theta = 6.28319 rad\n   t distribution: uniform\n      min_t = -2 ps, max_t = 2 ps\n   px distribution: Gaussian\n      avg_px = 0 eV/c, sigma_px = 276.857 eV/c\n   py distribution: Gaussian\n      avg_py = 0 eV/c, sigma_py = 276.857 eV/c\n   pz distribution: Gaussian\n      avg_pz = 0 eV/c, sigma_pz = 276.857 eV/c\n   Shifting avg_x = -9.28673E-07 mm -&gt; 0 mm\n   Scaling sigma_x = 2 mm -&gt; 2 mm\n   Shifting avg_y = -8.4613E-08 mm -&gt; 0 mm\n   Scaling sigma_y = 2 mm -&gt; 2 mm\n   Shifting avg_px = -0.000211406 eV/c -&gt; 0 eV/c\n   Scaling sigma_px = 276.857 eV/c -&gt; 276.857 eV/c\n   Shifting avg_py = -0.000548 eV/c -&gt; 0 eV/c\n   Scaling sigma_py = 276.857 eV/c -&gt; 276.857 eV/c\n   Shifting avg_pz = -0.000557315 eV/c -&gt; 0 eV/c\n   Scaling sigma_pz = 276.857 eV/c -&gt; 276.857 eV/c\n   Shifting avg_t = -5.15499E-07 ps -&gt; 0 ps\n   Scaling sigma_t = 1.1547 ps -&gt; 1.1547 ps\n   Cathode start: fixing pz momenta to forward hemisphere\n      avg_pz -&gt; 220.9 eV/c, sigma_pz -&gt; 166.892 eV/c\n...done. Time Elapsed: 99.0978 s.\n\n   Created particles in .particles: \n   ParticleGroup with 25000000 particles with total charge 9.999999999999536e-12 C\nDistribution format: gpt\nOutput file: rad.gaussian.out.txt\n\nCreating beam distribution....\n   Beam starting from: cathode\n   Total charge: 10 pC.\n   Number of macroparticles: 50000000.\n   Assuming cylindrical symmetry...\n   r distribution: radial Gaussian\n   theta distribution: uniform theta\n      min_theta = 0 rad, max_theta = 6.28319 rad\n   t distribution: uniform\n      min_t = -2 ps, max_t = 2 ps\n   px distribution: Gaussian\n      avg_px = 0 eV/c, sigma_px = 276.857 eV/c\n   py distribution: Gaussian\n      avg_py = 0 eV/c, sigma_py = 276.857 eV/c\n   pz distribution: Gaussian\n      avg_pz = 0 eV/c, sigma_pz = 276.857 eV/c\n   Shifting avg_x = -4.81676E-07 mm -&gt; 0 mm\n   Scaling sigma_x = 2 mm -&gt; 2 mm\n   Shifting avg_y = -4.29885E-08 mm -&gt; 0 mm\n   Scaling sigma_y = 2 mm -&gt; 2 mm\n   Shifting avg_px = -7.96742E-05 eV/c -&gt; 0 eV/c\n   Scaling sigma_px = 276.857 eV/c -&gt; 276.857 eV/c\n   Shifting avg_py = -0.000206235 eV/c -&gt; 0 eV/c\n   Scaling sigma_py = 276.857 eV/c -&gt; 276.857 eV/c\n   Shifting avg_pz = -0.000326574 eV/c -&gt; 0 eV/c\n   Scaling sigma_pz = 276.857 eV/c -&gt; 276.857 eV/c\n   Shifting avg_t = -2.78483E-07 ps -&gt; 0 ps\n   Scaling sigma_t = 1.1547 ps -&gt; 1.1547 ps\n   Cathode start: fixing pz momenta to forward hemisphere\n      avg_pz -&gt; 220.9 eV/c, sigma_pz -&gt; 166.892 eV/c\n...done. Time Elapsed: 198.729 s.\n\n   Created particles in .particles: \n   ParticleGroup with 50000000 particles with total charge 1.0000000000000699e-11 C\n</pre> In\u00a0[9]: Copied! <pre>p_times = []\n\nfor n_part in n_particles:\n\n    G['n_particle'] = n_part\n\n    # Run in serial:\n    ts0 = time()\n    G.run(max_workers=10)\n    ts1 = time()\n    \n\n    p_times.append(ts1-ts0)\n</pre> p_times = []  for n_part in n_particles:      G['n_particle'] = n_part      # Run in serial:     ts0 = time()     G.run(max_workers=10)     ts1 = time()           p_times.append(ts1-ts0) <pre>Creating particles in parallel with 10 workers\n   Setting up workers...done.\n   Executing worker tasks...done\n   Collecting beamlets...   Created particles in .particles: \n   ParticleGroup with 100 particles with total charge 1e-11 C\nCreating particles in parallel with 10 workers\n   Setting up workers...done.\n   Executing worker tasks...done\n   Collecting beamlets...   Created particles in .particles: \n   ParticleGroup with 1000 particles with total charge 1e-11 C\nCreating particles in parallel with 10 workers\n   Setting up workers...done.\n   Executing worker tasks...done\n   Collecting beamlets...   Created particles in .particles: \n   ParticleGroup with 10000 particles with total charge 1.0000000000000003e-11 C\nCreating particles in parallel with 10 workers\n   Setting up workers...done.\n   Executing worker tasks...done\n   Collecting beamlets...   Created particles in .particles: \n   ParticleGroup with 100000 particles with total charge 1.0000000000000003e-11 C\nCreating particles in parallel with 10 workers\n   Setting up workers...done.\n   Executing worker tasks...done\n   Collecting beamlets...   Created particles in .particles: \n   ParticleGroup with 1000000 particles with total charge 9.99999999999998e-12 C\nCreating particles in parallel with 10 workers\n   Setting up workers...done.\n   Executing worker tasks...done\n   Collecting beamlets...   Created particles in .particles: \n   ParticleGroup with 10000000 particles with total charge 1.0000000000000125e-11 C\nCreating particles in parallel with 10 workers\n   Setting up workers...done.\n   Executing worker tasks...done\n   Collecting beamlets...   Created particles in .particles: \n   ParticleGroup with 25000000 particles with total charge 9.999999999999536e-12 C\nCreating particles in parallel with 10 workers\n   Setting up workers...done.\n   Executing worker tasks...done\n   Collecting beamlets...   Created particles in .particles: \n   ParticleGroup with 50000000 particles with total charge 1.0000000000000699e-11 C\n</pre> In\u00a0[10]: Copied! <pre>plt.loglog(n_particles, s_times)\nplt.semilogx(n_particles, p_times)\nplt.xlabel('n_particle')\nplt.ylabel('time (sec)')\nplt.legend(['series', 'parallel, 10 workers'])\n</pre> plt.loglog(n_particles, s_times) plt.semilogx(n_particles, p_times) plt.xlabel('n_particle') plt.ylabel('time (sec)') plt.legend(['series', 'parallel, 10 workers']) Out[10]: <pre>&lt;matplotlib.legend.Legend at 0x7188d02b0&gt;</pre> In\u00a0[11]: Copied! <pre>G = Generator('data/rad.gaussian.in.yaml', verbose=0)\nG['n_particle'] = 100\n\npgs = [G.run() for ii in range(10)]\n</pre> G = Generator('data/rad.gaussian.in.yaml', verbose=0) G['n_particle'] = 100  pgs = [G.run() for ii in range(10)] In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/species/","title":"Species","text":"In\u00a0[1]: Copied! <pre>from distgen.physical_constants import PHYSICAL_CONSTANTS\n</pre> from distgen.physical_constants import PHYSICAL_CONSTANTS In\u00a0[2]: Copied! <pre>PHYSICAL_CONSTANTS._species_data['H2+']\n</pre> PHYSICAL_CONSTANTS._species_data['H2+'] Out[2]: <pre>{'description': 'ionized hydrogen molecule',\n 'charge': &lt;Quantity(1.60217663e-19, 'coulomb')&gt;,\n 'mass': &lt;Quantity(3.34615479e-27, 'kilogram')&gt;,\n 'mc2': &lt;Quantity(1.87705518e+09, 'electron_volt')&gt;}</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/spin/","title":"Spin","text":"In\u00a0[1]: Copied! <pre>from distgen import Generator\n\nimport numpy as np\n\n%load_ext autoreload\n%autoreload 2\n%config InlineBackend.figure_format = 'retina'\n</pre> from distgen import Generator  import numpy as np  %load_ext autoreload %autoreload 2 %config InlineBackend.figure_format = 'retina' In\u00a0[2]: Copied! <pre>D = Generator('data/gaussian.in.yaml', verbose=1)\nD['n_particle']=1000\n</pre> D = Generator('data/gaussian.in.yaml', verbose=1) D['n_particle']=1000 In\u00a0[3]: Copied! <pre>B = D.beam()\n</pre> B = D.beam() <pre>Distribution format: None\n   Warning: no output file specified, defaulting to \"None\".\nOutput file: None\n\nCreating beam distribution....\n   Beam starting from: time\n   Total charge: 10 pC.\n   Number of macroparticles: 1000.\n   Assuming cylindrical symmetry...\n   Assuming longitudinally polarized electrons...\n   r distribution: radial Gaussian\n   theta distribution: uniform theta\n      min_theta = 0 rad, max_theta = 6.28319 rad\nuniform theta\n      min_theta = 0 rad, max_theta = 6.28319 rad\n   px distribution: Gaussian\n      avg_px = 0 keV/c, sigma_px = 1.000 keV/c\n   py distribution: Gaussian\n      avg_py = 0 keV/c, sigma_py = 1.000 keV/c\n   pz distribution: Gaussian\n      avg_pz = 0 GeV/c, sigma_pz = 1.000 MeV/c\n   z distribution: Gaussian\n      avg_z = 0 mm, sigma_z = 2.000 mm\n   Shifting avg_x = -6.09445E-05 mm -&gt; 0 mm\n   Scaling sigma_x = 0.992078 mm -&gt; 1 mm\n   Shifting avg_y = -0.000934224 mm -&gt; 0 mm\n   Scaling sigma_y = 0.997564 mm -&gt; 1 mm\n   Shifting avg_z = -0.0220143 mm -&gt; 0 mm\n   Scaling sigma_z = 1.98865 mm -&gt; 2 mm\n   Shifting avg_px = -0.00212876 keV/c -&gt; 0 keV/c\n   Scaling sigma_px = 0.992484 keV/c -&gt; 1 keV/c\n   Shifting avg_py = -0.00796779 keV/c -&gt; 0 keV/c\n   Scaling sigma_py = 0.997902 keV/c -&gt; 1 keV/c\n   Shifting avg_pz = -7.43475E-06 GeV/c -&gt; 0 GeV/c\n   Scaling sigma_pz = 0.000997448 GeV/c -&gt; 1 MeV/c\n   Time start: fixing all particle time values to start time: 0 s.\n      Setting avg_t -&gt; 0 s.\n...done. Time Elapsed: 31.3709 ms.\n\n</pre> In\u00a0[4]: Copied! <pre>np.sum(B.sz) / np.sum(np.abs(B.sz))\n</pre> np.sum(B.sz) / np.sum(np.abs(B.sz)) Out[4]:  0.35000000000000003 dimensionless  In\u00a0[5]: Copied! <pre>B.sx.mean(), B.sy.mean(), B.s2.mean(), B.s2.std()\n</pre> B.sx.mean(), B.sy.mean(), B.s2.mean(), B.s2.std() Out[5]: <pre>(&lt;Quantity(-0.39458226, 'nanometer * electron_volt / speed_of_light')&gt;,\n &lt;Quantity(0.097855922, 'nanometer * electron_volt / speed_of_light')&gt;,\n &lt;Quantity(29203.4529, 'nanometer ** 2 * electron_volt ** 2 / speed_of_light ** 2')&gt;,\n &lt;Quantity(8.34676344e-12, 'nanometer ** 2 * electron_volt ** 2 / speed_of_light ** 2')&gt;)</pre> In\u00a0[6]: Copied! <pre>B.s2[0]\n</pre> B.s2[0] Out[6]:  29203.452877102412 electron_volt<sup>2</sup> nanometer<sup>2</sup>/speed_of_light<sup>2</sup> In\u00a0[7]: Copied! <pre>B.spin_polarization()\n</pre> B.spin_polarization() Out[7]:  0.35000000000000003 dimensionless  In\u00a0[8]: Copied! <pre>B.g_factor[0]\n</pre> B.g_factor[0] Out[8]:  -2.00231930436256 dimensionless  In\u00a0[9]: Copied! <pre>from distgen.writers import write_gpt\n</pre> from distgen.writers import write_gpt In\u00a0[10]: Copied! <pre>write_gpt(B, 'test.spin.gdf', verbose=1, asci2gdf_bin='$ASCI2GDF_BIN')\n</pre> write_gpt(B, 'test.spin.gdf', verbose=1, asci2gdf_bin='$ASCI2GDF_BIN') <pre>Printing 1000 particles to \"test.spin.gdf\":    Converting file to GDF: done. Time ellapsed: 3.0508 ms.\n...done. Time ellapsed: 19.8374 ms.\n</pre> <pre>sh: 1: -o: not found\n</pre> In\u00a0[11]: Copied! <pre>print(D)\n</pre> print(D) <pre>&lt;disgten.Generator with input: \nn_particle: 1000\noutput:\n  type: null\npx_dist:\n  sigma_px:\n    units: kiloelectron_volt / speed_of_light\n    value: 1.0\n  type: gaussian\npy_dist:\n  sigma_py:\n    units: kiloelectron_volt / speed_of_light\n    value: 1.0\n  type: gaussian\npz_dist:\n  avg_pz:\n    units: gigaelectron_volt / speed_of_light\n    value: 0.0\n  sigma_pz:\n    units: megaelectron_volt / speed_of_light\n    value: 1.0\n  type: gaussian\nr_dist:\n  sigma_xy:\n    units: millimeter\n    value: 1.0\n  type: radial_gaussian\nrandom:\n  type: hammersley\nspecies: electron\nspin_polarization: 0.35\nstart:\n  tstart:\n    units: second\n    value: 0\n  type: time\ntotal_charge:\n  units: picocoulomb\n  value: 10\ntransforms: null\nz_dist:\n  avg_z:\n    units: millimeter\n    value: 0.0\n  sigma_z:\n    units: millimeter\n    value: 2.0\n  type: gaussian\n\n&gt;\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/spin/#spin","title":"Spin\u00b6","text":""},{"location":"examples/surface_emitter/","title":"Surface emitter","text":"In\u00a0[1]: Copied! <pre># Useful for debugging\n%load_ext autoreload\n%autoreload 2\n%config InlineBackend.figure_format = 'retina'\n\nimport os\nimport yaml\nimport numpy as np\n</pre> # Useful for debugging %load_ext autoreload %autoreload 2 %config InlineBackend.figure_format = 'retina'  import os import yaml import numpy as np In\u00a0[2]: Copied! <pre>from distgen import Generator\n</pre> from distgen import Generator In\u00a0[3]: Copied! <pre>input_yaml = \"\"\"\nn_particle: 100000\nspecies: electron\nstart: \n  type: free\nrandom:\n  type: hammersley\ntotal_charge:\n  units: pC\n  value: 10\nr_dist:\n  max_r:\n    units: mm\n    value: 1\n  type: radial_uniform\np_dist:\n  sigma_p:\n    value: 1\n    units: eV/c\n  avg_p: \n    value: 100\n    units: eV/c\n  type: gaussian\n\"\"\"\n</pre> input_yaml = \"\"\" n_particle: 100000 species: electron start:    type: free random:   type: hammersley total_charge:   units: pC   value: 10 r_dist:   max_r:     units: mm     value: 1   type: radial_uniform p_dist:   sigma_p:     value: 1     units: eV/c   avg_p:      value: 100     units: eV/c   type: gaussian \"\"\" In\u00a0[4]: Copied! <pre>gen = Generator(input_yaml, verbose=True)\n</pre> gen = Generator(input_yaml, verbose=True) In\u00a0[5]: Copied! <pre>P = gen.run()\n</pre> P = gen.run() <pre>Distribution format: None\n   Warning: no output file specified, defaulting to \"None\".\nOutput file: None\n\nCreating beam distribution....\n   Beam starting from: free\n   Total charge: 10 pC.\n   Number of macroparticles: 100000.\n   Assuming cylindrical symmetry...\n   r distribution: radial uniform\n      min_r = 0 mm, max_r = 1 mm\n   theta distribution: uniform theta\n      min_theta = 0 rad, max_theta = 6.28319 rad\n   p distribution: Gaussian\n      avg_p = 100 eV/c, sigma_p = 1.000 eV/c\n   azimuthal angle distribution: uniform theta\n      min_theta = 0 rad, max_theta = 6.28319 rad\n   polar angle distribution: uniform phi\n      min_phi = 0 rad, max_phi = 3.14159 rad\n   Shifting avg_x = -4.85224E-08 mm -&gt; 0 mm\n   Scaling sigma_x = 0.499991 mm -&gt; 0.5 mm\n   Shifting avg_y = 1.44675E-06 mm -&gt; 0 mm\n   Scaling sigma_y = 0.49999 mm -&gt; 0.5 mm\n   Shifting avg_px = -3.3074E-05 eV/c -&gt; -6.12323E-15 eV/c\n   Scaling sigma_px = 57.7382 eV/c -&gt; 57.7379 eV/c\n   Shifting avg_py = 1.54491E-06 eV/c -&gt; 0 eV/c\n   Scaling sigma_py = 57.7382 eV/c -&gt; 57.7379 eV/c\n   Shifting avg_pz = -0.000118434 eV/c -&gt; 6.12323E-15 eV/c\n   Scaling sigma_pz = 57.7372 eV/c -&gt; 57.7379 eV/c\n...done. Time Elapsed: 101.316 ms.\n\n   Created particles in .particles: \n   ParticleGroup with 100000 particles with total charge 1.0000000000000003e-11 C\n</pre> In\u00a0[6]: Copied! <pre>P.plot('p')\n</pre> P.plot('p') In\u00a0[7]: Copied! <pre>P.plot('x', 'px')\n</pre> P.plot('x', 'px') In\u00a0[8]: Copied! <pre>P.plot('pz')\n</pre> P.plot('pz') In\u00a0[9]: Copied! <pre>P.plot('px')\n</pre> P.plot('px') In\u00a0[10]: Copied! <pre>P.plot('py')\n</pre> P.plot('py') In\u00a0[11]: Copied! <pre>from matplotlib import pyplot as plt\nfig = plt.figure()\nax = fig.add_subplot(projection='3d')\n\npx, py, pz = P['px'], P['py'], P['pz']\n\np = np.sqrt(px**2 + py**2 + pz**2)\n\ntheta = np.arctan2(py, px)\nphi = np.arccos(pz/p)\nhist, pedges = np.histogram(phi, bins=100, density=True)\npcs = (pedges[1:] + pedges[:-1]) / 2\n\nx = px/p\ny = py/p\nz = pz/p\n\nax.scatter(x[::200], y[::200], z[::200], '.');\nax.set_xlabel(r'$\\hat{p}_x$')\nax.set_ylabel(r'$\\hat{p}_y$')\nax.set_zlabel(r'$\\hat{p}_z$')\n</pre> from matplotlib import pyplot as plt fig = plt.figure() ax = fig.add_subplot(projection='3d')  px, py, pz = P['px'], P['py'], P['pz']  p = np.sqrt(px**2 + py**2 + pz**2)  theta = np.arctan2(py, px) phi = np.arccos(pz/p) hist, pedges = np.histogram(phi, bins=100, density=True) pcs = (pedges[1:] + pedges[:-1]) / 2  x = px/p y = py/p z = pz/p  ax.scatter(x[::200], y[::200], z[::200], '.'); ax.set_xlabel(r'$\\hat{p}_x$') ax.set_ylabel(r'$\\hat{p}_y$') ax.set_zlabel(r'$\\hat{p}_z$') Out[11]: <pre>Text(0.5, 0, '$\\\\hat{p}_z$')</pre> In\u00a0[12]: Copied! <pre>theta = np.arctan2(py, px)\nphi = np.arccos(pz/p)\nhist, pedges = np.histogram(phi, bins=100, density=True)\npcs = (pedges[1:] + pedges[:-1]) / 2\n\nplt.plot(pcs, hist);\n</pre> theta = np.arctan2(py, px) phi = np.arccos(pz/p) hist, pedges = np.histogram(phi, bins=100, density=True) pcs = (pedges[1:] + pedges[:-1]) / 2  plt.plot(pcs, hist); In\u00a0[13]: Copied! <pre>rns = np.random.random(100000)\n</pre> rns = np.random.random(100000) In\u00a0[14]: Copied! <pre>pa = 0\npb = np.pi\n\nCa = np.cos(pa)\nCb = np.cos(pb)\n</pre> pa = 0 pb = np.pi  Ca = np.cos(pa) Cb = np.cos(pb) In\u00a0[15]: Copied! <pre>rho = 1/(Ca-Cb)\n</pre> rho = 1/(Ca-Cb) In\u00a0[16]: Copied! <pre>phis = np.linspace(pa, pb, 1000)\n</pre> phis = np.linspace(pa, pb, 1000) In\u00a0[17]: Copied! <pre>plt.plot(phis, rho*np.sin(phis));\n</pre> plt.plot(phis, rho*np.sin(phis)); In\u00a0[18]: Copied! <pre>np.trapz(rho*np.sin(phis), phis)\n</pre> np.trapz(rho*np.sin(phis), phis) <pre>/tmp/ipykernel_2306/4275813628.py:1: DeprecationWarning: `trapz` is deprecated. Use `trapezoid` instead, or one of the numerical integration functions in `scipy.integrate`.\n  np.trapz(rho*np.sin(phis), phis)\n</pre> Out[18]: <pre>np.float64(0.999999175885426)</pre> In\u00a0[19]: Copied! <pre>cdf = (Ca - np.cos(phis))*rho\n</pre> cdf = (Ca - np.cos(phis))*rho In\u00a0[20]: Copied! <pre>from scipy.integrate import cumulative_trapezoid as cumtrapz\n</pre> from scipy.integrate import cumulative_trapezoid as cumtrapz In\u00a0[21]: Copied! <pre>plt.plot(phis, cdf, phis, cumtrapz(rho*np.sin(phis), phis, initial=0));\n</pre> plt.plot(phis, cdf, phis, cumtrapz(rho*np.sin(phis), phis, initial=0)); In\u00a0[22]: Copied! <pre>ps = np.arccos( Ca - rns*(Ca-Cb) )\n</pre> ps = np.arccos( Ca - rns*(Ca-Cb) ) In\u00a0[23]: Copied! <pre>hist, pedges = np.histogram(ps, bins=30, density=True)\n</pre> hist, pedges = np.histogram(ps, bins=30, density=True) In\u00a0[24]: Copied! <pre>pcs = (pedges[1:] + pedges[:-1]) / 2\n</pre> pcs = (pedges[1:] + pedges[:-1]) / 2 In\u00a0[25]: Copied! <pre>plt.plot(pcs, hist, phis, rho*np.sin(phis));\n</pre> plt.plot(pcs, hist, phis, rho*np.sin(phis)); In\u00a0[26]: Copied! <pre>gen = Generator('data/beer.can.in.yaml', verbose=1)\n\n#print(gen)\n</pre> gen = Generator('data/beer.can.in.yaml', verbose=1)  #print(gen) In\u00a0[27]: Copied! <pre>P1 = gen.run()\n</pre> P1 = gen.run() <pre>Distribution format: gpt\nOutput file: beer.can.out.txt\n\nCreating beam distribution....\n   Beam starting from: cathode\n   Total charge: 10 pC.\n   Number of macroparticles: 200000.\n   Assuming cylindrical symmetry...\n   r distribution: radial uniform\n      min_r = 0 mm, max_r = 2 mm\n   theta distribution: uniform theta\n      min_theta = 0 rad, max_theta = 6.28319 rad\n   t distribution: uniform\n      min_t = -2 ps, max_t = 2 ps, avg_t = 0 ps, sigma_t:  1.1547 ps\n   px distribution: Gaussian\n      avg_px = 0 eV/c, sigma_px = 276.857 eV/c\n   py distribution: Gaussian\n      avg_py = 0 eV/c, sigma_py = 276.857 eV/c\n   pz distribution: Gaussian\n      avg_pz = 0 eV/c, sigma_pz = 276.857 eV/c\n   Shifting avg_x = -2.10539E-05 mm -&gt; 0 mm\n   Scaling sigma_x = 0.999982 mm -&gt; 1 mm\n   Shifting avg_y = -1.97648E-06 mm -&gt; 0 mm\n   Scaling sigma_y = 0.999998 mm -&gt; 1 mm\n   Shifting avg_px = -0.0212516 eV/c -&gt; 0 eV/c\n   Scaling sigma_px = 276.849 eV/c -&gt; 276.857 eV/c\n   Shifting avg_py = -0.0259627 eV/c -&gt; 0 eV/c\n   Scaling sigma_py = 276.844 eV/c -&gt; 276.857 eV/c\n   Shifting avg_pz = -0.0372953 eV/c -&gt; 0 eV/c\n   Scaling sigma_pz = 276.843 eV/c -&gt; 276.857 eV/c\n   Shifting avg_t = -4.90022E-05 ps -&gt; 0 ps\n   Scaling sigma_t = 1.1547 ps -&gt; 1.1547 ps\n   Cathode start: fixing pz momenta to forward hemisphere\n      avg_pz -&gt; 220.904 eV/c, sigma_pz -&gt; 166.887 eV/c\n...done. Time Elapsed: 187.871 ms.\n\n</pre> <pre>   Created particles in .particles: \n   ParticleGroup with 200000 particles with total charge 1.0000000000000003e-11 C\n</pre> In\u00a0[28]: Copied! <pre>P1.plot('x', 'px')\n</pre> P1.plot('x', 'px') In\u00a0[29]: Copied! <pre>P1.plot('p')\n</pre> P1.plot('p') In\u00a0[30]: Copied! <pre>P1.plot('pz')\n</pre> P1.plot('pz') In\u00a0[31]: Copied! <pre>P1['sigma_px'], P1['sigma_py'], P1['sigma_pz']\n</pre> P1['sigma_px'], P1['sigma_py'], P1['sigma_pz'] Out[31]: <pre>(np.float64(276.8570795554991),\n np.float64(276.8570795554991),\n np.float64(166.88683722575215))</pre> In\u00a0[32]: Copied! <pre>gen = Generator('data/maxwell_boltzmann.beer.can.in.yaml', verbose=1)\n</pre> gen = Generator('data/maxwell_boltzmann.beer.can.in.yaml', verbose=1) In\u00a0[33]: Copied! <pre>P2 = gen.run()\n</pre> P2 = gen.run() <pre>Distribution format: gpt\nOutput file: beer.can.out.txt\n\nCreating beam distribution....\n   Beam starting from: cathode\n   Total charge: 10 pC.\n   Number of macroparticles: 200000.\n   Assuming cylindrical symmetry...\n   r distribution: radial uniform\n      min_r = 0 mm, max_r = 2 mm\n   theta distribution: uniform theta\n      min_theta = 0 rad, max_theta = 6.28319 rad\n   p distribution: Maxwell-Boltzmann\n      p scale = 276.857 eV/c\n   azimuthal angle distribution: uniform theta\n      min_theta = 0 rad, max_theta = 6.28319 rad\n   polar angle distribution: uniform phi\n      min_phi = 0 rad, max_phi = 3.14159 rad\n   t distribution: uniform\n      min_t = -2 ps, max_t = 2 ps, avg_t = 0 ps, sigma_t:  1.1547 ps\n   Shifting avg_x = 1.63849E-05 mm -&gt; 0 mm\n   Scaling sigma_x = 0.999984 mm -&gt; 1 mm\n   Shifting avg_y = -2.77139E-06 mm -&gt; 0 mm\n   Scaling sigma_y = 0.999996 mm -&gt; 1 mm\n   Shifting avg_px = -0.000954618 eV/c -&gt; -2.70524E-14 eV/c\n   Scaling sigma_px = 276.853 eV/c -&gt; 276.857 eV/rad\u2070\u22c5\u2075/c\n   Shifting avg_py = 0.000856608 eV/c -&gt; 0 eV/c\n   Scaling sigma_py = 276.848 eV/c -&gt; 276.857 eV/rad\u2070\u22c5\u2075/c\n   Shifting avg_pz = -0.0142766 eV/c -&gt; 2.70524E-14 eV/c\n   Scaling sigma_pz = 276.833 eV/c -&gt; 276.857 eV/rad\u2070\u22c5\u2075/c\n   Shifting avg_t = -4.90022E-05 ps -&gt; 0 ps\n   Scaling sigma_t = 1.1547 ps -&gt; 1.1547 ps\n   Cathode start: fixing pz momenta to forward hemisphere\n      avg_pz -&gt; 220.909 eV/c, sigma_pz -&gt; 166.881 eV/c\n...done. Time Elapsed: 198.054 ms.\n\n</pre> <pre>   Created particles in .particles: \n   ParticleGroup with 200000 particles with total charge 1.0000000000000003e-11 C\n</pre> In\u00a0[34]: Copied! <pre>P2['sigma_px'], P2['sigma_py'], P2['sigma_pz']\n</pre> P2['sigma_px'], P2['sigma_py'], P2['sigma_pz'] Out[34]: <pre>(np.float64(276.85707955549907),\n np.float64(276.85707955549907),\n np.float64(166.88083659251544))</pre> In\u00a0[35]: Copied! <pre>gen = Generator('data/maxwell_boltzmann_KE.beer.can.in.yaml', verbose=1)\n</pre> gen = Generator('data/maxwell_boltzmann_KE.beer.can.in.yaml', verbose=1) In\u00a0[36]: Copied! <pre>P3 = gen.run()\n</pre> P3 = gen.run() <pre>Distribution format: gpt\nOutput file: beer.can.out.txt\n\nCreating beam distribution....\n   Beam starting from: cathode\n   Total charge: 10 pC.\n   Number of macroparticles: 200000.\n   Assuming cylindrical symmetry...\n   r distribution: radial uniform\n      min_r = 0 mm, max_r = 2 mm\n   theta distribution: uniform theta\n      min_theta = 0 rad, max_theta = 6.28319 rad\n   KE distribution: </pre> <pre>Maxwell-Boltzmann Energy\n      kT = 150 meV\n   azimuthal angle distribution: uniform theta\n      min_theta = 0 rad, max_theta = 6.28319 rad\n   polar angle distribution: uniform phi\n      min_phi = 0 rad, max_phi = 3.14159 rad\n   t distribution: uniform\n      min_t = -2 ps, max_t = 2 ps, avg_t = 0 ps, sigma_t:  1.1547 ps\n   Shifting avg_x = 1.63849E-05 mm -&gt; 0 mm\n   Scaling sigma_x = 0.999984 mm -&gt; 1 mm\n   Shifting avg_y = -2.77139E-06 mm -&gt; 0 mm\n   Scaling sigma_y = 0.999996 mm -&gt; 1 mm\n   Shifting avg_px = -1.75487E-09 meV\u00b7s/m -&gt; -9.02058E-20 meV\u00b7s/m\n   Scaling sigma_px = 0.000922998 meV\u00b7s/m -&gt; 0.000922972 meV\u00b7s/m\n   Shifting avg_py = 1.21968E-09 meV\u00b7s/m -&gt; 0 meV\u00b7s/m\n   Scaling sigma_py = 0.000922978 meV\u00b7s/m -&gt; 0.000922972 meV\u00b7s/m\n   Shifting avg_pz = -4.48933E-08 meV\u00b7s/m -&gt; 9.02058E-20 meV\u00b7s/m\n   Scaling sigma_pz = 0.00092294 meV\u00b7s/m -&gt; 0.000922972 meV\u00b7s/m\n   Shifting avg_t = -4.90022E-05 ps -&gt; 0 ps\n   Scaling sigma_t = 1.1547 ps -&gt; 1.1547 ps\n   Cathode start: fixing pz momenta to forward hemisphere\n      avg_pz -&gt; 0.0007366 meV\u00b7s/m, sigma_pz -&gt; 0.000556145 meV\u00b7s/m\n...done. Time Elapsed: 198.81 ms.\n\n</pre> <pre>   Created particles in .particles: \n   ParticleGroup with 200000 particles with total charge 1.0000000000000003e-11 C\n</pre> In\u00a0[37]: Copied! <pre>P3.plot('kinetic_energy')\n</pre> P3.plot('kinetic_energy') In\u00a0[38]: Copied! <pre>P3.plot('x', 'px')\n</pre> P3.plot('x', 'px') In\u00a0[39]: Copied! <pre>P3['sigma_px'], P3['sigma_py'], P3['sigma_pz']\n</pre> P3['sigma_px'], P3['sigma_py'], P3['sigma_pz'] Out[39]: <pre>(np.float64(276.70000872169317),\n np.float64(276.70000872169317),\n np.float64(166.7279863589753))</pre> In\u00a0[40]: Copied! <pre>fig = plt.figure()\nax = fig.add_subplot(projection='3d')\n\npx, py, pz = P3['px'], P3['py'], P3['pz']\n\np = np.sqrt(px**2 + py**2 + pz**2)\n\ntheta = np.arctan2(py, px)\nphi = np.arccos(pz/p)\nhist, pedges = np.histogram(phi, bins=100, density=True)\npcs = (pedges[1:] + pedges[:-1]) / 2\n\nx = px/p\ny = py/p\nz = pz/p\n\nax.scatter(x[::500], y[::500], z[::500], '.');\nax.set_xlabel(r'$\\hat{p}_x$')\nax.set_ylabel(r'$\\hat{p}_y$')\nax.set_zlabel(r'$\\hat{p}_z$')\n</pre> fig = plt.figure() ax = fig.add_subplot(projection='3d')  px, py, pz = P3['px'], P3['py'], P3['pz']  p = np.sqrt(px**2 + py**2 + pz**2)  theta = np.arctan2(py, px) phi = np.arccos(pz/p) hist, pedges = np.histogram(phi, bins=100, density=True) pcs = (pedges[1:] + pedges[:-1]) / 2  x = px/p y = py/p z = pz/p  ax.scatter(x[::500], y[::500], z[::500], '.'); ax.set_xlabel(r'$\\hat{p}_x$') ax.set_ylabel(r'$\\hat{p}_y$') ax.set_zlabel(r'$\\hat{p}_z$') Out[40]: <pre>Text(0.5, 0, '$\\\\hat{p}_z$')</pre> In\u00a0[41]: Copied! <pre>KE = np.linspace(0, 150, 10000)\n\nE0=0\n\nA1 = 0.8,\nm1 = 8\n\nA2 = 0.1\nm2 = 90\n\nPKE = A1*np.exp(-np.abs(KE-E0)/m1) + A2*np.exp(-np.abs(KE-E0)/m2) \nPKE = PKE/np.trapz(PKE, KE)  # Numerically intergate to normalize\n\nplt.plot(KE, PKE);\nplt.xlabel('KE (eV)');\nplt.ylabel('$\\\\rho(KE)$ (1/eV)');\n</pre> KE = np.linspace(0, 150, 10000)  E0=0  A1 = 0.8, m1 = 8  A2 = 0.1 m2 = 90  PKE = A1*np.exp(-np.abs(KE-E0)/m1) + A2*np.exp(-np.abs(KE-E0)/m2)  PKE = PKE/np.trapz(PKE, KE)  # Numerically intergate to normalize  plt.plot(KE, PKE); plt.xlabel('KE (eV)'); plt.ylabel('$\\\\rho(KE)$ (1/eV)'); <pre>/tmp/ipykernel_2306/1250638860.py:12: DeprecationWarning: `trapz` is deprecated. Use `trapezoid` instead, or one of the numerical integration functions in `scipy.integrate`.\n  PKE = PKE/np.trapz(PKE, KE)  # Numerically intergate to normalize\n</pre> In\u00a0[42]: Copied! <pre>dat = np.zeros((len(KE),2))\ndat[:,0], dat[:,1] = KE, PKE\n\nnp.savetxt('KEdist.txt', dat, header=\"KE     PKE\", comments='')\n</pre> dat = np.zeros((len(KE),2)) dat[:,0], dat[:,1] = KE, PKE  np.savetxt('KEdist.txt', dat, header=\"KE     PKE\", comments='') In\u00a0[43]: Copied! <pre>q = 1000*1.60217663e-19\n\nprint(q)\n\ninput_yaml = \"\"\"\nn_particle: 1000\nspecies: electron\nstart: \n  type: cathode\nrandom:\n  type: hammersley\ntotal_charge:\n  units: C\n  value: 1.60217663e-17\nr_dist:\n  max_r:\n    units: mm\n    value: 14.6\n  type: radial_uniform\nKE_dist:\n  file: KEdist.txt\n  units: eV\n  type: file1d\ntransforms:\n  sx:\n    avg_x:\n      units: millimeter\n      value: -50\n    type: set_avg x\n  sy:\n    avg_y:\n      units: millimeter\n      value: 50\n    type: set_avg y\n  sz:\n    avg_z:\n      units: millimeter\n      value: 65\n    type: set_avg z\noutput:\n    file: None\n\"\"\"\n</pre> q = 1000*1.60217663e-19  print(q)  input_yaml = \"\"\" n_particle: 1000 species: electron start:    type: cathode random:   type: hammersley total_charge:   units: C   value: 1.60217663e-17 r_dist:   max_r:     units: mm     value: 14.6   type: radial_uniform KE_dist:   file: KEdist.txt   units: eV   type: file1d transforms:   sx:     avg_x:       units: millimeter       value: -50     type: set_avg x   sy:     avg_y:       units: millimeter       value: 50     type: set_avg y   sz:     avg_z:       units: millimeter       value: 65     type: set_avg z output:     file: None \"\"\" <pre>1.6021766299999998e-16\n</pre> In\u00a0[44]: Copied! <pre>import yaml\n\ninputs = yaml.safe_load(input_yaml)\n\nn = 1000\n\ninputs['n_particle'] = n\ninputs['output']['file'] = 'test_ion_writer.ion'\ninputs['output']['type'] = 'simion'\ninputs['total_charge']['value'] = n*1.60217663e-19\ninputs['transforms']['sx']['avg_x']['value'] = -50\ninputs['transforms']['sy']['avg_y']['value'] = 50\ninputs['transforms']['sz']['avg_z']['value'] = 55\n</pre> import yaml  inputs = yaml.safe_load(input_yaml)  n = 1000  inputs['n_particle'] = n inputs['output']['file'] = 'test_ion_writer.ion' inputs['output']['type'] = 'simion' inputs['total_charge']['value'] = n*1.60217663e-19 inputs['transforms']['sx']['avg_x']['value'] = -50 inputs['transforms']['sy']['avg_y']['value'] = 50 inputs['transforms']['sz']['avg_z']['value'] = 55 In\u00a0[45]: Copied! <pre>gen = Generator(inputs, verbose=1)\n</pre> gen = Generator(inputs, verbose=1)  In\u00a0[46]: Copied! <pre>P = gen.run()\n</pre> P = gen.run() <pre>Distribution format: simion\nOutput file: /home/runner/work/distgen/distgen/docs/examples/test_ion_writer.ion\n\nCreating beam distribution....\n   Beam starting from: cathode\n   Total charge: 1.60218E-16 C.\n   Number of macroparticles: 1000.\n   Assuming cylindrical symmetry...\n   r distribution: radial uniform\n      min_r = 0 mm, max_r = 14.6 mm\n   theta distribution: uniform theta\n      min_theta = 0 rad, max_theta = 6.28319 rad\n   KE distribution: KE-distribution file: \"/home/runner/work/distgen/distgen/docs/examples/KEdist.txt\"\n   azimuthal angle distribution: uniform theta\n      min_theta = 0 rad, max_theta = 6.28319 rad\n   polar angle distribution: uniform phi\n      min_phi = 0 rad, max_phi = 3.14159 rad\n   Shifting avg_x = 0.00564031 mm -&gt; 0 mm\n   Scaling sigma_x = 7.29551 mm -&gt; 7.3 mm\n   Shifting avg_y = 0.00120927 mm -&gt; 0 mm\n   Scaling sigma_y = 7.29741 mm -&gt; 7.3 mm\n   Shifting avg_px = -6.09774E-09 eV\u00b7s/m -&gt; -9.89015E-22 eV\u00b7s/m\n   Scaling sigma_px = 1.11822E-05 eV\u00b7s/m -&gt; 1.11773E-05 eV\u00b7s/m\n   Shifting avg_py = -2.50205E-09 eV\u00b7s/m -&gt; 0 eV\u00b7s/m\n   Scaling sigma_py = 1.11987E-05 eV\u00b7s/m -&gt; 1.11773E-05 eV\u00b7s/m\n   Shifting avg_pz = -2.52855E-08 eV\u00b7s/m -&gt; 9.89015E-22 eV\u00b7s/m\n   Scaling sigma_pz = 1.11509E-05 eV\u00b7s/m -&gt; 1.11773E-05 eV\u00b7s/m\n   Cathode start: fixing pz momenta to forward hemisphere\n      avg_pz -&gt; 8.07962E-06 eV\u00b7s/m, sigma_pz -&gt; 7.72348E-06 eV\u00b7s/m\n   Applying user supplied transform: \"sx\" = set_avg x...\n      Setting avg_x -&gt; -50 mm.\n   Applying user supplied transform: \"sy\" = set_avg y...\n      Setting avg_y -&gt; 50 mm.\n   Applying user supplied transform: \"sz\" = set_avg z...\n      Setting avg_z -&gt; 55 mm.\n...done. Time Elapsed: 26.504 ms.\n\n   Created particles in .particles: \n   ParticleGroup with 1000 particles with total charge 1.6021766300000003e-16 C\n</pre> In\u00a0[47]: Copied! <pre>P.plot('x', 'y', figsize=(5,5))\n</pre> P.plot('x', 'y', figsize=(5,5)) In\u00a0[48]: Copied! <pre>P.plot('x', 'px', figsize=(5,5))\n</pre> P.plot('x', 'px', figsize=(5,5)) In\u00a0[49]: Copied! <pre>P.plot('kinetic_energy')\n</pre> P.plot('kinetic_energy') In\u00a0[50]: Copied! <pre>from distgen.writers import writer\n\nwriter('simion', gen.beam(), 'test_ion_writer.ion', params={'color':0})\n</pre> from distgen.writers import writer  writer('simion', gen.beam(), 'test_ion_writer.ion', params={'color':0}) <pre>Distribution format: simion\nOutput file: /home/runner/work/distgen/distgen/docs/examples/test_ion_writer.ion\n\nCreating beam distribution....\n   Beam starting from: cathode\n   Total charge: 1.60218E-16 C.\n   Number of macroparticles: 1000.\n   Assuming cylindrical symmetry...\n   r distribution: radial uniform\n      min_r = 0 mm, max_r = 14.6 mm\n   theta distribution: uniform theta\n      min_theta = 0 rad, max_theta = 6.28319 rad\n   KE distribution: KE-distribution file: \"/home/runner/work/distgen/distgen/docs/examples/KEdist.txt\"\n   azimuthal angle distribution: uniform theta\n      min_theta = 0 rad, max_theta = 6.28319 rad\n   polar angle distribution: uniform phi\n      min_phi = 0 rad, max_phi = 3.14159 rad\n   Shifting avg_x = 0.00564031 mm -&gt; 0 mm\n   Scaling sigma_x = 7.29551 mm -&gt; 7.3 mm\n   Shifting avg_y = 0.00120927 mm -&gt; 0 mm\n   Scaling sigma_y = 7.29741 mm -&gt; 7.3 mm\n   Shifting avg_px = -6.09774E-09 eV\u00b7s/m -&gt; -9.89015E-22 eV\u00b7s/m\n   Scaling sigma_px = 1.11822E-05 eV\u00b7s/m -&gt; 1.11773E-05 eV\u00b7s/m\n   Shifting avg_py = -2.50205E-09 eV\u00b7s/m -&gt; 0 eV\u00b7s/m\n   Scaling sigma_py = 1.11987E-05 eV\u00b7s/m -&gt; 1.11773E-05 eV\u00b7s/m\n   Shifting avg_pz = -2.52855E-08 eV\u00b7s/m -&gt; 9.89015E-22 eV\u00b7s/m\n   Scaling sigma_pz = 1.11509E-05 eV\u00b7s/m -&gt; 1.11773E-05 eV\u00b7s/m\n   Cathode start: fixing pz momenta to forward hemisphere\n      avg_pz -&gt; 8.07962E-06 eV\u00b7s/m, sigma_pz -&gt; 7.72348E-06 eV\u00b7s/m\n   Applying user supplied transform: \"sx\" = set_avg x...\n      Setting avg_x -&gt; -50 mm.\n   Applying user supplied transform: \"sy\" = set_avg y...\n      Setting avg_y -&gt; 50 mm.\n   Applying user supplied transform: \"sz\" = set_avg z...\n      Setting avg_z -&gt; 55 mm.\n...done. Time Elapsed: 26.0615 ms.\n\n</pre> In\u00a0[51]: Copied! <pre>from scipy.constants import physical_constants\n\nmc2 = 1e6 * physical_constants['electron mass energy equivalent in MeV'][0]\ne_= physical_constants['elementary charge'][0]\nme = physical_constants['electron mass in u'][0]\n\ndef particle_group_to_SIMION(P, filename, color=0):\n    \n    header=';0'\n    \n    simion_params= ['TOB', 'MASS', 'CHARGE', 'X', 'Y', 'Z', 'AZ', 'EL', 'KE', 'CWF', 'COLOR']\n    \n    simion_units = {'TOB':'usec', 'MASS':'amu', 'CHARGE':'e', 'X':'mm', 'Y':'mm', 'Z':'mm', 'AZ':'deg', 'EL':'deg', 'CWF':'', 'COLOR':''}\n    \n    data = np.zeros( (len(P), len(simion_params)) )\n    \n    data[:, simion_params.index('TOB')] = P.t*1e6    # [P.t] = sec, convert to usec\n    \n    if(P.species == 'electron'):\n        data[:, simion_params.index('MASS')] = np.full(len(P), me)\n        data[:, simion_params.index('CHARGE')] = np.full(len(P), -1)\n    else:\n        raise ValueError(f'Species {P.species} is not supported')\n    \n    data[:, simion_params.index('X')] =  P.z*1e3\n    data[:, simion_params.index('Y')] =  P.y*1e3\n    data[:, simion_params.index('Z')] = -P.x*1e3\n    \n    px =  P.pz\n    py =  P.py\n    pz = -P.px\n    \n    data[:, simion_params.index('KE')] = P.kinetic_energy       # [eV] \n    data[:, simion_params.index('AZ')] = np.arctan2(-pz, px) * (180/np.pi)   # [deg]\n    data[:, simion_params.index('EL')] = np.arctan2(py, np.sqrt(px**2 + pz**2) ) * (180/np.pi) # [deg]\n    \n    data[:, simion_params.index('CWF')] = P.weight/e_                       # Charge Weighting Factor, derive from particle group weights\n    data[:, simion_params.index('COLOR')] = np.full(len(P), color)\n    #fname, X, fmt='%.18e', delimiter=' '\n    \n    np.savetxt(filename, data, delimiter=',', header=header, comments='', fmt='  %.9e')\n</pre> from scipy.constants import physical_constants  mc2 = 1e6 * physical_constants['electron mass energy equivalent in MeV'][0] e_= physical_constants['elementary charge'][0] me = physical_constants['electron mass in u'][0]  def particle_group_to_SIMION(P, filename, color=0):          header=';0'          simion_params= ['TOB', 'MASS', 'CHARGE', 'X', 'Y', 'Z', 'AZ', 'EL', 'KE', 'CWF', 'COLOR']          simion_units = {'TOB':'usec', 'MASS':'amu', 'CHARGE':'e', 'X':'mm', 'Y':'mm', 'Z':'mm', 'AZ':'deg', 'EL':'deg', 'CWF':'', 'COLOR':''}          data = np.zeros( (len(P), len(simion_params)) )          data[:, simion_params.index('TOB')] = P.t*1e6    # [P.t] = sec, convert to usec          if(P.species == 'electron'):         data[:, simion_params.index('MASS')] = np.full(len(P), me)         data[:, simion_params.index('CHARGE')] = np.full(len(P), -1)     else:         raise ValueError(f'Species {P.species} is not supported')          data[:, simion_params.index('X')] =  P.z*1e3     data[:, simion_params.index('Y')] =  P.y*1e3     data[:, simion_params.index('Z')] = -P.x*1e3          px =  P.pz     py =  P.py     pz = -P.px          data[:, simion_params.index('KE')] = P.kinetic_energy       # [eV]      data[:, simion_params.index('AZ')] = np.arctan2(-pz, px) * (180/np.pi)   # [deg]     data[:, simion_params.index('EL')] = np.arctan2(py, np.sqrt(px**2 + pz**2) ) * (180/np.pi) # [deg]          data[:, simion_params.index('CWF')] = P.weight/e_                       # Charge Weighting Factor, derive from particle group weights     data[:, simion_params.index('COLOR')] = np.full(len(P), color)     #fname, X, fmt='%.18e', delimiter=' '          np.savetxt(filename, data, delimiter=',', header=header, comments='', fmt='  %.9e')      In\u00a0[52]: Copied! <pre>particle_group_to_SIMION(P, 'text_ion_file.ion')\n</pre> particle_group_to_SIMION(P, 'text_ion_file.ion') In\u00a0[53]: Copied! <pre>def read_simion_ION_file(filename):\n    \n    data = np.loadtxt(filename, comments=';', delimiter=',', skiprows=1)\n    \n    simion_params= ['TOB', 'MASS', 'CHARGE', 'X', 'Y', 'Z', 'AZ', 'EL', 'KE', 'CWF', 'COLOR']\n    \n    return {simion_params[ii]:data[:,ii] for ii, p in enumerate(simion_params)}\n</pre> def read_simion_ION_file(filename):          data = np.loadtxt(filename, comments=';', delimiter=',', skiprows=1)          simion_params= ['TOB', 'MASS', 'CHARGE', 'X', 'Y', 'Z', 'AZ', 'EL', 'KE', 'CWF', 'COLOR']          return {simion_params[ii]:data[:,ii] for ii, p in enumerate(simion_params)}                        In\u00a0[54]: Copied! <pre>ions1 = read_simion_ION_file('text_ion_file.ion')\nions2 = read_simion_ION_file('test_ion_writer.ion')\n</pre> ions1 = read_simion_ION_file('text_ion_file.ion') ions2 = read_simion_ION_file('test_ion_writer.ion') In\u00a0[55]: Copied! <pre>fig = plt.figure()\nax = fig.add_subplot(projection='3d')\n\npx, py, pz = P['px'], P['py'], P['pz']\n\np = np.sqrt(px**2 + py**2 + pz**2)\n\ntheta = np.arctan2(py, px)\nphi = np.arccos(pz/p)\nhist, pedges = np.histogram(phi, bins=100, density=True)\npcs = (pedges[1:] + pedges[:-1]) / 2\n\nx = px/p\ny = py/p\nz = pz/p\n\nax.scatter(x[::], y[::], z[::], '.');\nax.set_xlabel(r'$\\hat{p}_x$')\nax.set_ylabel(r'$\\hat{p}_y$')\nax.set_zlabel(r'$\\hat{p}_z$')\n</pre> fig = plt.figure() ax = fig.add_subplot(projection='3d')  px, py, pz = P['px'], P['py'], P['pz']  p = np.sqrt(px**2 + py**2 + pz**2)  theta = np.arctan2(py, px) phi = np.arccos(pz/p) hist, pedges = np.histogram(phi, bins=100, density=True) pcs = (pedges[1:] + pedges[:-1]) / 2  x = px/p y = py/p z = pz/p  ax.scatter(x[::], y[::], z[::], '.'); ax.set_xlabel(r'$\\hat{p}_x$') ax.set_ylabel(r'$\\hat{p}_y$') ax.set_zlabel(r'$\\hat{p}_z$') Out[55]: <pre>Text(0.5, 0, '$\\\\hat{p}_z$')</pre> In\u00a0[56]: Copied! <pre>for p in ions1: print(f'{p}:', max(np.abs(ions1[p] - ions2[p])))\n</pre> for p in ions1: print(f'{p}:', max(np.abs(ions1[p] - ions2[p]))) <pre>TOB: 0.0\nMASS: 0.0\nCHARGE: 0.0\nX: 0.0\nY: 0.0\nZ: 0.0\nAZ: 0.0\nEL: 0.0\nKE: 0.0\nCWF: 0.0\nCOLOR: 0.0\n</pre> In\u00a0[57]: Copied! <pre>plt.plot(ions1['KE'], ions1['KE']/ions2['KE'], '.');\nplt.xlabel('KE (eV)');\n</pre> plt.plot(ions1['KE'], ions1['KE']/ions2['KE'], '.'); plt.xlabel('KE (eV)'); In\u00a0[58]: Copied! <pre>os.remove('text_ion_file.ion')\nos.remove('KEdist.txt')\nos.remove('test_ion_writer.ion')\n</pre> os.remove('text_ion_file.ion') os.remove('KEdist.txt') os.remove('test_ion_writer.ion') In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/transforms/","title":"Transformation utilties","text":"In\u00a0[1]: Copied! <pre># Useful for debugging\n%load_ext autoreload\n%autoreload 2\n%config InlineBackend.figure_format = 'retina'\n</pre> # Useful for debugging %load_ext autoreload %autoreload 2 %config InlineBackend.figure_format = 'retina' In\u00a0[2]: Copied! <pre>units = {'x':'mm','y':'mm','r':'mm','z':'mm','px':'keV/c','py':'keV/c','pz':'MeV/c','t':'ps','q':'pC','thetax':'mrad','thetay':'mrad'}\nfrom distgen import Generator\nfrom distgen.plot import plot_dist2d, plot_radial_dist\nfrom distgen.physical_constants import unit_registry as unit\nfrom matplotlib import pyplot as plt\nimport yaml\nimport numpy as np\nfrom pprint import pprint\n</pre> units = {'x':'mm','y':'mm','r':'mm','z':'mm','px':'keV/c','py':'keV/c','pz':'MeV/c','t':'ps','q':'pC','thetax':'mrad','thetay':'mrad'} from distgen import Generator from distgen.plot import plot_dist2d, plot_radial_dist from distgen.physical_constants import unit_registry as unit from matplotlib import pyplot as plt import yaml import numpy as np from pprint import pprint <p>A set of transformations can be applied to a beam when it is created by adding a dictionary called 'transforms' at the top level of the Distgen input structure (in either dictionary or YAML format).</p> <p>Transformations are added to this dictionary with a unique identifier key.  The key <code>'order'</code> is protected and should not be used. Each transformation definition must be a dictionary containing a <code>'type'</code> key associated with a known transform function and the variable(s) it acts on.  A simple example is given by a translation in x: the type key is then \"type: translate x\".  All input parameters for the transformation should be input at the same level as the 'type' key. Physical quantities with units should be dictionaries with a 'value' and 'units' key/value pair supplied.</p> <p>Unless specified, transformations are applied in the order they are input in the transforms dictionary. Because transformation operations often do not commute, the user may specify a desired order by adding a list of transformation ID's to the tranform dictionary using the key <code>'order'</code>. Because python and yaml do not universally guarantee order is preserved, it is recommended to always specify the order list when the number of transforms is more than one.</p> <p>In the example below, two transforms are include: scaling a round beam so that it is oval, and then rotated the beam by 45 deg.  In this example the full input to Distgen is printed, in subsequent examples, only the transform details are printed.</p> In\u00a0[3]: Copied! <pre>gen = Generator('data/beer.can.in.yaml', verbose=0) \n\ninitial_beam = gen.beam()\n\nsetstdx = {'type':'set_std x', 'sigma_x':{'value': 3, 'units': 'mm'}}\nrot2dxy = {'type':'rotate2d x:y', 'angle':{'value':45, 'units':'deg'}}\ntransy = {'type': 'translate y', 'delta': {'value': 1, 'units': 'mm'}}\n\ngen['transforms']={'t1':setstdx, 't2':rot2dxy, 't3':transy, 'order':['t1', 't2', 't3']}\n\nfinal_beam = gen.beam()\n\nprint('Input:\\n', yaml.dump(gen.input['transforms']))\n\nfig, ax = plt.subplots(1, 2, sharex='col',constrained_layout=True)\n\nplot_dist2d(initial_beam, 'x', units['x'], 'y', units['y'], axis='equal', ax=ax[0]);\nax[0].set_title('Before transforms');\n\nplot_dist2d(final_beam, 'x', units['x'], 'y', units['y'], axis='equal', ax=ax[1]);\nax[1].set_title('After transforms');\n</pre> gen = Generator('data/beer.can.in.yaml', verbose=0)   initial_beam = gen.beam()  setstdx = {'type':'set_std x', 'sigma_x':{'value': 3, 'units': 'mm'}} rot2dxy = {'type':'rotate2d x:y', 'angle':{'value':45, 'units':'deg'}} transy = {'type': 'translate y', 'delta': {'value': 1, 'units': 'mm'}}  gen['transforms']={'t1':setstdx, 't2':rot2dxy, 't3':transy, 'order':['t1', 't2', 't3']}  final_beam = gen.beam()  print('Input:\\n', yaml.dump(gen.input['transforms']))  fig, ax = plt.subplots(1, 2, sharex='col',constrained_layout=True)  plot_dist2d(initial_beam, 'x', units['x'], 'y', units['y'], axis='equal', ax=ax[0]); ax[0].set_title('Before transforms');  plot_dist2d(final_beam, 'x', units['x'], 'y', units['y'], axis='equal', ax=ax[1]); ax[1].set_title('After transforms'); <pre>Input:\n order:\n- t1\n- t2\n- t3\nt1:\n  sigma_x:\n    units: millimeter\n    value: 3.0\n  type: set_std x\nt2:\n  angle:\n    units: degree\n    value: 45.0\n  type: rotate2d x:y\nt3:\n  delta:\n    units: millimeter\n    value: 1.0\n  type: translate y\n\n</pre> <p>Distgen provides a set of basic transformation utilities that can be applied the particle coordinates of a beam object.  Here the basic examples are discused: the transformation functions are defined as well as how to use them from the standard Distgen input structure.  Note the these transformation operations do not in general commute.</p> <p>The primary example used is that of a uniform radial distribution.</p> <p>Translations of the coordinate $u$ are defined by: $u\\rightarrow u + \\Delta u$.</p> In\u00a0[4]: Copied! <pre># Translations: a translation of a single coordinate are handled by transforms.translate\nfrom distgen.transforms import translate\n\ngen=Generator('data/beer.can.in.yaml',verbose=0)\nbeam1=gen.beam()\n\ntransx = {'type':'translate x', 'delta':{'value':+3, 'units':'mm'}}\ntransy = {'type':'translate y', 'delta': '-1 mm'}\n\ngen['transforms']={'tx':transx, 'ty':transy, 'order':['tx','ty']}\nbeam2 = gen.beam()\n\nprint('Input:\\n',yaml.dump(gen.input['transforms']))\n\nfig, ax = plt.subplots(1, 2, sharex='col',constrained_layout=True)\n\nplot_dist2d(beam1, 'x', units['x'], 'y', units['y'], axis='equal', ax=ax[0], title_on=True);\nax[0].set_title(f'Before\\n{ax[0].get_title()}')\n\nplot_dist2d(beam2, 'x', units['x'], 'y', units['y'], axis='equal', ax=ax[1], title_on=True);\nax[1].set_title(f'After\\n{ax[1].get_title()}');\n</pre> # Translations: a translation of a single coordinate are handled by transforms.translate from distgen.transforms import translate  gen=Generator('data/beer.can.in.yaml',verbose=0) beam1=gen.beam()  transx = {'type':'translate x', 'delta':{'value':+3, 'units':'mm'}} transy = {'type':'translate y', 'delta': '-1 mm'}  gen['transforms']={'tx':transx, 'ty':transy, 'order':['tx','ty']} beam2 = gen.beam()  print('Input:\\n',yaml.dump(gen.input['transforms']))  fig, ax = plt.subplots(1, 2, sharex='col',constrained_layout=True)  plot_dist2d(beam1, 'x', units['x'], 'y', units['y'], axis='equal', ax=ax[0], title_on=True); ax[0].set_title(f'Before\\n{ax[0].get_title()}')  plot_dist2d(beam2, 'x', units['x'], 'y', units['y'], axis='equal', ax=ax[1], title_on=True); ax[1].set_title(f'After\\n{ax[1].get_title()}'); <pre>Input:\n order:\n- tx\n- ty\ntx:\n  delta:\n    units: millimeter\n    value: 3.0\n  type: translate x\nty:\n  delta:\n    units: millimeter\n    value: -1\n  type: translate y\n\n</pre> In\u00a0[5]: Copied! <pre>gen=Generator('data/beer.can.in.yaml',verbose=0)\nbeam1=gen.beam()\n\nsetavgx = {'type':'set_avg x', 'avg_x':{'value':+3, 'units':'mm'}}\nsetavgy = {'type':'set_avg y', 'avg_y':{'value':-1, 'units':'mm'}}\n\ngen['transforms']={'tx':setavgx, 'ty':setavgy, 'order':['tx', 'ty']}\nbeam2 = gen.beam()\n\nprint('Input:\\n',yaml.dump(gen.input['transforms']))\n\nfig, ax = plt.subplots(1, 2, sharex='col',constrained_layout=True)\n\nplot_dist2d(beam1, 'x', units['x'], 'y', units['y'], axis='equal', ax=ax[0], title_on=True);\nax[0].set_title(f'Before\\n{ax[0].get_title()}')\n\nplot_dist2d(beam2, 'x', units['x'], 'y', units[\"y\"], axis='equal', ax=ax[1], title_on=True);\nax[1].set_title(f'After\\n{ax[1].get_title()}');\n</pre> gen=Generator('data/beer.can.in.yaml',verbose=0) beam1=gen.beam()  setavgx = {'type':'set_avg x', 'avg_x':{'value':+3, 'units':'mm'}} setavgy = {'type':'set_avg y', 'avg_y':{'value':-1, 'units':'mm'}}  gen['transforms']={'tx':setavgx, 'ty':setavgy, 'order':['tx', 'ty']} beam2 = gen.beam()  print('Input:\\n',yaml.dump(gen.input['transforms']))  fig, ax = plt.subplots(1, 2, sharex='col',constrained_layout=True)  plot_dist2d(beam1, 'x', units['x'], 'y', units['y'], axis='equal', ax=ax[0], title_on=True); ax[0].set_title(f'Before\\n{ax[0].get_title()}')  plot_dist2d(beam2, 'x', units['x'], 'y', units[\"y\"], axis='equal', ax=ax[1], title_on=True); ax[1].set_title(f'After\\n{ax[1].get_title()}'); <pre>Input:\n order:\n- tx\n- ty\ntx:\n  avg_x:\n    units: millimeter\n    value: 3.0\n  type: set_avg x\nty:\n  avg_y:\n    units: millimeter\n    value: -1.0\n  type: set_avg y\n\n</pre> <p>Basic scaling is handled using transforms.scale.  To scale the $x$ coordinate of the beam by $\\alpha$ use:</p> <p>scale(beam,'x',$\\alpha$)</p> <p>where $\\alpha$ is a dimensionless quantity or float.  Note that if the $&lt;x&gt;\\neq0$ then $&lt;x&gt;\\rightarrow\\alpha&lt;x&gt;$.  It is possible to fix the average value under scaling using:</p> <p>scale(beam, 'x', $\\alpha$, fix_average='True')</p> In\u00a0[6]: Copied! <pre>from distgen.transforms import scale\n\ngen=Generator('data/beer.can.in.yaml',verbose=0)\nbeam1 = gen.beam()\n\ntransx = {'type':'translate x', 'delta':{'value': 3,'units': 'mm'}}\nscalex = {'type':'scale x', 'scale':2,}\n\ngen['transforms']={'t1':transx, 't2':scalex, 'order':['t1','t2']}\nbeam1 = gen.beam()\n\nscalex['fix_average']=True\n\ngen['transforms']={'t':transx, 's':scalex, 'order':['t','s']}\nbeam2 = gen.beam()\n\nprint('Input:\\n',yaml.dump(gen.input['transforms']))\n\nfig, ax = plt.subplots(1, 2, constrained_layout=True)\n\nplot_dist2d(beam1, 'x', units['x'], 'y', units[\"y\"], axis='equal', ax=ax[0]);\nax[0].set_title('Default scaling (average scaled)');\n\nplot_dist2d(beam2, 'x', units['x'], 'y', units['y'], axis='equal', ax=ax[1]);\nax[1].set_title('Scaling with average fixed');\n</pre> from distgen.transforms import scale  gen=Generator('data/beer.can.in.yaml',verbose=0) beam1 = gen.beam()  transx = {'type':'translate x', 'delta':{'value': 3,'units': 'mm'}} scalex = {'type':'scale x', 'scale':2,}  gen['transforms']={'t1':transx, 't2':scalex, 'order':['t1','t2']} beam1 = gen.beam()  scalex['fix_average']=True  gen['transforms']={'t':transx, 's':scalex, 'order':['t','s']} beam2 = gen.beam()  print('Input:\\n',yaml.dump(gen.input['transforms']))  fig, ax = plt.subplots(1, 2, constrained_layout=True)  plot_dist2d(beam1, 'x', units['x'], 'y', units[\"y\"], axis='equal', ax=ax[0]); ax[0].set_title('Default scaling (average scaled)');  plot_dist2d(beam2, 'x', units['x'], 'y', units['y'], axis='equal', ax=ax[1]); ax[1].set_title('Scaling with average fixed'); <pre>Input:\n order:\n- t\n- s\ns:\n  fix_average: true\n  scale: 2\n  type: scale x\nt:\n  delta:\n    units: millimeter\n    value: 3.0\n  type: translate x\n\n</pre> In\u00a0[7]: Copied! <pre>from distgen.transforms import set_stdxy\n\ngen=Generator('data/beer.can.in.yaml',verbose=0)\nbeam1 = gen.beam()\n\nscalex = {'type':'set_stdxy x:y', 'sigma_xy':{'value':3.4, 'units': 'mm'},}\n\ngen['transforms']={'t1':scalex}\nbeam2 = gen.beam()\n\nplot_dist2d(beam2, 'x', units['x'], 'y', units[\"y\"], axis='equal', title_on=True);\n</pre> from distgen.transforms import set_stdxy  gen=Generator('data/beer.can.in.yaml',verbose=0) beam1 = gen.beam()  scalex = {'type':'set_stdxy x:y', 'sigma_xy':{'value':3.4, 'units': 'mm'},}  gen['transforms']={'t1':scalex} beam2 = gen.beam()  plot_dist2d(beam2, 'x', units['x'], 'y', units[\"y\"], axis='equal', title_on=True);  <p>It is possible to combine a translation with a scaling operation to shift and rescale a coordinate to have a new standard deviation while keeping the form of the underlying coordinate distribution unchanged. This is accomplished using transforms.set_avg_and_std(...)</p> In\u00a0[8]: Copied! <pre>from distgen.transforms import set_avg_and_std\n\ngen=Generator('data/beer.can.in.yaml',verbose=0)\n\nsetx = {\n    'type':'set_avg_and_std x',\n    'avg_x':  {'value': -3, 'units': 'mm'},\n    'sigma_x':{'value':  5, 'units': 'mm'}\n}\n\ngen['transforms']={'sx':setx}\nbeam = gen.beam()\n\nprint('Input:\\n',yaml.dump(gen.input['transforms']))\n\nplot_dist2d(beam, 'x', units['x'], 'y', units['y'], axis='equal', title_on=True);\n</pre> from distgen.transforms import set_avg_and_std  gen=Generator('data/beer.can.in.yaml',verbose=0)  setx = {     'type':'set_avg_and_std x',     'avg_x':  {'value': -3, 'units': 'mm'},     'sigma_x':{'value':  5, 'units': 'mm'} }  gen['transforms']={'sx':setx} beam = gen.beam()  print('Input:\\n',yaml.dump(gen.input['transforms']))  plot_dist2d(beam, 'x', units['x'], 'y', units['y'], axis='equal', title_on=True); <pre>Input:\n sx:\n  avg_x:\n    units: millimeter\n    value: -3.0\n  sigma_x:\n    units: millimeter\n    value: 5.0\n  type: set_avg_and_std x\n\n</pre> <p>Rotation between two coordinates is accomplished using transforms.rotate2d.  In addition to the beam object, the user must specify the variables to rotate.  This can be done in a string of the form 'var1:var2' or as a list of strs ['var1','var2'].  The variables supplied must have the same type of units.  The user must also specify an angle in radians or degrees to rotate by.</p> <p>Note, the default behavior is to rotate around the coordinate origins (not the coordinate averages) as seen in the plot on the left below. The rotation can be performed about a different origin by setting the keyword arguement 'origin'.  Often it is desirable to set the origin of rotation to be the coordinate centroids. This is done by setting origin='centroid' (as seen in the plot on the right below).</p> In\u00a0[9]: Copied! <pre>from distgen.transforms import rotate2d\n\ngen=Generator('data/beer.can.in.yaml',verbose=0)\n\nscalex = {'type':'scale x', 'scale':3}\nshiftx = {'type': 'translate x', 'delta': {'value': 5, 'units': 'mm'}}\nrotxy = {'type':'rotate2d x:y', 'angle':{'value':45, 'units':'deg'}}\n            \ngen['transforms']={'sx':scalex, 'shx':shiftx, 'rxy':rotxy, 'order':['sx','shx','rxy']}\nobeam = gen.beam()\n\n# do with rotation around centroid\ngen['transforms:rxy']={'type':'rotate2d x:y', 'angle':{'value':45, 'units':'deg'}, 'origin':'centroid'}\n\ncbeam = gen.beam()\nprint('YAML input:\\n', yaml.dump(gen.input['transforms']))\n\nfig, ax = plt.subplots(1, 2, sharex='col',constrained_layout=True)\nplot_dist2d(obeam, 'x', units['x'], 'y', units['y'], ax=ax[0], axis=\"equal\");\nax[0].set_title('Rotated around origin');\n\nplot_dist2d(cbeam, 'x', units['x'], 'y', units['y'], ax=ax[1], axis=\"equal\");\nax[1].set_title('Rotated around centroids');\n</pre> from distgen.transforms import rotate2d  gen=Generator('data/beer.can.in.yaml',verbose=0)  scalex = {'type':'scale x', 'scale':3} shiftx = {'type': 'translate x', 'delta': {'value': 5, 'units': 'mm'}} rotxy = {'type':'rotate2d x:y', 'angle':{'value':45, 'units':'deg'}}              gen['transforms']={'sx':scalex, 'shx':shiftx, 'rxy':rotxy, 'order':['sx','shx','rxy']} obeam = gen.beam()  # do with rotation around centroid gen['transforms:rxy']={'type':'rotate2d x:y', 'angle':{'value':45, 'units':'deg'}, 'origin':'centroid'}  cbeam = gen.beam() print('YAML input:\\n', yaml.dump(gen.input['transforms']))  fig, ax = plt.subplots(1, 2, sharex='col',constrained_layout=True) plot_dist2d(obeam, 'x', units['x'], 'y', units['y'], ax=ax[0], axis=\"equal\"); ax[0].set_title('Rotated around origin');  plot_dist2d(cbeam, 'x', units['x'], 'y', units['y'], ax=ax[1], axis=\"equal\"); ax[1].set_title('Rotated around centroids'); <pre>YAML input:\n order:\n- sx\n- shx\n- rxy\nrxy:\n  angle:\n    units: degree\n    value: 45.0\n  origin: centroid\n  type: rotate2d x:y\nshx:\n  delta:\n    units: millimeter\n    value: 5.0\n  type: translate x\nsx:\n  scale: 3\n  type: scale x\n\n</pre> <p>The shear operation allows one to apply a sheer in a 2D subspace according of the form:</p> <p>$v\\rightarrow v + \\alpha u$</p> <p>This can be useful in a variety of cases such as drifting particles.</p> In\u00a0[10]: Copied! <pre>from distgen.transforms import shear\n\ngen=Generator('data/x.y.uniform.in.yaml',verbose=0)\nbeam1=gen.beam()\n\ngen['transforms']= {'s':{'type':'shear x:y', 'shear_coefficient':{'value': 0.5, 'units': ''}} }\nbeam2=gen.beam()\nprint('YAML:\\n',yaml.dump(gen.input['transforms']))\n\nfig, ax = plt.subplots(1, 2, constrained_layout=True)\nplot_dist2d(beam1, 'x', units['x'], 'y', units['y'], axis=\"equal\",ax=ax[0]);\nax[0].set_title('Before')\n\nplot_dist2d(beam2, 'x', units['x'], 'y', units['y'], axis=\"equal\", ax=ax[1]);\nax[1].set_title('After');\n</pre> from distgen.transforms import shear  gen=Generator('data/x.y.uniform.in.yaml',verbose=0) beam1=gen.beam()  gen['transforms']= {'s':{'type':'shear x:y', 'shear_coefficient':{'value': 0.5, 'units': ''}} } beam2=gen.beam() print('YAML:\\n',yaml.dump(gen.input['transforms']))  fig, ax = plt.subplots(1, 2, constrained_layout=True) plot_dist2d(beam1, 'x', units['x'], 'y', units['y'], axis=\"equal\",ax=ax[0]); ax[0].set_title('Before')  plot_dist2d(beam2, 'x', units['x'], 'y', units['y'], axis=\"equal\", ax=ax[1]); ax[1].set_title('After'); <pre>YAML:\n s:\n  shear_coefficient:\n    units: dimensionless\n    value: 0.5\n  type: shear x:y\n\n</pre> <p>Magnetizing a cylindrical beam provides a more physically relevant application of the sheer function.  Here the magnetization $\\mathcal{L}$ is added to the particle momentum in the form $p_x\\rightarrow p_x + \\frac{\\mathcal{L}}{\\sigma_{x,y}^2}y$ and $p_y\\rightarrow p_y - \\frac{\\mathcal{L}}{\\sigma_{x,y}^2}x$.  This results in a transverse emittance of $\\sqrt{\\epsilon_{n,x,uncor}^2 + \\mathcal{L}^2}$.  Note that using the definitions of cylindrical variables it is possible to show this is equivalent to a sheer of $p_{\\theta}\\rightarrow p_{\\theta}-\\frac{\\mathcal{L}}{\\sigma_{x,y}^2}r$.</p> <p>For symplicity, a magnetization function has been defined to perform the above transform given the magnetization $\\mathcal{L}$.  Currently this assumes a cylindrically symmetric bunch.</p> In\u00a0[11]: Copied! <pre>from distgen import PHYSICAL_CONSTANTS\nfrom distgen.transforms import magnetize\n\nc = PHYSICAL_CONSTANTS['speed of light in vacuum']\nMC2 = PHYSICAL_CONSTANTS.species('electron')['mc2']\n\ngen = Generator('data/beer.can.in.yaml',verbose=0)\n\nfig, ax = plt.subplots(1, 2, constrained_layout=True, figsize=(10,4))\n\nibeam = gen.beam()\nplot_dist2d(ibeam, 'r', units['r'], 'ptheta', units['px'], ax=ax[0], title_on=True);\nax[0].set_title(f'Before\\n{ax[0].get_title()}')\n\nLmag = -50*unit('micrometer')*MC2.magnitude*unit('eV/c')\nprint(f'{Lmag.units:~P}')\nmagnetize = {\n    'type':'magnetize r:ptheta',\n    'magnetization':{'value': Lmag.magnitude, 'units': str(Lmag.units)},\n}\n\ngen['transforms']={'m':magnetize}\n\nprint('YAML:\\n',yaml.dump(gen.input['transforms']))\n\nfbeam = gen.beam()\nplot_dist2d(fbeam, 'r', units['r'], 'ptheta', units['px'], ax=ax[1], title_on=True);\nax[1].set_title(f'After\\n{ax[1].get_title()}');\n\neni = 0.5*(ibeam.emitt('x','normalized') + ibeam.emitt('y', 'normalized'))\nenf = 0.5*(fbeam.emitt('x','normalized') + fbeam.emitt('y', 'normalized'))\n\nenf0 = np.sqrt(eni**2 + (Lmag/(MC2/c).to('eV/c'))**2)\nerr = (enf/enf0-1)\n\nprint(f'Initial emittance: {eni.to(\"um\"):G~P}')\nprint(f'Final emittance: {enf.to(\"um\"):G~P}')\nprint(f'Error: {100*err.magnitude} %')\n</pre> from distgen import PHYSICAL_CONSTANTS from distgen.transforms import magnetize  c = PHYSICAL_CONSTANTS['speed of light in vacuum'] MC2 = PHYSICAL_CONSTANTS.species('electron')['mc2']  gen = Generator('data/beer.can.in.yaml',verbose=0)  fig, ax = plt.subplots(1, 2, constrained_layout=True, figsize=(10,4))  ibeam = gen.beam() plot_dist2d(ibeam, 'r', units['r'], 'ptheta', units['px'], ax=ax[0], title_on=True); ax[0].set_title(f'Before\\n{ax[0].get_title()}')  Lmag = -50*unit('micrometer')*MC2.magnitude*unit('eV/c') print(f'{Lmag.units:~P}') magnetize = {     'type':'magnetize r:ptheta',     'magnetization':{'value': Lmag.magnitude, 'units': str(Lmag.units)}, }  gen['transforms']={'m':magnetize}  print('YAML:\\n',yaml.dump(gen.input['transforms']))  fbeam = gen.beam() plot_dist2d(fbeam, 'r', units['r'], 'ptheta', units['px'], ax=ax[1], title_on=True); ax[1].set_title(f'After\\n{ax[1].get_title()}');  eni = 0.5*(ibeam.emitt('x','normalized') + ibeam.emitt('y', 'normalized')) enf = 0.5*(fbeam.emitt('x','normalized') + fbeam.emitt('y', 'normalized'))  enf0 = np.sqrt(eni**2 + (Lmag/(MC2/c).to('eV/c'))**2) err = (enf/enf0-1)  print(f'Initial emittance: {eni.to(\"um\"):G~P}') print(f'Final emittance: {enf.to(\"um\"):G~P}') print(f'Error: {100*err.magnitude} %') <pre>eV\u00b7\u00b5m/c\nYAML:\n m:\n  magnetization:\n    units: electron_volt * micrometer / speed_of_light\n    value: -25549947.499999996\n  type: magnetize r:ptheta\n\n</pre> <pre>Initial emittance: 0.541796 \u00b5m\nFinal emittance: 50.0029 \u00b5m\nError: -5.464299750457258e-05 %\n</pre> In\u00a0[12]: Copied! <pre>from distgen.transforms import polynomial\nimport numpy as np\n\ngen=Generator('data/gaussian.in.yaml',verbose=0)\n\n\n\nV0 = 1000*unit('MeV/c')\nw = 2*PHYSICAL_CONSTANTS.pi*1.3*unit('GHz')\nk = w/c\nphi = -2.5*unit('deg')\nc3 = -0.5*V0*k**2\n\npolytrans = {\n    'type':'polynomial z:pz',\n    'coefficients':[\n        {'value': V0.magnitude, 'units': str(V0.units)},\n        {'value': 0.0, 'units': 'eV/c/meter'},\n        {'value': c3.magnitude, 'units': str(c3.units)},\n    ]\n}\n\ngen['transforms']={'pt':polytrans}\n\nbeam = gen.beam()\nprint('YAML input:\\n',yaml.dump(gen.input['transforms']))\n\nplot_dist2d(beam, 'z', units['z'], 'pz', units['pz']);\n</pre> from distgen.transforms import polynomial import numpy as np  gen=Generator('data/gaussian.in.yaml',verbose=0)    V0 = 1000*unit('MeV/c') w = 2*PHYSICAL_CONSTANTS.pi*1.3*unit('GHz') k = w/c phi = -2.5*unit('deg') c3 = -0.5*V0*k**2  polytrans = {     'type':'polynomial z:pz',     'coefficients':[         {'value': V0.magnitude, 'units': str(V0.units)},         {'value': 0.0, 'units': 'eV/c/meter'},         {'value': c3.magnitude, 'units': str(c3.units)},     ] }  gen['transforms']={'pt':polytrans}  beam = gen.beam() print('YAML input:\\n',yaml.dump(gen.input['transforms']))  plot_dist2d(beam, 'z', units['z'], 'pz', units['pz']); <pre>YAML input:\n pt:\n  coefficients:\n  - units: megaelectron_volt / speed_of_light\n    value: 1000.0\n  - units: electron_volt / meter / speed_of_light\n    value: 0.0\n  - units: gigahertz ** 2 * megaelectron_volt * radian ** 2 * second ** 2 / meter\n      ** 2 / speed_of_light\n    value: -3.7117185708535e-13\n  type: polynomial z:pz\n\n</pre> In\u00a0[13]: Copied! <pre>from distgen.transforms import cosine\nimport numpy as np\n\ngen=Generator('data/gaussian.in.yaml',verbose=0)\n\nw = 2*PHYSICAL_CONSTANTS.pi*1.3*unit('GHz')\nk = w/c\n\ntcos = {\n    'type':'cosine z:pz',\n    'amplitude':{'value':1000, 'units':'MeV/c'},\n    'phase':{'value':-2.5, 'units':'deg'},\n    'omega':{'value': k.magnitude, 'units': str(k.units)}\n}\n\ngen['transforms']={'tc':tcos}\n\nbeam = gen.beam()\nprint('YAML input:\\n',yaml.dump(gen.input['transforms']))\n\nplot_dist2d(beam, 'z', units['z'], 'pz', units['pz']);\n</pre> from distgen.transforms import cosine import numpy as np  gen=Generator('data/gaussian.in.yaml',verbose=0)  w = 2*PHYSICAL_CONSTANTS.pi*1.3*unit('GHz') k = w/c  tcos = {     'type':'cosine z:pz',     'amplitude':{'value':1000, 'units':'MeV/c'},     'phase':{'value':-2.5, 'units':'deg'},     'omega':{'value': k.magnitude, 'units': str(k.units)} }  gen['transforms']={'tc':tcos}  beam = gen.beam() print('YAML input:\\n',yaml.dump(gen.input['transforms']))  plot_dist2d(beam, 'z', units['z'], 'pz', units['pz']); <pre>YAML input:\n tc:\n  amplitude:\n    units: megaelectron_volt / speed_of_light\n    value: 1000.0\n  omega:\n    units: gigahertz * radian * second / meter\n    value: 2.724598528537186e-08\n  phase:\n    units: degree\n    value: -2.5\n  type: cosine z:pz\n\n</pre> In\u00a0[14]: Copied! <pre>from distgen.transforms import set_twiss, translate\nfilename = \"data/gaussian.in.yaml\"\n\ngen = Generator(filename, verbose=0) \n\nboost_pz = {'type':'translate pz',  'delta': { 'value':1, 'units':'GeV/c',}}\n\ngen['transforms']={'boost':boost_pz}\nbeam1 = gen.beam()\n\ntwiss_x = {\n    'type':'set_twiss x', \n    'beta': {'value':12.5, 'units':'m',},\n    'alpha':{'value':-1, 'units':''},\n    'emittance': {'value':2, 'units':'nm'}\n}\n\ngen['transforms']={'boost':boost_pz, 'twiss':twiss_x, 'order':['boost','twiss']}\nbeam2 = gen.beam()\n\nprint('YAML input:\\n',yaml.dump(gen.input['transforms']))\n\nprint('Initial Horizontal Twiss params:')\nprint(f'beta: {beam1.Beta(\"x\"):G~P}, alpha: {beam1.Alpha(\"x\"):G~P}, eps: {beam1.emitt(\"x\",\"geometric\").to(\"nm\"):0.3f~P}')\n\nfig, ax = plt.subplots(1, 2, constrained_layout=True)\nplot_dist2d(beam1, 'x', units['x'], 'thetax', units['thetax'], ax=ax[0]);\nax[0].set_title('Before')\n\nplot_dist2d(beam2, 'x', units['x'], 'thetax', units[\"thetax\"], ax=ax[1]);\nax[1].set_title('After');\n\nprint('\\nFinal Horizontal Twiss params:')\nprint(f'beta: {beam2.Beta(\"x\").to(\"m\"):G~P}, alpha: {beam2.Alpha(\"x\"):G~P}, eps: {beam2.emitt(\"x\",\"geometric\").to(\"nm\"):0.3f~P}')\n</pre> from distgen.transforms import set_twiss, translate filename = \"data/gaussian.in.yaml\"  gen = Generator(filename, verbose=0)   boost_pz = {'type':'translate pz',  'delta': { 'value':1, 'units':'GeV/c',}}  gen['transforms']={'boost':boost_pz} beam1 = gen.beam()  twiss_x = {     'type':'set_twiss x',      'beta': {'value':12.5, 'units':'m',},     'alpha':{'value':-1, 'units':''},     'emittance': {'value':2, 'units':'nm'} }  gen['transforms']={'boost':boost_pz, 'twiss':twiss_x, 'order':['boost','twiss']} beam2 = gen.beam()  print('YAML input:\\n',yaml.dump(gen.input['transforms']))  print('Initial Horizontal Twiss params:') print(f'beta: {beam1.Beta(\"x\"):G~P}, alpha: {beam1.Alpha(\"x\"):G~P}, eps: {beam1.emitt(\"x\",\"geometric\").to(\"nm\"):0.3f~P}')  fig, ax = plt.subplots(1, 2, constrained_layout=True) plot_dist2d(beam1, 'x', units['x'], 'thetax', units['thetax'], ax=ax[0]); ax[0].set_title('Before')  plot_dist2d(beam2, 'x', units['x'], 'thetax', units[\"thetax\"], ax=ax[1]); ax[1].set_title('After');  print('\\nFinal Horizontal Twiss params:') print(f'beta: {beam2.Beta(\"x\").to(\"m\"):G~P}, alpha: {beam2.Alpha(\"x\"):G~P}, eps: {beam2.emitt(\"x\",\"geometric\").to(\"nm\"):0.3f~P}') <pre>YAML input:\n boost:\n  delta:\n    units: gigaelectron_volt / speed_of_light\n    value: 1.0\n  type: translate pz\norder:\n- boost\n- twiss\ntwiss:\n  alpha:\n    units: dimensionless\n    value: -1.0\n  beta:\n    units: meter\n    value: 12.5\n  emittance:\n    units: nanometer\n    value: 2.0\n  type: set_twiss x\n\nInitial Horizontal Twiss params:\nbeta: 999999 mm, alpha: 2.74102E-05, eps: 1.000 nm\n\nFinal Horizontal Twiss params:\nbeta: 12.5 m, alpha: -1, eps: 2.000 nm\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"examples/transforms/#transformation-utilties","title":"Transformation utilties\u00b6","text":""},{"location":"examples/transforms/#translations","title":"Translations\u00b6","text":""},{"location":"examples/transforms/#scaling","title":"Scaling\u00b6","text":""},{"location":"examples/transforms/#shift-and-scale-a-single-coordinate","title":"Shift and Scale a single coordinate\u00b6","text":""},{"location":"examples/transforms/#rotating-coordinates","title":"Rotating coordinates\u00b6","text":""},{"location":"examples/transforms/#shear","title":"Shear\u00b6","text":""},{"location":"examples/transforms/#polynomial","title":"Polynomial\u00b6","text":"<p>It is possible to apply a polynomial map in one beam variable to a second using the polynomial function:</p> <p>$p \\rightarrow p + \\sum_{n=0}^N a_n (x-\\mathcal{O})^n$.</p> <p>Here $p_i$ is the dependent variable before the transformation (this term can be left out by specifying the keyword zero_dependent_var=True),  the $a_n$ specify the polynomial coefficients, and $\\mathcal{O}$ is the expansion origin.  In the example used below, a quartic polynomial in $z$ is applied to $p_z$ mimicing the effect of an RF cavity:</p>"},{"location":"examples/transforms/#cosine","title":"Cosine\u00b6","text":"<p>It is often convenient to impart a cosine like energy spread to beam's longitudinal momentum.  This can be accomplished using the cosine transform:</p> <p>$p \\rightarrow p + A\\cos(\\omega v + \\phi)$.</p>"},{"location":"examples/transforms/#setting-twiss-parameters","title":"Setting Twiss parameters\u00b6","text":"<p>Often for beams at energy the user may wish to set beam Twiss parameters $\\beta$, $\\alpha$, and $\\epsilon$ for a desired 2D phase space.</p>"},{"location":"examples/data/convert2yaml/","title":"Convert2yaml","text":"In\u00a0[\u00a0]: Copied! <pre>import yaml\nimport os\n</pre> import yaml import os In\u00a0[\u00a0]: Copied! <pre>def main():\n\n    for filename in os.listdir(os.getcwd()):\n        if(filename.endswith('json')):\n            with open(filename) as fid:\n                data = yaml.safe_load(fid)\n\n            newfile = '.'.join( (filename.split('.'))[:-1] )+'.yaml'\n            with open(newfile,'w') as yid:\n                yaml.dump(data, yid, default_flow_style=False)\n</pre> def main():      for filename in os.listdir(os.getcwd()):         if(filename.endswith('json')):             with open(filename) as fid:                 data = yaml.safe_load(fid)              newfile = '.'.join( (filename.split('.'))[:-1] )+'.yaml'             with open(newfile,'w') as yid:                 yaml.dump(data, yid, default_flow_style=False) In\u00a0[\u00a0]: Copied! <pre>if __name__==main():\n    #main()\n    filename='tukey.beer.can.in.json'\n    with open(filename) as fid:\n        data = yaml.safe_load(fid)\n\n    newfile='tukey.beer.can.in.yaml'\n    with open(newfile,'w') as yid:\n        yaml.dump(data, yid, default_flow_style=False)\n</pre> if __name__==main():     #main()     filename='tukey.beer.can.in.json'     with open(filename) as fid:         data = yaml.safe_load(fid)      newfile='tukey.beer.can.in.yaml'     with open(newfile,'w') as yid:         yaml.dump(data, yid, default_flow_style=False)"},{"location":"examples/data/convert_examples/","title":"Convert examples","text":"In\u00a0[\u00a0]: Copied! <pre>import json\nimport os\nimport copy\n</pre> import json import os import copy In\u00a0[\u00a0]: Copied! <pre>def main():\n\n    exs = {}\n\n    files = os.listdir('.')\n    for filename in files:\n\n        if(filename.endswith('json') and 'examples' not in filename):\n            print(filename)\n            with open(filename) as jid:\n                data = json.load(jid)\n\n            ndata = copy.deepcopy(data)\n\n            ndata['total_charge']=data['beam']['params']['total_charge']\n            ndata['n_particles']=data['generator']['rand']['count'] \n            ndata['random_type']=data['generator']['rand']['type'] \n            ndata['count']=data['generator']['rand']['count']\n\n            del[ndata['generator']]\n            del[ndata['beam']]\n\n            exs[filename[:-8]]=ndata\n\n    \n\n    with open('examples.json','w') as jfile:\n        json.dump(exs,jfile,indent=4,sort_keys=True)\n</pre> def main():      exs = {}      files = os.listdir('.')     for filename in files:          if(filename.endswith('json') and 'examples' not in filename):             print(filename)             with open(filename) as jid:                 data = json.load(jid)              ndata = copy.deepcopy(data)              ndata['total_charge']=data['beam']['params']['total_charge']             ndata['n_particles']=data['generator']['rand']['count']              ndata['random_type']=data['generator']['rand']['type']              ndata['count']=data['generator']['rand']['count']              del[ndata['generator']]             del[ndata['beam']]              exs[filename[:-8]]=ndata            with open('examples.json','w') as jfile:         json.dump(exs,jfile,indent=4,sort_keys=True) In\u00a0[\u00a0]: Copied! <pre>if __name__== \"__main__\":\n    main()\n</pre> if __name__== \"__main__\":     main()"},{"location":"examples/data/fix_random_keys/","title":"Fix random keys","text":"In\u00a0[1]: Copied! <pre># Useful for debugging\n%load_ext autoreload\n%autoreload 2\n%config InlineBackend.figure_format = 'retina'\nimport yaml\nfrom glob import glob\nfrom pathlib import Path\n</pre> # Useful for debugging %load_ext autoreload %autoreload 2 %config InlineBackend.figure_format = 'retina' import yaml from glob import glob from pathlib import Path In\u00a0[2]: Copied! <pre>yamls = glob('*yaml')\n</pre> yamls = glob('*yaml') In\u00a0[3]: Copied! <pre>for y in yamls:\n    \n    with open(y, 'r') as fid:\n        inputs = yaml.safe_load(fid)\n        \n        if('random_type' in inputs):\n            del inputs['random_type']\n            \n        inputs['random']={'type':'hammersley'}\n    \n    with open(y, 'w') as fid:\n        yaml.dump(inputs, fid)\n</pre> for y in yamls:          with open(y, 'r') as fid:         inputs = yaml.safe_load(fid)                  if('random_type' in inputs):             del inputs['random_type']                      inputs['random']={'type':'hammersley'}          with open(y, 'w') as fid:         yaml.dump(inputs, fid)  In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"regression_tests/Generator/","title":"Generator","text":"In\u00a0[1]: Copied! <pre>from distgen import Generator\nfrom distgen import PHYSICAL_CONSTANTS\nfrom distgen.tools import check_abs_and_rel_tols\n</pre> from distgen import Generator from distgen import PHYSICAL_CONSTANTS from distgen.tools import check_abs_and_rel_tols  In\u00a0[2]: Copied! <pre>def test_getitem_():\n\n    ins =\"\"\"\nn_particle: 200000\nspecies: electron\nr_dist:\n  sigma_xy: 1.0 mm\n  type: radial_gaussian\nrandom:\n  type: hammersley\nstart:\n  tstart: 0 sec\n  type: time\ntotal_charge: 10 pC\n\"\"\"\n\n    D = Generator(ins)\n    assert D['r_dist:sigma_xy']['value']==1\n    assert D['r_dist:sigma_xy']['units']=='millimeter'\n    \ntest_getitem_()\n</pre> def test_getitem_():      ins =\"\"\" n_particle: 200000 species: electron r_dist:   sigma_xy: 1.0 mm   type: radial_gaussian random:   type: hammersley start:   tstart: 0 sec   type: time total_charge: 10 pC \"\"\"      D = Generator(ins)     assert D['r_dist:sigma_xy']['value']==1     assert D['r_dist:sigma_xy']['units']=='millimeter'      test_getitem_() In\u00a0[3]: Copied! <pre>def test_setitem_():\n    ins =\"\"\"\nn_particle: 200000\nspecies: electron\nr_dist:\n  sigma_xy: 1.0 mm\n  type: radial_gaussian\nrandom:\n  type: hammersley\nstart:\n  tstart: 0 sec\n  type: time\ntotal_charge: 10 pC\n\"\"\"\n    \n    D = Generator(ins)\n    D['r_dist:sigma_xy'] = 2.0\n    \n    assert isinstance(D['r_dist:sigma_xy'], dict)\n    assert D['r_dist:sigma_xy']['value']==2\n    assert D['r_dist:sigma_xy']['units']=='millimeter'\n\n    D['r_dist:sigma_xy:units'] = 'cm'\n    assert D['r_dist:sigma_xy']['value']==2\n    assert D['r_dist:sigma_xy']['units']=='centimeter'\n\n    D['r_dist:sigma_xy:value'] = 3\n    assert D['r_dist:sigma_xy']['value']==3\n    assert D['r_dist:sigma_xy']['units']=='centimeter'\n    \n    D['r_dist:sigma_xy'] = '4 um'\n    assert D['r_dist:sigma_xy']['value']==4\n    assert D['r_dist:sigma_xy']['units']=='micrometer'\n\ntest_setitem_()\n</pre> def test_setitem_():     ins =\"\"\" n_particle: 200000 species: electron r_dist:   sigma_xy: 1.0 mm   type: radial_gaussian random:   type: hammersley start:   tstart: 0 sec   type: time total_charge: 10 pC \"\"\"          D = Generator(ins)     D['r_dist:sigma_xy'] = 2.0          assert isinstance(D['r_dist:sigma_xy'], dict)     assert D['r_dist:sigma_xy']['value']==2     assert D['r_dist:sigma_xy']['units']=='millimeter'      D['r_dist:sigma_xy:units'] = 'cm'     assert D['r_dist:sigma_xy']['value']==2     assert D['r_dist:sigma_xy']['units']=='centimeter'      D['r_dist:sigma_xy:value'] = 3     assert D['r_dist:sigma_xy']['value']==3     assert D['r_dist:sigma_xy']['units']=='centimeter'          D['r_dist:sigma_xy'] = '4 um'     assert D['r_dist:sigma_xy']['value']==4     assert D['r_dist:sigma_xy']['units']=='micrometer'  test_setitem_() In\u00a0[4]: Copied! <pre>def test_species_rest_energy():\n\n    inputs= {'n_particle': 1000,\n             'total_charge': '0 C',\n             'species': None,\n             'start': {'type': 'time'}\n            }\n\n    for species in PHYSICAL_CONSTANTS.species_list:\n\n        inputs['species'] = species\n        inputs['total_charge'] = f'{inputs[\"n_particle\"]*PHYSICAL_CONSTANTS.species(species)[\"charge\"].magnitude} C'\n\n        D = Generator(inputs)\n        B = D.beam()\n\n        check_abs_and_rel_tols('rest energy', \n                               B['energy'], \n                               PHYSICAL_CONSTANTS.species(species)['mc2'],\n                               abs_tol=1e-6)\n\ntest_species_rest_energy()\n</pre> def test_species_rest_energy():      inputs= {'n_particle': 1000,              'total_charge': '0 C',              'species': None,              'start': {'type': 'time'}             }      for species in PHYSICAL_CONSTANTS.species_list:          inputs['species'] = species         inputs['total_charge'] = f'{inputs[\"n_particle\"]*PHYSICAL_CONSTANTS.species(species)[\"charge\"].magnitude} C'          D = Generator(inputs)         B = D.beam()          check_abs_and_rel_tols('rest energy',                                 B['energy'],                                 PHYSICAL_CONSTANTS.species(species)['mc2'],                                abs_tol=1e-6)  test_species_rest_energy() In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"regression_tests/beam/","title":"Beam Class Regression Tests","text":"In\u00a0[1]: Copied! <pre>%load_ext autoreload\n%autoreload 2\n</pre> %load_ext autoreload %autoreload 2 In\u00a0[2]: Copied! <pre>import numpy as np\nfrom distgen import Generator\nfrom distgen.physical_constants import PHYSICAL_CONSTANTS\nfrom distgen.tools import check_abs_and_rel_tols\nfrom glob import glob\n</pre> import numpy as np from distgen import Generator from distgen.physical_constants import PHYSICAL_CONSTANTS from distgen.tools import check_abs_and_rel_tols from glob import glob In\u00a0[3]: Copied! <pre>yaml_files = list( glob('../examples/data/*.yaml') )\n\ncoordinates = {'x', 'y', 'z', 'px', 'py', 'pz', \n               'r', 'theta', 'pr', 'ptheta', \n               'xp', 'yp', 'thetax', 'thetay',\n               'gamma', 'energy', 'kinetic_energy', \n               'beta_x', 'beta_y', 'beta_z'}\n\ndef run_test_on_input_file(input_file, test):\n    G = Generator(input_file, verbose=0)\n    G['n_particle']=10_000\n    test(G.beam())\n\ndef run_test_on_input_files(input_files, test, verbose=False):\n    \n    for input_file in input_files:\n        if(verbose): \n            print('Testing:', input_file)\n            \n        run_test_on_input_file(input_file, test)\n</pre> yaml_files = list( glob('../examples/data/*.yaml') )  coordinates = {'x', 'y', 'z', 'px', 'py', 'pz',                 'r', 'theta', 'pr', 'ptheta',                 'xp', 'yp', 'thetax', 'thetay',                'gamma', 'energy', 'kinetic_energy',                 'beta_x', 'beta_y', 'beta_z'}  def run_test_on_input_file(input_file, test):     G = Generator(input_file, verbose=0)     G['n_particle']=10_000     test(G.beam())  def run_test_on_input_files(input_files, test, verbose=False):          for input_file in input_files:         if(verbose):              print('Testing:', input_file)                      run_test_on_input_file(input_file, test) In\u00a0[4]: Copied! <pre>def test_weight_normalization(beam):\n    check_abs_and_rel_tols('macroparticle weights', np.sum(beam['w']), 1.0, abs_tol=1e-12, rel_tol=1e-15)\n\nrun_test_on_input_files(yaml_files, test_weight_normalization)\n</pre> def test_weight_normalization(beam):     check_abs_and_rel_tols('macroparticle weights', np.sum(beam['w']), 1.0, abs_tol=1e-12, rel_tol=1e-15)  run_test_on_input_files(yaml_files, test_weight_normalization) <p>$\\langle \\mathcal{O}\\rangle = \\sum_i w_i \\mathcal{O}_i$</p> In\u00a0[5]: Copied! <pre>def test_avg(beam):\n    for var in coordinates:\n        avg_beam, avg_numpy = beam.avg(var), np.sum(beam['w']*beam[var])\n        check_abs_and_rel_tols('beam.avg', avg_beam, avg_numpy, abs_tol=1e-12, rel_tol=1e-15)  \n\nrun_test_on_input_files(yaml_files, test_avg)\n</pre> def test_avg(beam):     for var in coordinates:         avg_beam, avg_numpy = beam.avg(var), np.sum(beam['w']*beam[var])         check_abs_and_rel_tols('beam.avg', avg_beam, avg_numpy, abs_tol=1e-12, rel_tol=1e-15)    run_test_on_input_files(yaml_files, test_avg) <p>$\\sigma_{\\mathcal{O}}^2 = \\sum_i w_i (\\mathcal{O}_i-\\langle \\mathcal{O}\\rangle)^2 $</p> In\u00a0[6]: Copied! <pre>def test_std(beam):\n    for var in coordinates:\n        sigma2_beam = beam.std(var)**2\n        sigma2_numpy = np.sum(beam['w']*(beam[var]-beam.avg(var))**2)\n        check_abs_and_rel_tols('beam.std', sigma2_beam, sigma2_numpy, abs_tol=1e-8, rel_tol=1e-15)\n\nrun_test_on_input_files(yaml_files, test_std)\n</pre> def test_std(beam):     for var in coordinates:         sigma2_beam = beam.std(var)**2         sigma2_numpy = np.sum(beam['w']*(beam[var]-beam.avg(var))**2)         check_abs_and_rel_tols('beam.std', sigma2_beam, sigma2_numpy, abs_tol=1e-8, rel_tol=1e-15)  run_test_on_input_files(yaml_files, test_std) <p>$r=\\sqrt{ x^2 + y^2 }$</p> In\u00a0[7]: Copied! <pre>def test_r(beam):\n    check_abs_and_rel_tols('beam.r', beam['r'], np.sqrt(beam['x']**2 + beam['y']**2), abs_tol=1e-15, rel_tol=1e-15)\n\nrun_test_on_input_files(yaml_files, test_r)\n</pre> def test_r(beam):     check_abs_and_rel_tols('beam.r', beam['r'], np.sqrt(beam['x']**2 + beam['y']**2), abs_tol=1e-15, rel_tol=1e-15)  run_test_on_input_files(yaml_files, test_r) <p>$x=r\\cos\\theta$</p> In\u00a0[8]: Copied! <pre>def test_x(beam):\n    check_abs_and_rel_tols('beam.x = r cos(theta)', beam['x'], beam['r']*np.cos(beam['theta']), abs_tol=1e-12, rel_tol=1e-11)\n\nrun_test_on_input_files(yaml_files, test_x)\n</pre> def test_x(beam):     check_abs_and_rel_tols('beam.x = r cos(theta)', beam['x'], beam['r']*np.cos(beam['theta']), abs_tol=1e-12, rel_tol=1e-11)  run_test_on_input_files(yaml_files, test_x) <p>$y = r\\sin\\theta$</p> In\u00a0[9]: Copied! <pre>def test_y(beam):\n    check_abs_and_rel_tols('beam.y = r sin(theta)', beam['y'], beam['r']*np.sin(beam['theta']), abs_tol=1e-12, rel_tol=1e-11)\n\nrun_test_on_input_files(yaml_files, test_y)\n</pre> def test_y(beam):     check_abs_and_rel_tols('beam.y = r sin(theta)', beam['y'], beam['r']*np.sin(beam['theta']), abs_tol=1e-12, rel_tol=1e-11)  run_test_on_input_files(yaml_files, test_y) <p>$p_r = p_x\\cos\\theta + p_y\\sin\\theta$</p> In\u00a0[10]: Copied! <pre>def test_pr(beam):\n    check_abs_and_rel_tols('beam.pr = px cos(theta) + py sin(theta)', beam['pr'],\n                           beam['px']*np.cos(beam['theta']) + beam['py']*np.sin(beam['theta']), \n                           abs_tol=1e-12, rel_tol=1e-15)\n\n\nrun_test_on_input_files(yaml_files, test_pr)\n</pre> def test_pr(beam):     check_abs_and_rel_tols('beam.pr = px cos(theta) + py sin(theta)', beam['pr'],                            beam['px']*np.cos(beam['theta']) + beam['py']*np.sin(beam['theta']),                             abs_tol=1e-12, rel_tol=1e-15)   run_test_on_input_files(yaml_files, test_pr) <p>$p_{\\theta} = -p_x\\sin\\theta + p_y\\cos\\theta$</p> In\u00a0[11]: Copied! <pre>def test_ptheta(beam):\n    check_abs_and_rel_tols('beam.ptheta = -px sin(theta) + py cos(theta)', \n                           beam['ptheta'],\n                           -beam['px']*np.sin(beam['theta']) + beam['py']*np.cos(beam['theta']), \n                           abs_tol=1e-12, rel_tol=1e-15)\n\nrun_test_on_input_files(yaml_files, test_ptheta)\n</pre> def test_ptheta(beam):     check_abs_and_rel_tols('beam.ptheta = -px sin(theta) + py cos(theta)',                             beam['ptheta'],                            -beam['px']*np.sin(beam['theta']) + beam['py']*np.cos(beam['theta']),                             abs_tol=1e-12, rel_tol=1e-15)  run_test_on_input_files(yaml_files, test_ptheta) <p>$x^{\\prime} = p_x/p_z$</p> In\u00a0[12]: Copied! <pre>def test_xp(beam):\n    check_abs_and_rel_tols('beam.xp = px/pz', beam['xp'], beam['px'].to(beam['pz'].units)/beam['pz'], abs_tol=1e-14, rel_tol=1e-15)\n\nrun_test_on_input_files(yaml_files, test_xp)\n</pre> def test_xp(beam):     check_abs_and_rel_tols('beam.xp = px/pz', beam['xp'], beam['px'].to(beam['pz'].units)/beam['pz'], abs_tol=1e-14, rel_tol=1e-15)  run_test_on_input_files(yaml_files, test_xp) <p>$y^{\\prime} = p_y/p_z$</p> In\u00a0[13]: Copied! <pre>def test_yp(beam):\n    check_abs_and_rel_tols('beam.yp = py/pz', beam['yp'], beam['py'].to(beam['pz'].units)/beam['pz'], abs_tol=1e-14, rel_tol=1e-15)\n\nrun_test_on_input_files(yaml_files, test_yp)\n</pre> def test_yp(beam):     check_abs_and_rel_tols('beam.yp = py/pz', beam['yp'], beam['py'].to(beam['pz'].units)/beam['pz'], abs_tol=1e-14, rel_tol=1e-15)  run_test_on_input_files(yaml_files, test_yp) <p>$\\theta_x = \\arctan(p_x/p_z)$</p> In\u00a0[14]: Copied! <pre>def test_thetax(beam):\n    check_abs_and_rel_tols('beam.thetax = arctan(px/pz)', \n                           beam['thetax'], \n                           np.arctan2(beam['px'].to(beam['pz'].units), beam['pz']), \n                           abs_tol=1e-15, rel_tol=1e-15)\n\nrun_test_on_input_files(yaml_files, test_thetax)\n</pre> def test_thetax(beam):     check_abs_and_rel_tols('beam.thetax = arctan(px/pz)',                             beam['thetax'],                             np.arctan2(beam['px'].to(beam['pz'].units), beam['pz']),                             abs_tol=1e-15, rel_tol=1e-15)  run_test_on_input_files(yaml_files, test_thetax) <p>$\\theta_y = \\arctan(p_y/p_z)$</p> In\u00a0[15]: Copied! <pre>def test_thetay(beam):\n    check_abs_and_rel_tols('beam.thetay = arctan(py/pz)', \n                           beam['thetay'], \n                           np.arctan2(beam['py'].to(beam['pz'].units), beam['pz']), \n                           abs_tol=1e-15, rel_tol=1e-15)\n\nrun_test_on_input_files(yaml_files, test_thetay)\n</pre> def test_thetay(beam):     check_abs_and_rel_tols('beam.thetay = arctan(py/pz)',                             beam['thetay'],                             np.arctan2(beam['py'].to(beam['pz'].units), beam['pz']),                             abs_tol=1e-15, rel_tol=1e-15)  run_test_on_input_files(yaml_files, test_thetay) In\u00a0[16]: Copied! <pre>def test_p(beam):\n    deviation = np.abs(beam['p'] - np.sqrt(beam['px']**2 +beam['py']**2 + beam['pz']**2))\n    check_abs_and_rel_tols('beam.p = sqrt(px^2 + py^2 + pz^2)', \n                           beam['p'], \n                           np.sqrt(beam['px']**2 +beam['py']**2 + beam['pz']**2), \n                           abs_tol=1e-15, rel_tol=1e-15)\n\nrun_test_on_input_files(yaml_files, test_p)\n</pre> def test_p(beam):     deviation = np.abs(beam['p'] - np.sqrt(beam['px']**2 +beam['py']**2 + beam['pz']**2))     check_abs_and_rel_tols('beam.p = sqrt(px^2 + py^2 + pz^2)',                             beam['p'],                             np.sqrt(beam['px']**2 +beam['py']**2 + beam['pz']**2),                             abs_tol=1e-15, rel_tol=1e-15)  run_test_on_input_files(yaml_files, test_p) <p>$E = \\sqrt{c^2|\\vec{p}|^2 + (mc^2)^2}$</p> In\u00a0[17]: Copied! <pre>def test_energy(beam):\n\n    c = PHYSICAL_CONSTANTS['speed of light in vacuum']\n\n    check_abs_and_rel_tols('beam.energy = sqrt(c^2p^2 + (mc^2)^2)', \n                           beam['energy'], \n                           np.sqrt(c**2*beam['p']**2 + beam.mc2**2), \n                           abs_tol=1e-9, rel_tol=1e-15)\n\nrun_test_on_input_files(yaml_files, test_energy)\n</pre> def test_energy(beam):      c = PHYSICAL_CONSTANTS['speed of light in vacuum']      check_abs_and_rel_tols('beam.energy = sqrt(c^2p^2 + (mc^2)^2)',                             beam['energy'],                             np.sqrt(c**2*beam['p']**2 + beam.mc2**2),                             abs_tol=1e-9, rel_tol=1e-15)  run_test_on_input_files(yaml_files, test_energy) <p>$\\gamma = \\sqrt{1+\\left(\\frac{p}{mc}\\right)^2}$, $E/mc^2$</p> In\u00a0[18]: Copied! <pre>def test_gamma(beam):\n\n    mc = beam.species_mass * PHYSICAL_CONSTANTS['speed of light in vacuum']\n    \n    check_abs_and_rel_tols('beam.gamma = sqrt( 1 + (p/mc)^2 )', \n                           beam['gamma'], \n                           np.sqrt(1+ (beam['p']/mc).to_reduced_units()**2),\n                           abs_tol=1e-10, rel_tol=1e-10)\n\n    check_abs_and_rel_tols('beam.gamma = E/mc^2', \n                           beam['gamma'], \n                           beam['energy']/beam.mc2,\n                           abs_tol=1e-15, rel_tol=1e-15)\n\nrun_test_on_input_files(yaml_files, test_gamma)\n</pre> def test_gamma(beam):      mc = beam.species_mass * PHYSICAL_CONSTANTS['speed of light in vacuum']          check_abs_and_rel_tols('beam.gamma = sqrt( 1 + (p/mc)^2 )',                             beam['gamma'],                             np.sqrt(1+ (beam['p']/mc).to_reduced_units()**2),                            abs_tol=1e-10, rel_tol=1e-10)      check_abs_and_rel_tols('beam.gamma = E/mc^2',                             beam['gamma'],                             beam['energy']/beam.mc2,                            abs_tol=1e-15, rel_tol=1e-15)  run_test_on_input_files(yaml_files, test_gamma) <p>$\\beta = \\frac{c|\\vec{p}|}{E}$</p> In\u00a0[19]: Copied! <pre>def test_beta(beam):\n    check_abs_and_rel_tols('beam.beta = c|p|/E', \n                           beam['beta'], \n                           PHYSICAL_CONSTANTS['speed of light in vacuum']*beam.p/beam.energy,\n                           abs_tol=1e-11, rel_tol=1e-14)\n\n    assert max(beam['beta']) &lt; 1, 'max(beta) &gt; 1, faster than light particle!'\n\nrun_test_on_input_files(yaml_files, test_beta)\n</pre> def test_beta(beam):     check_abs_and_rel_tols('beam.beta = c|p|/E',                             beam['beta'],                             PHYSICAL_CONSTANTS['speed of light in vacuum']*beam.p/beam.energy,                            abs_tol=1e-11, rel_tol=1e-14)      assert max(beam['beta']) &lt; 1, 'max(beta) &gt; 1, faster than light particle!'  run_test_on_input_files(yaml_files, test_beta) <p>$\\beta_{x_i} = \\frac{cp_{x_i}}{E}$, $\\beta_x = x^{\\prime}\\beta_z$, $\\beta_y = y^{\\prime}\\beta_z$,  $\\beta_z = \\frac{\\beta}{\\sqrt{1+(x^{\\prime})^2 +(y^{\\prime})^2}}$</p> In\u00a0[20]: Copied! <pre>def test_beta_xi(beam):\n\n    for var in ['x', 'y', 'z']:\n        check_abs_and_rel_tols('beam.beta_xi = c pxi/E )', \n                           beam[f'beta_{var}'], \n                           (PHYSICAL_CONSTANTS['speed of light in vacuum']*beam[f'p{var}']/beam['energy']).to_reduced_units(),\n                           abs_tol=1e-15, rel_tol=1e-15)\n\n        check_abs_and_rel_tols(\"beam.beta_z = sign(pz)*beta/sqrt( 1 + x'^2 + y'^2 )\", \n                           beam['beta_z'], \n                           np.sign(beam['pz'])*beam['beta']/np.sqrt( 1 + beam['xp']**2 + beam['yp']**2 ),\n                           abs_tol=1e-11, rel_tol=5e-9)\n\nrun_test_on_input_files(yaml_files, test_beta_xi)\n</pre> def test_beta_xi(beam):      for var in ['x', 'y', 'z']:         check_abs_and_rel_tols('beam.beta_xi = c pxi/E )',                             beam[f'beta_{var}'],                             (PHYSICAL_CONSTANTS['speed of light in vacuum']*beam[f'p{var}']/beam['energy']).to_reduced_units(),                            abs_tol=1e-15, rel_tol=1e-15)          check_abs_and_rel_tols(\"beam.beta_z = sign(pz)*beta/sqrt( 1 + x'^2 + y'^2 )\",                             beam['beta_z'],                             np.sign(beam['pz'])*beam['beta']/np.sqrt( 1 + beam['xp']**2 + beam['yp']**2 ),                            abs_tol=1e-11, rel_tol=5e-9)  run_test_on_input_files(yaml_files, test_beta_xi) <p>KE = $mc^2(\\gamma-1)$, $E-mc^2$</p> In\u00a0[21]: Copied! <pre>def test_kinetic_energy(beam):\n\n    if(PHYSICAL_CONSTANTS.species(beam['species'])['mass']&gt;0):\n    \n        check_abs_and_rel_tols('beam.kinetic_energy = mc2*(gamma-1)', \n                               beam['kinetic_energy'], \n                               beam.mc2*(beam['gamma']-1),\n                               abs_tol=1e-9, rel_tol=1e-05)\n\n    check_abs_and_rel_tols('beam.kinetic_energy = E - mc2', \n                           beam['kinetic_energy'], \n                           beam['energy'] - beam.mc2,\n                           abs_tol=1e-15, rel_tol=1e-15)\n\nrun_test_on_input_files(yaml_files, test_kinetic_energy)\n</pre> def test_kinetic_energy(beam):      if(PHYSICAL_CONSTANTS.species(beam['species'])['mass']&gt;0):              check_abs_and_rel_tols('beam.kinetic_energy = mc2*(gamma-1)',                                 beam['kinetic_energy'],                                 beam.mc2*(beam['gamma']-1),                                abs_tol=1e-9, rel_tol=1e-05)      check_abs_and_rel_tols('beam.kinetic_energy = E - mc2',                             beam['kinetic_energy'],                             beam['energy'] - beam.mc2,                            abs_tol=1e-15, rel_tol=1e-15)  run_test_on_input_files(yaml_files, test_kinetic_energy) In\u00a0[22]: Copied! <pre>def test_emitt_normalized(beam):\n    for var in ['x', 'y']:\n    \n        mc = beam.species_mass * PHYSICAL_CONSTANTS['speed of light in vacuum']\n        \n        stdx = beam.std(var)\n        stdp = (beam.std(f'p{var}')/mc).to_reduced_units()\n        dx = beam[var]-beam.avg(var)\n        dp = ( (beam[f'p{var}']-beam.avg(f'p{var}'))/mc ).to_reduced_units()\n\n        check_abs_and_rel_tols('beam.emitt (normalized)', \n                               beam.emitt(var), \n                               np.sqrt(stdx**2 * stdp**2 - (np.sum(beam['w']*dx*dp))**2),\n                               abs_tol=1e-11, rel_tol=1e-11)\n\nrun_test_on_input_files(yaml_files, test_emitt_normalized)\n</pre> def test_emitt_normalized(beam):     for var in ['x', 'y']:              mc = beam.species_mass * PHYSICAL_CONSTANTS['speed of light in vacuum']                  stdx = beam.std(var)         stdp = (beam.std(f'p{var}')/mc).to_reduced_units()         dx = beam[var]-beam.avg(var)         dp = ( (beam[f'p{var}']-beam.avg(f'p{var}'))/mc ).to_reduced_units()          check_abs_and_rel_tols('beam.emitt (normalized)',                                 beam.emitt(var),                                 np.sqrt(stdx**2 * stdp**2 - (np.sum(beam['w']*dx*dp))**2),                                abs_tol=1e-11, rel_tol=1e-11)  run_test_on_input_files(yaml_files, test_emitt_normalized) <p>$\\epsilon_{x} = \\sqrt{\\sigma_x^2\\sigma_{x^{\\prime}}^2 - \\langle \\left(x-\\langle x\\rangle\\right)\\left(x^{\\prime}-\\langle x^{\\prime}\\rangle\\right)\\rangle^2 }$</p> In\u00a0[23]: Copied! <pre>def test_emitt_geometric(beam):\n\n    for var in ['x', 'y']:\n        stdx = beam.std(var)\n        stdp = (beam.std(f'{var}p'))\n        dx = beam[var]-beam.avg(var)\n        dp = (beam[f'{var}p']-beam.avg(f'{var}p'))\n\n        check_abs_and_rel_tols('beam.emitt (geometric)', \n                               beam.emitt(var, 'geometric'), \n                               np.sqrt(stdx**2 * stdp**2 - (np.sum(beam['w']*dx*dp))**2),\n                               abs_tol=1e-14, rel_tol=1e-15)\n\nrun_test_on_input_files(yaml_files, test_emitt_geometric)\n</pre> def test_emitt_geometric(beam):      for var in ['x', 'y']:         stdx = beam.std(var)         stdp = (beam.std(f'{var}p'))         dx = beam[var]-beam.avg(var)         dp = (beam[f'{var}p']-beam.avg(f'{var}p'))          check_abs_and_rel_tols('beam.emitt (geometric)',                                 beam.emitt(var, 'geometric'),                                 np.sqrt(stdx**2 * stdp**2 - (np.sum(beam['w']*dx*dp))**2),                                abs_tol=1e-14, rel_tol=1e-15)  run_test_on_input_files(yaml_files, test_emitt_geometric) <p>Twiss $\\beta_{x_i} = \\frac{\\sigma_x^2}{\\epsilon_x}$</p> In\u00a0[24]: Copied! <pre>def twiss_beta_xi(beam):\n\n    for var in ['x', 'y']:\n        \n        stdx = beam.std(var)\n        epsx = beam.emitt(var,'geometric')\n\n        if(epsx&gt;0):\n            check_abs_and_rel_tols('beam.Beta_xi (Twiss)', \n                                   beam.Beta(var), \n                                   stdx**2/epsx ,\n                                   abs_tol=1e-14, rel_tol=1e-15)\n        \nrun_test_on_input_files(yaml_files, test_beta_xi)\n</pre> def twiss_beta_xi(beam):      for var in ['x', 'y']:                  stdx = beam.std(var)         epsx = beam.emitt(var,'geometric')          if(epsx&gt;0):             check_abs_and_rel_tols('beam.Beta_xi (Twiss)',                                     beam.Beta(var),                                     stdx**2/epsx ,                                    abs_tol=1e-14, rel_tol=1e-15)          run_test_on_input_files(yaml_files, test_beta_xi) <p>Twiss $\\alpha_{x_i} = -\\frac{\\langle(x-\\langle x\\rangle)(x^{\\prime}-\\langle x^{\\prime}\\rangle)\\rangle}{\\epsilon_x}$</p> In\u00a0[25]: Copied! <pre>def test_alpha_xi(beam):\n\n    for var in ['x', 'y']:\n        dx = beam[var]-beam.avg(var)\n        dp = (beam[f'{var}p']-beam.avg(f'{var}p'))\n        epsx = beam.emitt(var,'geometric')\n\n        if(epsx&gt;0):\n            check_abs_and_rel_tols('beam.Alpha_xi (Twiss)', \n                                   beam.Alpha(var), \n                                   -sum(beam['w']*dx*dp)/epsx,\n                                   abs_tol=1e-14, rel_tol=1e-14)\n        \nrun_test_on_input_files(yaml_files, test_alpha_xi)\n</pre> def test_alpha_xi(beam):      for var in ['x', 'y']:         dx = beam[var]-beam.avg(var)         dp = (beam[f'{var}p']-beam.avg(f'{var}p'))         epsx = beam.emitt(var,'geometric')          if(epsx&gt;0):             check_abs_and_rel_tols('beam.Alpha_xi (Twiss)',                                     beam.Alpha(var),                                     -sum(beam['w']*dx*dp)/epsx,                                    abs_tol=1e-14, rel_tol=1e-14)          run_test_on_input_files(yaml_files, test_alpha_xi)     <p>Twiss $\\gamma_{x_i} = \\frac{\\sigma_{x^{\\prime}}^2}{\\epsilon_x}$</p> In\u00a0[26]: Copied! <pre>def test_gamma_xi(beam):\n\n    for var in ['x', 'y']:\n        stdp = beam.std(f'{var}p')\n        epsx = beam.emitt(var,'geometric')\n\n        if(epsx&gt;0):\n            check_abs_and_rel_tols('beam.Gamma_xi (Twiss)', \n                                   beam.Gamma(var), \n                                   stdp**2/epsx,\n                                   abs_tol=1e-14, rel_tol=1e-14)\n\nrun_test_on_input_files(yaml_files, test_gamma_xi)\n</pre> def test_gamma_xi(beam):      for var in ['x', 'y']:         stdp = beam.std(f'{var}p')         epsx = beam.emitt(var,'geometric')          if(epsx&gt;0):             check_abs_and_rel_tols('beam.Gamma_xi (Twiss)',                                     beam.Gamma(var),                                     stdp**2/epsx,                                    abs_tol=1e-14, rel_tol=1e-14)  run_test_on_input_files(yaml_files, test_gamma_xi)  In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"regression_tests/beam/#beam-class-regression-tests","title":"Beam Class Regression Tests\u00b6","text":""},{"location":"regression_tests/beam/#statistical-tests","title":"Statistical Tests\u00b6","text":"<p>$\\sum_i w_i = 1$</p>"},{"location":"regression_tests/beam/#cylindrical-coordinates","title":"Cylindrical Coordinates\u00b6","text":""},{"location":"regression_tests/beam/#getting","title":"Getting\u00b6","text":""},{"location":"regression_tests/beam/#transverse-derivatives-and-angles","title":"Transverse Derivatives and Angles\u00b6","text":""},{"location":"regression_tests/beam/#getting","title":"Getting\u00b6","text":""},{"location":"regression_tests/beam/#relativistic-quantities","title":"Relativistic Quantities\u00b6","text":"<p>$p=\\sqrt{p_x^2 + p_y^2 + p_z^2}$</p>"},{"location":"regression_tests/beam/#twiss-parameters","title":"Twiss Parameters\u00b6","text":""},{"location":"regression_tests/beam/#getting","title":"Getting\u00b6","text":"<p>$\\epsilon_{n,x_i} = \\frac{1}{mc}\\sqrt{\\sigma_{x_i}^2\\sigma_{p_{x_i}}^2 - \\langle \\left(x_i-\\langle x_i\\rangle\\right)\\left(p_{x_i}-\\langle p_{x_i}\\rangle\\right)\\rangle^2 }$</p>"},{"location":"regression_tests/correlations/","title":"Correlation Regression Tests","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nfrom matplotlib import pyplot as plt\nimport matplotlib \n\n%matplotlib inline\n%config InlineBackend.figure_format = 'retina'\n</pre> import numpy as np from matplotlib import pyplot as plt import matplotlib   %matplotlib inline %config InlineBackend.figure_format = 'retina' In\u00a0[2]: Copied! <pre>from distgen.dist import random_generator\n\nrands = random_generator((4,1000), sequence='hammersley')\ncov = np.cov(rands)\n\nprint('Covariance of Hammersley samples:')\nprint(cov)\nplt.plot(rands[0,:], rands[1,:],'.');\n</pre> from distgen.dist import random_generator  rands = random_generator((4,1000), sequence='hammersley') cov = np.cov(rands)  print('Covariance of Hammersley samples:') print(cov) plt.plot(rands[0,:], rands[1,:],'.');   <pre>Covariance of Hammersley samples:\n[[ 8.33224805e-02 -3.68343309e-04 -6.68187387e-05  4.25010191e-04]\n [-3.68343309e-04  8.33878181e-02  7.56326104e-05  2.25221076e-04]\n [-6.68187387e-05  7.56326104e-05  8.34060346e-02  4.12948253e-04]\n [ 4.25010191e-04  2.25221076e-04  4.12948253e-04  8.32500833e-02]]\n</pre> In\u00a0[3]: Copied! <pre>rands = random_generator((4,1000), sequence='pseudo')\ncov = np.cov(rands)\nprint('Covariance of Rand samples:')\nprint(cov)\nplt.plot(rands[0,:], rands[1,:], '.')\n</pre>  rands = random_generator((4,1000), sequence='pseudo') cov = np.cov(rands) print('Covariance of Rand samples:') print(cov) plt.plot(rands[0,:], rands[1,:], '.') <pre>Covariance of Rand samples:\n[[ 0.08018895  0.00474555  0.0010819   0.00282745]\n [ 0.00474555  0.08186638 -0.00650449 -0.00019469]\n [ 0.0010819  -0.00650449  0.08513119  0.00146046]\n [ 0.00282745 -0.00019469  0.00146046  0.08407384]]\n</pre> Out[3]: <pre>[&lt;matplotlib.lines.Line2D at 0x7fdbe4ecdf70&gt;]</pre> In\u00a0[4]: Copied! <pre>import math\nrands = random_generator((2,10000), sequence='hammersley')\nnp.sum( np.cos(2*math.pi)*rands[1,:] * np.sin(2*math.pi)*rands[1,:])\n</pre> import math rands = random_generator((2,10000), sequence='hammersley') np.sum( np.cos(2*math.pi)*rands[1,:] * np.sin(2*math.pi)*rands[1,:]) Out[4]: <pre>np.float64(-8.163903819533452e-13)</pre> In\u00a0[5]: Copied! <pre>rands = random_generator((2,10000), sequence='pseudo')\nnp.sum( np.cos(2*math.pi)*rands[1,:] * np.sin(2*math.pi)*rands[1,:])\n</pre> rands = random_generator((2,10000), sequence='pseudo') np.sum( np.cos(2*math.pi)*rands[1,:] * np.sin(2*math.pi)*rands[1,:]) Out[5]: <pre>np.float64(-8.18772949704862e-13)</pre> In\u00a0[6]: Copied! <pre>R = 1\nN=100000\n\nrands1 = random_generator((2,N), sequence='hammersley')\nrands2 = random_generator((2,N), sequence='pseudo')\nrands3 = np.linspace(0, 1, N)\n\nrs = R*np.sqrt(rands1[0,:]) \n\nxs1 = rs*np.cos(2*math.pi*rands1[1,:])\nys1 = rs*np.sin(2*math.pi*rands1[1,:])\n\nxs2 = rs*np.cos(2*math.pi*rands2[1,:])\nys2 = rs*np.sin(2*math.pi*rands2[1,:])\n\nxs3 = rs*np.cos(2*math.pi*rands3)\nys3 = rs*np.sin(2*math.pi*rands3)\n\nplt.plot(xs1,ys1,'.');\n</pre> R = 1 N=100000  rands1 = random_generator((2,N), sequence='hammersley') rands2 = random_generator((2,N), sequence='pseudo') rands3 = np.linspace(0, 1, N)  rs = R*np.sqrt(rands1[0,:])   xs1 = rs*np.cos(2*math.pi*rands1[1,:]) ys1 = rs*np.sin(2*math.pi*rands1[1,:])  xs2 = rs*np.cos(2*math.pi*rands2[1,:]) ys2 = rs*np.sin(2*math.pi*rands2[1,:])  xs3 = rs*np.cos(2*math.pi*rands3) ys3 = rs*np.sin(2*math.pi*rands3)  plt.plot(xs1,ys1,'.'); In\u00a0[7]: Copied! <pre>print( np.mean( (xs1-xs1.mean())*(ys1-ys1.mean())) )\nprint( np.mean( (xs2-xs2.mean())*(ys2-ys2.mean())) )\nprint( np.mean( (xs3-xs3.mean())*(ys3-ys3.mean())) )\n</pre> print( np.mean( (xs1-xs1.mean())*(ys1-ys1.mean())) ) print( np.mean( (xs2-xs2.mean())*(ys2-ys2.mean())) ) print( np.mean( (xs3-xs3.mean())*(ys3-ys3.mean())) ) <pre>-9.407807239092847e-07\n0.0004992565985348314\n-9.40046825031402e-07\n</pre> In\u00a0[8]: Copied! <pre>sigma=np.cov(rands1)\nv,V = np.linalg.eig(sigma)\n\n#np.matmul(np.matmul(V.T, sigma), V) \n\nrandsp = np.matmul(V.T, rands1)\n\nnp.cov(randsp)\nrs = R*np.sqrt(randsp[0,:]) \n\nxsp = rs*np.cos(2*math.pi*randsp[1,:])\nysp = rs*np.sin(2*math.pi*randsp[1,:])\nprint(np.mean( (xsp-xsp.mean())*(ysp-ysp.mean())))\n</pre> sigma=np.cov(rands1) v,V = np.linalg.eig(sigma)  #np.matmul(np.matmul(V.T, sigma), V)   randsp = np.matmul(V.T, rands1)  np.cov(randsp) rs = R*np.sqrt(randsp[0,:])   xsp = rs*np.cos(2*math.pi*randsp[1,:]) ysp = rs*np.sin(2*math.pi*randsp[1,:]) print(np.mean( (xsp-xsp.mean())*(ysp-ysp.mean()))) <pre>0.008920000391515817\n</pre> In\u00a0[9]: Copied! <pre>input_str=\"\"\"\nn_particle: 100000\nspecies: electron\nrandom_type: hammersley\ntotal_charge:\n  value: 1\n  units: pC\nstart:\n  type: time\nr_dist:\n  max_r:\n    units: m\n    value: 2\n  min_r:\n    units: m\n    value: 0\n  type: radial_uniform\n\"\"\"\n\nimport yaml\n\nyaml.safe_load(input_str)\n</pre> input_str=\"\"\" n_particle: 100000 species: electron random_type: hammersley total_charge:   value: 1   units: pC start:   type: time r_dist:   max_r:     units: m     value: 2   min_r:     units: m     value: 0   type: radial_uniform \"\"\"  import yaml  yaml.safe_load(input_str) Out[9]: <pre>{'n_particle': 100000,\n 'species': 'electron',\n 'random_type': 'hammersley',\n 'total_charge': {'value': 1, 'units': 'pC'},\n 'start': {'type': 'time'},\n 'r_dist': {'max_r': {'units': 'm', 'value': 2},\n  'min_r': {'units': 'm', 'value': 0},\n  'type': 'radial_uniform'}}</pre> In\u00a0[10]: Copied! <pre>from distgen import Generator\ngen = Generator(input_str)\ngen.run()\nxs = gen.particles['x']\nys = gen.particles['y']\n\ngen.particles.cov('x','y')\n</pre> from distgen import Generator gen = Generator(input_str) gen.run() xs = gen.particles['x'] ys = gen.particles['y']  gen.particles.cov('x','y') Out[10]: <pre>array([[ 1.00001000e+00, -3.76331398e-06],\n       [-3.76331398e-06,  1.00001000e+00]])</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"regression_tests/correlations/#correlation-regression-tests","title":"Correlation Regression Tests\u00b6","text":""},{"location":"regression_tests/correlations/#test-correlations-in-the-hammersley-generator","title":"Test Correlations in the Hammersley Generator\u00b6","text":"<p>The Hammerlsey sequence should produce random numbers on (0,1) that are less correlated than the basic random generator:</p>"},{"location":"regression_tests/correlations/#radial-distributions","title":"Radial Distributions\u00b6","text":""},{"location":"regression_tests/correlations/#test-correlation-in-sinthetacostheta","title":"Test correlation in sin(theta)cos(theta)\u00b6","text":""},{"location":"regression_tests/correlations/#generate-xy-for-uniform-dist-and-check-correlation","title":"Generate x,y for uniform dist and check correlation\u00b6","text":""},{"location":"regression_tests/dist/","title":"Dist Regression Tests","text":"In\u00a0[1]: Copied! <pre>%load_ext autoreload\n%autoreload 2\n%config InlineBackend.figure_format = 'retina'\n</pre> %load_ext autoreload %autoreload 2 %config InlineBackend.figure_format = 'retina' In\u00a0[2]: Copied! <pre>from distgen.physical_constants import unit_registry\nimport numpy as np\nfrom matplotlib import pyplot as plt\n</pre> from distgen.physical_constants import unit_registry import numpy as np from matplotlib import pyplot as plt <p>To sample various distributions requires generating random numbers and supplying them to the $CDF^{-1}$ functions for each corresponding distribution.  Currently, this is handled using</p> <p><code>distgen.dist.random_generator(shape, sequence, **params)</code>.</p> <p>Here <code>shape = (n_dimension, n_particle)</code> determines the shape of the random numbers returned.  The keyword 'sequence' can be used to set the sequence to Hammerlsey for quasi-random numbers.</p> <p>The difference is shown below:</p> In\u00a0[3]: Copied! <pre>from distgen.dist import random_generator\n\nshape = (2,100)\n\np1 = random_generator(shape, sequence='hammersley')\np2 = random_generator(shape, 'pseudo')\n\nfig, ax = plt.subplots(1, 2, constrained_layout=True)\n\nax[0].plot(p1[0,:],p1[1,:],'.');\nax[0].set(xlabel='rx', ylabel='ry', title='hammersley');\n\nax[1].plot(p2[0,:],p2[1,:],'*');\nax[1].set(xlabel='rx', ylabel='ry', title='random.rand');\n</pre> from distgen.dist import random_generator  shape = (2,100)  p1 = random_generator(shape, sequence='hammersley') p2 = random_generator(shape, 'pseudo')  fig, ax = plt.subplots(1, 2, constrained_layout=True)  ax[0].plot(p1[0,:],p1[1,:],'.'); ax[0].set(xlabel='rx', ylabel='ry', title='hammersley');  ax[1].plot(p2[0,:],p2[1,:],'*'); ax[1].set(xlabel='rx', ylabel='ry', title='random.rand'); In\u00a0[4]: Copied! <pre>from distgen.dist import Uniform\nvar = 'x'\nverbose=1\nparams={'min_x':2*unit_registry('mm'),'max_x':4*unit_registry('mm')}\nuniform = Uniform(var,verbose=verbose,**params)\nuniform.plot_pdf()\nuniform.plot_cdf()\nuniform.test_sampling()\n</pre> from distgen.dist import Uniform var = 'x' verbose=1 params={'min_x':2*unit_registry('mm'),'max_x':4*unit_registry('mm')} uniform = Uniform(var,verbose=verbose,**params) uniform.plot_pdf() uniform.plot_cdf() uniform.test_sampling() <pre>uniform\n      min_x = 2 mm, max_x = 4 mm, avg_x = 3 mm, sigma_x:  0.57735 mm\n</pre> In\u00a0[5]: Copied! <pre>from distgen.dist import Linear\nvar = 'x'\nverbose=1\nparams={'min_x':-2*unit_registry('mm'),\n        'max_x':1*unit_registry('mm'),\n        'slope_fraction':-1\n       }\nnorm = Linear(var,verbose=verbose,**params)\nnorm.plot_pdf()\nnorm.plot_cdf()\nnorm.test_sampling()\n</pre> from distgen.dist import Linear var = 'x' verbose=1 params={'min_x':-2*unit_registry('mm'),         'max_x':1*unit_registry('mm'),         'slope_fraction':-1        } norm = Linear(var,verbose=verbose,**params) norm.plot_pdf() norm.plot_cdf() norm.test_sampling() <pre>Linear\n</pre> In\u00a0[6]: Copied! <pre>from distgen.dist import Norm\nvar = 'x'\nverbose=1\nparams={'sigma_x':2*unit_registry('mm'),'avg_x':-1*unit_registry('mm')}\nnorm = Norm(var,verbose=verbose,**params)\nnorm.plot_pdf()\nnorm.plot_cdf()\nnorm.test_sampling()\n</pre> from distgen.dist import Norm var = 'x' verbose=1 params={'sigma_x':2*unit_registry('mm'),'avg_x':-1*unit_registry('mm')} norm = Norm(var,verbose=verbose,**params) norm.plot_pdf() norm.plot_cdf() norm.test_sampling() <pre>Gaussian\n      avg_x = -1 mm, sigma_x = 2.000 mm\n</pre> <p>Below the $N_{\\text{cutoff}}$ parameter is set to cut the distribution symmetrically:</p> In\u00a0[7]: Copied! <pre>from distgen.dist import Norm\nvar = 'x'\nverbose=1\nparams={'sigma_x':2*unit_registry('mm'),'avg_x':0*unit_registry('mm'), 'n_sigma_cutoff':2}\nnorm = Norm(var,verbose=verbose,**params)\nnorm.plot_pdf()\nnorm.plot_cdf()\nnorm.test_sampling()\n</pre> from distgen.dist import Norm var = 'x' verbose=1 params={'sigma_x':2*unit_registry('mm'),'avg_x':0*unit_registry('mm'), 'n_sigma_cutoff':2} norm = Norm(var,verbose=verbose,**params) norm.plot_pdf() norm.plot_cdf() norm.test_sampling() <pre>Gaussian\n      avg_x = 0 mm, sigma_x = 2.000 mm\n      Left n_sigma_cutoff = 2, Right n_sigma_cutoff = -2\n</pre> <p>The distribution can be truncated asymmetrically using the $N_{\\text{cutoff},R}$ and $N_{\\text{cutoff},L}$ parameters, as shown below.  Note in this case, it is only required that $N_{\\text{cutoff},L} &lt; N_{\\text{cutoff},R}$, allowing for completley arbtitray location of the truncation points.  This requires a minus sign for the cut off parameters for truncation values less than zero.</p> In\u00a0[8]: Copied! <pre>from distgen.dist import Norm\nparams={'sigma_x':2*unit_registry('mm'),\n        'avg_x':0*unit_registry('mm'), \n        'n_sigma_cutoff_left':-1.5,\n        'n_sigma_cutoff_right':1}\n\nnorm = Norm('x',verbose=1,**params)\nnorm.plot_pdf()\nnorm.plot_cdf()\nnorm.test_sampling()\n</pre> from distgen.dist import Norm params={'sigma_x':2*unit_registry('mm'),         'avg_x':0*unit_registry('mm'),          'n_sigma_cutoff_left':-1.5,         'n_sigma_cutoff_right':1}  norm = Norm('x',verbose=1,**params) norm.plot_pdf() norm.plot_cdf() norm.test_sampling() <pre>Gaussian\n      avg_x = 0 mm, sigma_x = 2.000 mm\n      Left n_sigma_cutoff = 1, Right n_sigma_cutoff = -1.5\n</pre> In\u00a0[9]: Copied! <pre>from distgen.dist import SuperGaussian\n\nps = [0.5, 1 , 5, float('Inf')]\nalphas = [0, 0.25, 0.5, 1]\n\nfig, (ax1, ax2) = plt.subplots(1, 2,\n                               sharex='col',\n                               figsize=(12,4),\n                               constrained_layout=True)\n\nplegs = ['p = '+str(p) for p in ps]\nalegs = ['$\\\\alpha$ = '+str(a) for a in alphas]\n\nfor ii,p in enumerate(ps):\n    pparams = {'lambda':2*unit_registry('mm'),\n              'p':p*unit_registry('dimensionless'),}\n    \n    supG = SuperGaussian('x',verbose=0,**pparams)\n    x = supG.get_x_pts(1000)\n    rho = supG.pdf(x)\n    ax1.plot(x,rho);\n    \n    a=alphas[ii]\n    aparams = {'lambda':2*unit_registry('mm'),\n              'alpha':a*unit_registry('dimensionless'),}\n    \n    x = np.linspace(-3*aparams['lambda'], 3*aparams['lambda'],100)\n    supG = SuperGaussian('x',verbose=0,**aparams)\n    rho = supG.pdf(x)\n    ax2.plot(x,rho);\n    \nax1.set_xlabel('x (mm)');    ax2.set_xlabel('x (mm)');\nax1.set_ylabel('pdf (1/mm)');ax2.set_ylabel('pdf (1/mm)');\nax1.legend(plegs);           ax2.legend(alegs);\n</pre> from distgen.dist import SuperGaussian  ps = [0.5, 1 , 5, float('Inf')] alphas = [0, 0.25, 0.5, 1]  fig, (ax1, ax2) = plt.subplots(1, 2,                                sharex='col',                                figsize=(12,4),                                constrained_layout=True)  plegs = ['p = '+str(p) for p in ps] alegs = ['$\\\\alpha$ = '+str(a) for a in alphas]  for ii,p in enumerate(ps):     pparams = {'lambda':2*unit_registry('mm'),               'p':p*unit_registry('dimensionless'),}          supG = SuperGaussian('x',verbose=0,**pparams)     x = supG.get_x_pts(1000)     rho = supG.pdf(x)     ax1.plot(x,rho);          a=alphas[ii]     aparams = {'lambda':2*unit_registry('mm'),               'alpha':a*unit_registry('dimensionless'),}          x = np.linspace(-3*aparams['lambda'], 3*aparams['lambda'],100)     supG = SuperGaussian('x',verbose=0,**aparams)     rho = supG.pdf(x)     ax2.plot(x,rho);      ax1.set_xlabel('x (mm)');    ax2.set_xlabel('x (mm)'); ax1.set_ylabel('pdf (1/mm)');ax2.set_ylabel('pdf (1/mm)'); ax1.legend(plegs);           ax2.legend(alegs); <p>To set the length scale of the distribution, the user must either supply 'sigma_[var]' or 'lambda'. See usage below:</p> In\u00a0[10]: Copied! <pre>params = {'sigma_x':2*unit_registry('mm'),\n          #'alpha': 0.75*unit_registry('dimensionless'),\n           'alpha': 0.003*unit_registry('dimensionless'),\n          'avg_x':0.25*unit_registry('mm')}\n\nsupG = SuperGaussian('x',verbose=1,**params)\nsupG.plot_pdf()\nsupG.plot_cdf()\nsupG.test_sampling()\n</pre> params = {'sigma_x':2*unit_registry('mm'),           #'alpha': 0.75*unit_registry('dimensionless'),            'alpha': 0.003*unit_registry('dimensionless'),           'avg_x':0.25*unit_registry('mm')}  supG = SuperGaussian('x',verbose=1,**params) supG.plot_pdf() supG.plot_cdf() supG.test_sampling() <pre>Super Gaussian\n      sigma_x = 2 mm, power = 333.333\n</pre> <p>Disgten supports importing a 1D PDF saved in column form in.  The input form of the file should have space separated headers such as $x$ and $Px$, with corresponding column data below it.  The PDF is normalized numerically using the numpy.trapz numerical integration routine. The CDF is computed using the scipy.cumtrapz cumulative numerical intgration routine.</p> <p>The following example shows a gaussian PDF with cuts added to it.</p> In\u00a0[11]: Copied! <pre>from distgen.dist import File1d\nvar = 't'\nverbose=1\nparams={'file':'../examples/data/cutgauss.1d.txt','units':'ps'}\nfile1d = File1d(var,verbose=verbose,**params)\nfile1d.plot_pdf()\nfile1d.plot_cdf()\nfile1d.test_sampling()\n</pre> from distgen.dist import File1d var = 't' verbose=1 params={'file':'../examples/data/cutgauss.1d.txt','units':'ps'} file1d = File1d(var,verbose=verbose,**params) file1d.plot_pdf() file1d.plot_cdf() file1d.test_sampling() <pre>t-distribution file: \"../examples/data/cutgauss.1d.txt\"\n</pre> In\u00a0[12]: Copied! <pre>from distgen.dist import TemporalLaserPulseStacking\nverbose=1\nparams={'crystal_length_1': 15.096*unit_registry('mm'),\n        'crystal_length_2': 7.548*unit_registry('mm'), \n        'crystal_length_3': 3.774*unit_registry('mm'), \n        'crystal_length_4': 1.887*unit_registry('mm'), \n        'crystal_angle_1':  0.6*unit_registry('deg'), \n        'crystal_angle_2':  1.8*unit_registry('deg'), \n        'crystal_angle_3': -0.9*unit_registry('deg'),  \n        'crystal_angle_4': -0.5*unit_registry('deg'), }\n    \nlaser_pulse = TemporalLaserPulseStacking(verbose=verbose,**params)\nlaser_pulse.plot_pdf()\nlaser_pulse.plot_cdf()\nlaser_pulse.test_sampling()\n</pre> from distgen.dist import TemporalLaserPulseStacking verbose=1 params={'crystal_length_1': 15.096*unit_registry('mm'),         'crystal_length_2': 7.548*unit_registry('mm'),          'crystal_length_3': 3.774*unit_registry('mm'),          'crystal_length_4': 1.887*unit_registry('mm'),          'crystal_angle_1':  0.6*unit_registry('deg'),          'crystal_angle_2':  1.8*unit_registry('deg'),          'crystal_angle_3': -0.9*unit_registry('deg'),           'crystal_angle_4': -0.5*unit_registry('deg'), }      laser_pulse = TemporalLaserPulseStacking(verbose=verbose,**params) laser_pulse.plot_pdf() laser_pulse.plot_cdf() laser_pulse.test_sampling() <pre>crystal temporal laser shaping\n      crystal 1 length = 15.096 mm, angle = 0.6 deg\n      crystal 2 length = 7.548 mm, angle = 1.8 deg\n      crystal 3 length = 3.774 mm, angle = -0.9 deg\n      crystal 4 length = 1.887 mm, angle = -0.5 deg\n      Pulses propagated: min t = -23.9053 ps, max t = 23.9053 ps\n</pre> In\u00a0[13]: Copied! <pre>from distgen.dist import Tukey\nvar = 'y'\nverbose=1\nparams={'length':2*unit_registry('mm'),'ratio':0.75*unit_registry('dimensionless')}\ntukey = Tukey(var,verbose=1,**params)\ntukey.plot_pdf()\ntukey.plot_cdf()\ntukey.test_sampling()\n</pre> from distgen.dist import Tukey var = 'y' verbose=1 params={'length':2*unit_registry('mm'),'ratio':0.75*unit_registry('dimensionless')} tukey = Tukey(var,verbose=1,**params) tukey.plot_pdf() tukey.plot_cdf() tukey.test_sampling() <pre>Tukey\n      length = 2 mm, ratio = 0.75\n</pre> In\u00a0[14]: Copied! <pre>from distgen.dist import Superposition\n\nparams = {\n    'weights':{'d1':1, 'd2':2},\n    'dists':{\n        'd1':{\n            'avg_z':-2*unit_registry('mm'),\n            'sigma_z':1*unit_registry('mm'),\n            'type': 'gaussian'\n        } ,\n        'd2':{\n            'avg_z':+2*unit_registry('mm'),\n            'sigma_z':1*unit_registry('mm'),\n            'type': 'gaussian'\n        } \n    }\n}\n\nsup = Superposition('z', 1, **params)\nsup.plot_pdf()\nsup.plot_cdf()\nsup.test_sampling()\n</pre> from distgen.dist import Superposition  params = {     'weights':{'d1':1, 'd2':2},     'dists':{         'd1':{             'avg_z':-2*unit_registry('mm'),             'sigma_z':1*unit_registry('mm'),             'type': 'gaussian'         } ,         'd2':{             'avg_z':+2*unit_registry('mm'),             'sigma_z':1*unit_registry('mm'),             'type': 'gaussian'         }      } }  sup = Superposition('z', 1, **params) sup.plot_pdf() sup.plot_cdf() sup.test_sampling() <pre>superpostion\n      1. distribution name: d1, type: Gaussian\n         avg_z = -2 mm, sigma_z = 1.000 mm\n      2. distribution name: d2, type: Gaussian\n         avg_z = 2 mm, sigma_z = 1.000 mm\n</pre> In\u00a0[15]: Copied! <pre>from distgen.dist import Product\n\nparams = {\n    'dists':{\n        'd1':{\n            'min_z':-3*unit_registry('mm'),\n            'max_z':3*unit_registry('mm'),\n            'type': 'uniform'\n        } ,\n        'd2':{\n            'avg_z':+0*unit_registry('mm'),\n            'sigma_z':3*unit_registry('mm'),\n            'type': 'gaussian'\n        } \n    }\n}\n\npro = Product('z', 1, **params)\npro.plot_pdf()\npro.plot_cdf()\npro.test_sampling()\n</pre> from distgen.dist import Product  params = {     'dists':{         'd1':{             'min_z':-3*unit_registry('mm'),             'max_z':3*unit_registry('mm'),             'type': 'uniform'         } ,         'd2':{             'avg_z':+0*unit_registry('mm'),             'sigma_z':3*unit_registry('mm'),             'type': 'gaussian'         }      } }  pro = Product('z', 1, **params) pro.plot_pdf() pro.plot_cdf() pro.test_sampling() <pre>\ndistribution name: d1\nuniform\n      min_z = -3 mm, max_z = 3 mm, avg_z = 0 mm, sigma_z:  1.73205 mm\n\ndistribution name: d2\nGaussian\n      avg_z = 0 mm, sigma_z = 3.000 mm\n</pre> In\u00a0[16]: Copied! <pre>from distgen.dist import Deformable\n\nparams = {'alpha':0.750*unit_registry(''),\n          'slope_fraction':-1,\n          'sigma_x':2*unit_registry('mm'),\n          'avg_x':  0*unit_registry('mm')}\n\ndeform = Deformable('x', verbose=1, **params)\ndeform.plot_pdf()\ndeform.plot_cdf()\ndeform.test_sampling()\n</pre> from distgen.dist import Deformable  params = {'alpha':0.750*unit_registry(''),           'slope_fraction':-1,           'sigma_x':2*unit_registry('mm'),           'avg_x':  0*unit_registry('mm')}  deform = Deformable('x', verbose=1, **params) deform.plot_pdf() deform.plot_cdf() deform.test_sampling() <pre>Super Gaussian\n      sigma_x = 2 mm, power = 1.33333\nLinear\n</pre> In\u00a0[17]: Copied! <pre>from distgen.dist import Interpolation1d\n\nparams = {'avg_t': 0.0*unit_registry('ps'),\n          'sigma_t':2*unit_registry('ps'),\n          'Pt':[1, 2.2, 3.3, 4, 3, 2, 6, 7, 7.5, 8, 7.5, 1],\n          'method':'spline',\n          'n_pts':100000\n         }\n\ni1d = Interpolation1d('t', verbose=1, **params)\n\ni1d.plot_pdf()\ni1d.plot_cdf()\ni1d.test_sampling()\n</pre> from distgen.dist import Interpolation1d  params = {'avg_t': 0.0*unit_registry('ps'),           'sigma_t':2*unit_registry('ps'),           'Pt':[1, 2.2, 3.3, 4, 3, 2, 6, 7, 7.5, 8, 7.5, 1],           'method':'spline',           'n_pts':100000          }  i1d = Interpolation1d('t', verbose=1, **params)  i1d.plot_pdf() i1d.plot_cdf() i1d.test_sampling() In\u00a0[18]: Copied! <pre>from distgen.dist import UniformRad\nverbose=1\nparams={'min_r':1*unit_registry('mm'),'max_r':2*unit_registry('mm')}\nurad = UniformRad(verbose=1,**params)\nurad.plot_pdf()\nurad.plot_cdf()\nurad.test_sampling()\n</pre> from distgen.dist import UniformRad verbose=1 params={'min_r':1*unit_registry('mm'),'max_r':2*unit_registry('mm')} urad = UniformRad(verbose=1,**params) urad.plot_pdf() urad.plot_cdf() urad.test_sampling() <pre>radial uniform\n      min_r = 1 mm, max_r = 2 mm\n</pre> In\u00a0[19]: Copied! <pre>from distgen.dist import LinearRad\nverbose=1\nparams={'min_r':0*unit_registry('mm'),\n        'max_r':2*unit_registry('mm'),\n        'slope_fraction':1\n       }\n\nlin = LinearRad(verbose=verbose,**params)\nlin.plot_pdf()\nlin.plot_cdf()\nlin.test_sampling()\n</pre> from distgen.dist import LinearRad verbose=1 params={'min_r':0*unit_registry('mm'),         'max_r':2*unit_registry('mm'),         'slope_fraction':1        }  lin = LinearRad(verbose=verbose,**params) lin.plot_pdf() lin.plot_cdf() lin.test_sampling()  <pre>LinearRad\n</pre> In\u00a0[20]: Copied! <pre>from distgen.dist import NormRad\nverbose=1\nparams={'sigma_xy':1*unit_registry('mm')}\nnrad = NormRad(verbose=1,**params)\nnrad.plot_pdf()\nnrad.plot_cdf()\nnrad.test_sampling()\n</pre> from distgen.dist import NormRad verbose=1 params={'sigma_xy':1*unit_registry('mm')} nrad = NormRad(verbose=1,**params) nrad.plot_pdf() nrad.plot_cdf() nrad.test_sampling() <pre>radial Gaussian\n</pre> <p>For laser scientists it can be convenient to to work with a pinhole radius and a fraction of the laser intensity to clip a transverse normal laser mode at.  In this case the user can supply a truncation radius ($=r_R$) and a truncation fraction $f = \\exp\\left(-\\frac{r_R^2}{2\\sigma}\\right)$ from which distgen determines the underlying $\\sigma$.  The example below demonstrates this usage:</p> In\u00a0[21]: Copied! <pre>from distgen.dist import NormRad\nverbose=1\nparams={'truncation_radius':1*unit_registry('mm'),'truncation_fraction':0.5*unit_registry('dimensionless')}\nnrad = NormRad(verbose=1,**params)\nnrad.plot_pdf()\nnrad.plot_cdf()\nnrad.test_sampling()\n</pre> from distgen.dist import NormRad verbose=1 params={'truncation_radius':1*unit_registry('mm'),'truncation_fraction':0.5*unit_registry('dimensionless')} nrad = NormRad(verbose=1,**params) nrad.plot_pdf() nrad.plot_cdf() nrad.test_sampling() <pre>radial Gaussian\n</pre> In\u00a0[22]: Copied! <pre>from distgen.dist import NormRad\nverbose=1\nparams={'sigma_xy':2*unit_registry('mm'),'n_sigma_cutoff':1}\nnrad = NormRad(verbose=1,**params)\nnrad.plot_pdf()\nnrad.plot_cdf()\nnrad.test_sampling()\n</pre> from distgen.dist import NormRad verbose=1 params={'sigma_xy':2*unit_registry('mm'),'n_sigma_cutoff':1} nrad = NormRad(verbose=1,**params) nrad.plot_pdf() nrad.plot_cdf() nrad.test_sampling() <pre>radial Gaussian\n</pre> In\u00a0[23]: Copied! <pre>from distgen.dist import TukeyRad\nverbose=1\nparams={'length':1*unit_registry('mm'),'ratio':0.75*unit_registry('dimensionless')}\nrtukey = TukeyRad(verbose=1,**params)\nrtukey.plot_pdf()\nrtukey.plot_cdf()\nrtukey.test_sampling()\n</pre> from distgen.dist import TukeyRad verbose=1 params={'length':1*unit_registry('mm'),'ratio':0.75*unit_registry('dimensionless')} rtukey = TukeyRad(verbose=1,**params) rtukey.plot_pdf() rtukey.plot_cdf() rtukey.test_sampling() <pre>TukeyRad\n      legnth = 1.000 mm, ratio = 0.750\n</pre> In\u00a0[24]: Copied! <pre>from distgen.dist import SuperGaussianRad\nverbose=1\nparams={'sigma_xy':1*unit_registry('mm'),\n        'alpha':0.0*unit_registry('dimensionless')}\nsupG = SuperGaussianRad(verbose=1,**params)\nsupG.plot_pdf()\nsupG.plot_cdf()\nsupG.test_sampling()\n</pre> from distgen.dist import SuperGaussianRad verbose=1 params={'sigma_xy':1*unit_registry('mm'),         'alpha':0.0*unit_registry('dimensionless')} supG = SuperGaussianRad(verbose=1,**params) supG.plot_pdf() supG.plot_cdf() supG.test_sampling() <pre>SuperGaussianRad\n      lambda = 1.41421 mm, power = INF\n</pre> In\u00a0[25]: Copied! <pre>from distgen.dist import RadFile\n\nparams = {'file':'../examples/data/cutgauss.rad.txt','units':'mm'}\n\nrfd = RadFile(verbose=1, **params)\nrfd.plot_pdf()\nrfd.plot_cdf()\nrfd.test_sampling()\n</pre> from distgen.dist import RadFile  params = {'file':'../examples/data/cutgauss.rad.txt','units':'mm'}  rfd = RadFile(verbose=1, **params) rfd.plot_pdf() rfd.plot_cdf() rfd.test_sampling() <pre>radial file\n      r-dist file: \"../examples/data/cutgauss.rad.txt\"\n</pre> In\u00a0[26]: Copied! <pre>from distgen.dist import DeformableRad\n\nparams = {\n    'alpha':0.05*unit_registry(''),\n    'slope_fraction':-1,\n    'sigma_xy':2*unit_registry('mm'),\n}\n\ndeform = DeformableRad(verbose=1, **params)\ndeform.plot_pdf()\ndeform.plot_cdf()\ndeform.test_sampling()\n</pre> from distgen.dist import DeformableRad  params = {     'alpha':0.05*unit_registry(''),     'slope_fraction':-1,     'sigma_xy':2*unit_registry('mm'), }  deform = DeformableRad(verbose=1, **params) deform.plot_pdf() deform.plot_cdf() deform.test_sampling() <pre>SuperGaussianRad\n      lambda = 2.86117 mm, power = 20\nLinearRad\n</pre>"},{"location":"regression_tests/dist/#dist-regression-tests","title":"Dist Regression Tests\u00b6","text":""},{"location":"regression_tests/dist/#random-number-generation","title":"Random Number Generation\u00b6","text":""},{"location":"regression_tests/dist/#1d-distributions","title":"1D Distributions\u00b6","text":"<p>Distgen supports several one dimensional distribution types.</p>"},{"location":"regression_tests/dist/#uniform-1d","title":"Uniform 1D\u00b6","text":"<p>The uniform distirbuition is defined by a probability distribution function:</p> <p>$\\rho(x) = \\frac{1}{b-a}$ for $a\\leq x\\leq b$ and zero elsewhere.</p> <p>The corresponding CDF is</p> <p>$P(x) = \\frac{x-a}{b-a}$ for $a\\leq x\\leq b$ and zero elsewhere.</p> <p>The first and second moments of this distribution are:</p> <p>$\\langle x \\rangle = \\frac{1}{2}(a+b)$ and $\\sigma_x = \\frac{b-a}{\\sqrt{12}}$</p>"},{"location":"regression_tests/dist/#linear","title":"Linear\u00b6","text":"<p>The linear distirbuition is defined by a probability distribution function:</p> <p>$\\rho(x) \\propto \\frac{\\rho_b-\\rho_a}{b-a}(x-a) + \\rho_a$ for $a\\leq x\\leq b$ and zero elsewhere.</p> <p>The corresponding CDF is</p> <p>$P(x) \\propto \\frac{1}{2}\\frac{\\rho_b-\\rho_a}{b-a}(x-a)$ for $a\\leq x\\leq b$ and zero elsewhere.</p> <p>The first and second moments of this distribution are:</p> <p>$\\langle x \\rangle \\propto \\frac{\\rho_b-\\rho_a}{b-a}\\left(\\frac{1}{3}(b^3-a^3) -a(b^2-a^2)\\right) + \\frac{1}{2}\\rho_a(b^2-a^2)$.</p>"},{"location":"regression_tests/dist/#normal-distribution-including-truncation","title":"Normal Distribution (including truncation)\u00b6","text":"<p>The general form of a normal distribution PDF with truncation is given by</p> <p>$\\rho(x) = \\frac{1}{\\sigma}\\frac{\\phi\\left(\\frac{x-\\mu}{\\sigma}\\right)}{\\Phi\\left(\\frac{b-\\mu}{\\sigma}\\right)-\\Phi\\left(\\frac{a-\\mu}{\\sigma}\\right)}$.</p> <p>In this expression $\\phi(\\xi) = \\frac{1}{\\sqrt{2\\pi}}e^{-\\frac{1}{2}\\xi^2}$ is the canonical normal distribution, $\\Phi(\\xi) = \\frac{1}{2}\\left[1 + \\text{erf}\\left(\\frac{\\xi}{\\sqrt{2}}\\right) \\right]$ is the canonical normal CDF, and $a=-N_{\\text{cutoff}}\\cdot\\sigma$ and $b=-N_{\\text{cutoff}}\\cdot\\sigma$ are the left and right truncation points.  The CDF if given by</p> <p>$P(x) = \\frac{\\Phi\\left(\\frac{x-\\mu}{\\sigma}\\right) - \\Phi\\left(\\frac{a-\\mu}{\\sigma}\\right)}{\\Phi\\left(\\frac{b-\\mu}{\\sigma}\\right)-\\Phi\\left(\\frac{a-\\mu}{\\sigma}\\right)}$.</p> <p>Defining $\\alpha = \\frac{a-\\mu}{\\sigma}$ and $\\beta = \\frac{b-\\mu}{\\sigma}$, the first and second moments of the distribution are:</p> <p>$\\langle x\\rangle = \\mu + \\frac{\\phi\\left(\\alpha\\right) - \\phi\\left(\\beta\\right)}{\\Phi\\left(\\beta\\right)-\\Phi\\left(\\alpha\\right)}\\sigma$ and $\\sigma_x = \\sigma \\left\\{1 + \\frac{\\alpha\\phi\\left(\\alpha\\right) - \\beta\\phi(\\beta) }{\\Phi(\\beta) - \\Phi(\\alpha)} - \\left(\\frac{\\phi\\left(\\alpha\\right) - \\phi(\\beta)}{\\Phi(\\beta) - \\Phi(\\alpha)}\\right)^{2} \\right\\}^{1/2} $.</p> <p>When using this distribution, if the $N_{\\text{cutoff}}$ is not set then the distribution reduces to an infinite range normal distribution, as first shown below:</p>"},{"location":"regression_tests/dist/#super-gaussian","title":"Super Gaussian\u00b6","text":"<p>In additional to the regular Gaussian function, it is also possible to sample a super-Gaussian distribution defined by</p> <p>$\\rho(x; \\lambda, p) = \\frac{1}{2\\sqrt{2}\\Gamma\\left(1+\\frac{1}{2p}\\right)\\lambda } \\exp\\left[-\\left(\\frac{(x-\\mu)^2 }{2\\lambda^2}\\right)^{p}\\right]$</p> <p>Here $\\sigma_1$ is the length scale and $p$ is the power of the super-Gaussian. Note when $p=1$ reduces to a Normal distirbution, in which case $\\sigma_x=\\lambda$.  As $p\\rightarrow\\infty$ the distribution reduces to a flat-top (uniform). The full range of powers is given by $p\\in\\left(0,\\infty\\right]$.</p> <p>The first and second moments of the distribution are given by:</p> <p>$\\langle x\\rangle = \\mu$, and $\\sigma_x = \\left(\\frac{2\\Gamma\\left(1+\\frac{3}{2p}\\right)}{3\\Gamma\\left(1+\\frac{1}{2p}\\right)}\\right)^{1/2}\\lambda$.</p> <p>Often, it is convenient to scan the distribution from the uniform limit to the Gaussian limit.  To do some, the input $p$ can be parameterized by $\\alpha\\in[0,1]$ where $p = 1/\\alpha$.  Here $\\alpha=0$ corresponds to a flat-top (uniform) and $\\alpha=1$ corresponds to a Gaussian.  Examples of both types of usage are shown below.</p>"},{"location":"regression_tests/dist/#1d-pdf-from-a-file","title":"1D PDF from a file\u00b6","text":""},{"location":"regression_tests/dist/#laser-pulse-stacking","title":"Laser pulse stacking\u00b6","text":""},{"location":"regression_tests/dist/#tukey-1d","title":"Tukey 1D\u00b6","text":""},{"location":"regression_tests/dist/#superposition-1d","title":"Superposition 1D\u00b6","text":"<p>This distribution allows the user to superimpose an arbitrary number of 1D PDFs.  The general form is:</p> <p>$\\rho(x) = \\sum_i w_i \\frac{\\rho_i(x)}{\\max(\\rho_i)}$.</p> <p>Here the $w_i$ are user specified weights.  If no weight is specified for a given $rho_i$, then the weight will default to one.</p>"},{"location":"regression_tests/dist/#product-dist-1d","title":"Product Dist 1D\u00b6","text":"<p>This distribution allows the user to multiply an arbitrary number of 1D PDFs.  The general form is:</p> <p>$\\rho(x) = \\prod_i \\rho_i(x)$.</p>"},{"location":"regression_tests/dist/#deformable","title":"Deformable\u00b6","text":""},{"location":"regression_tests/dist/#interpolation1d","title":"Interpolation1D\u00b6","text":""},{"location":"regression_tests/dist/#radial-distributions","title":"Radial Distributions\u00b6","text":""},{"location":"regression_tests/dist/#radial-linear","title":"Radial Linear\u00b6","text":""},{"location":"regression_tests/dist/#radial-normal-distribution-with-truncation","title":"Radial Normal Distribution (with truncation)\u00b6","text":"<p>The radial normal distribution including truncation(s) has a probability function given by</p> <p>$\\rho_r(r) = \\frac{1}{\\sigma^2}\\frac{\\phi(r/\\sigma)}{\\phi\\left(\\frac{r_L}{\\sigma}\\right)-\\phi\\left(\\frac{r_R}{\\sigma}\\right)} $ for $0 \\leq r_L \\leq r \\leq r_R$ and zero everywhere else.</p> <p>In this expresion $\\phi(\\xi) = \\frac{1}{2\\pi}\\exp\\left(-\\xi^2/2\\right)$ is the canonical raidial normal distirbution (no truncation), and the scale parameter $\\sigma$ follows from the product of two normal distributions in $x$ and $y$ when $\\sigma=\\sigma_x=\\sigma_y$.  The corresponding CDF is given by</p> <p>$P(r)= \\frac{\\phi\\left(\\frac{r_L}{\\sigma}\\right)-\\phi\\left(\\frac{r}{\\sigma}\\right)}{\\phi\\left(\\frac{r_L}{\\sigma}\\right)-\\phi\\left(\\frac{r_R}{\\sigma}\\right)} $ for $0 \\leq r_L \\leq r$.</p> <p>The corresponding first and second moments are:</p> <p>$\\langle r\\rangle = \\frac{\\frac{r_L}{\\sigma}\\phi\\left(\\frac{r_L}{\\sigma}\\right) -\\frac{r_R}{\\sigma}\\phi\\left(\\frac{r_R}{\\sigma}\\right) +\\frac{1}{2\\sqrt{2\\pi}}\\left( \\text{erf}\\left(\\frac{r_R}{\\sigma\\sqrt{2}}\\right) - \\text{erf}\\left(\\frac{r_L}{\\sigma\\sqrt{2}}\\right) \\right)  } {\\phi\\left(\\frac{r_L}{\\sigma}\\right)-\\phi\\left(\\frac{r_R}{\\sigma}\\right)}$,</p> <p>$r_{rms} = \\sqrt{ 2\\sigma^2 + r_L^2 - \\frac{(r_R^2-r_L^2)\\phi(r_R/\\sigma)}{\\phi\\left(\\frac{r_L}{\\sigma}\\right)-\\phi\\left(\\frac{r_R}{\\sigma}\\right)} }$.</p> <p>Note that in the limits $r_L\\rightarrow 0$ and $r_R -&gt; \\infty$ the above expressions reduce to the underlying radial normal distribution:</p> <p>$\\rho_r(r)\\rightarrow \\frac{\\phi\\left(\\frac{r}{\\sigma}\\right)}{\\sigma^2}$, $P(r)\\rightarrow 1 - \\phi\\left(\\frac{r}{\\sigma}\\right)$, $\\langle r\\rangle\\rightarrow \\sqrt{\\frac{\\pi}{2}}\\sigma$, and $r_{rms}\\rightarrow \\sqrt{2}\\sigma$.  This limiting case is shown first below.</p>"},{"location":"regression_tests/dist/#radial-tukey","title":"Radial Tukey\u00b6","text":""},{"location":"regression_tests/dist/#radial-super-gaussian","title":"Radial Super Gaussian\u00b6","text":"<p>This implements a radial version of the Super Gaussian function discussed above.  Here the radial function takes the form:</p> <p>$2\\pi\\rho(r;\\lambda,p) = \\frac{1}{\\Gamma\\left(1+\\frac{1}{p}\\right)\\lambda^2} \\exp\\left[-\\left(\\frac{r^2}{2\\lambda^2}\\right)^p\\right]$.</p> <p>The first and (rms) second moment of the distribution are given by:</p> <p>$\\langle r\\rangle = \\frac{2\\sqrt{2}}{3}\\frac{\\Gamma\\left(1+\\frac{3}{2p}\\right)}{\\Gamma\\left(1+\\frac{1}{p}\\right)}\\lambda$,</p> <p>$r_{\\text{rms}} = \\sqrt{\\frac{\\Gamma\\left(1+\\frac{2}{p}\\right)}{\\Gamma\\left(1+\\frac{1}{p}\\right)}}\\lambda$.</p>"},{"location":"regression_tests/dist/#radial-file-distribution","title":"Radial File Distribution\u00b6","text":""},{"location":"regression_tests/dist/#deformable","title":"Deformable\u00b6","text":""},{"location":"regression_tests/dist/#angular-distributions-todo","title":"Angular Distributions (TODO)\u00b6","text":"<p>Angular distributions define one dimensional probability functions for the cylindrical variable $\\theta$.</p>"},{"location":"regression_tests/example_beams/","title":"Compare Example Beams Across Versions","text":"In\u00a0[1]: Copied! <pre>from distgen import Generator\n\nimport glob\nfrom pathlib import Path\nimport numpy as np\nfrom pmd_beamphysics import ParticleGroup\n</pre> from distgen import Generator  import glob from pathlib import Path import numpy as np from pmd_beamphysics import ParticleGroup In\u00a0[2]: Copied! <pre>from distgen import __version__\n</pre> from distgen import __version__ In\u00a0[3]: Copied! <pre>__version__\n</pre> __version__ Out[3]: <pre>'0+untagged.1.g609ca2f'</pre> In\u00a0[4]: Copied! <pre>YAMLS = glob.glob('../examples/data/*yaml')\n</pre> YAMLS = glob.glob('../examples/data/*yaml') In\u00a0[5]: Copied! <pre>for YAML in YAMLS:\n\n    D = Generator(YAML)\n    D['n_particle']=1_000\n    P = D.run()\n    P.write(f'archive/{Path(YAML).name.replace(\".yaml\", \".h5\")}')\n</pre> for YAML in YAMLS:      D = Generator(YAML)     D['n_particle']=1_000     P = D.run()     P.write(f'archive/{Path(YAML).name.replace(\".yaml\", \".h5\")}')   In\u00a0[6]: Copied! <pre>import os\n</pre> import os In\u00a0[7]: Copied! <pre>os.getcwd()\n</pre> os.getcwd() Out[7]: <pre>'/home/runner/work/distgen/distgen/docs/regression_tests'</pre> In\u00a0[8]: Copied! <pre>PREVIOUS_ARCHIVE = 'archive'\n\n#PREVIOUS_ARCHIVE = '/Users/colwyngulliford/devel/distgen/distgen2.0.0'\n\ndef test_beam(beam_file, previous_archive, abs_tol = 1e-9, rel_tol = 1e-11, verbose=True):\n\n    beam_file = Path(beam_file)\n    name = beam_file.name.replace('.yaml', '')\n    p1file = f'{previous_archive}/{name}.h5'\n    p2file = f'archive/{name}.h5'\n\n    if(Path(p1file).exists() and Path(p2file).exists()):\n        if(verbose):\n            print('Checking:', Path(p1file).name, 'against', p2file)\n        \n        P1, P2 = ParticleGroup(p1file), ParticleGroup(p2file)\n        \n        vs = ['x', 'y', 'z', 'px', 'py', 'pz', 'weight']\n        for v in vs:\n            abs_deviation = P1[v] - P2[v]\n            assert np.max(np.abs(abs_deviation)) &lt; abs_tol, f'Max[ |absolute deviation| ] for {v}: {np.max(np.abs(abs_deviation))} for {Path(p1file).name}'\n            non_zero = np.abs(P2[v])&gt;0\n            \n            if(np.any(non_zero)):\n                rel_deviation = (P1[v][non_zero] - P2[v][non_zero])/P2[v][non_zero]\n                assert np.max(np.abs(rel_deviation)) &lt; rel_tol, f'Max[ |relative deviation| ] for {v}: {np.max(np.abs(rel_deviation))} for {Path(p1file).name}'\n\n        \n\ndef test_beams(beam_files, previous_archive, verbose=True, abs_tol=1e-10, rel_tol=1e-12):\n\n    print(f'Comparing the current beam archive to {previous_archive}\\n')\n\n    for beam_file in beam_files:\n        test_beam(beam_file, previous_archive, verbose=verbose, abs_tol = abs_tol, rel_tol = rel_tol)\n\n    if(verbose):\n        print('\\nAll beams check to w/absolute tolerance of:', abs_tol )\n        print('All beams check to an w/relative tolerance of:', rel_tol )\n\ntest_beams(YAMLS, PREVIOUS_ARCHIVE, verbose=True, abs_tol = 1e-11, rel_tol=1e-12)\n</pre> PREVIOUS_ARCHIVE = 'archive'  #PREVIOUS_ARCHIVE = '/Users/colwyngulliford/devel/distgen/distgen2.0.0'  def test_beam(beam_file, previous_archive, abs_tol = 1e-9, rel_tol = 1e-11, verbose=True):      beam_file = Path(beam_file)     name = beam_file.name.replace('.yaml', '')     p1file = f'{previous_archive}/{name}.h5'     p2file = f'archive/{name}.h5'      if(Path(p1file).exists() and Path(p2file).exists()):         if(verbose):             print('Checking:', Path(p1file).name, 'against', p2file)                  P1, P2 = ParticleGroup(p1file), ParticleGroup(p2file)                  vs = ['x', 'y', 'z', 'px', 'py', 'pz', 'weight']         for v in vs:             abs_deviation = P1[v] - P2[v]             assert np.max(np.abs(abs_deviation)) &lt; abs_tol, f'Max[ |absolute deviation| ] for {v}: {np.max(np.abs(abs_deviation))} for {Path(p1file).name}'             non_zero = np.abs(P2[v])&gt;0                          if(np.any(non_zero)):                 rel_deviation = (P1[v][non_zero] - P2[v][non_zero])/P2[v][non_zero]                 assert np.max(np.abs(rel_deviation)) &lt; rel_tol, f'Max[ |relative deviation| ] for {v}: {np.max(np.abs(rel_deviation))} for {Path(p1file).name}'            def test_beams(beam_files, previous_archive, verbose=True, abs_tol=1e-10, rel_tol=1e-12):      print(f'Comparing the current beam archive to {previous_archive}\\n')      for beam_file in beam_files:         test_beam(beam_file, previous_archive, verbose=verbose, abs_tol = abs_tol, rel_tol = rel_tol)      if(verbose):         print('\\nAll beams check to w/absolute tolerance of:', abs_tol )         print('All beams check to an w/relative tolerance of:', rel_tol )  test_beams(YAMLS, PREVIOUS_ARCHIVE, verbose=True, abs_tol = 1e-11, rel_tol=1e-12) <pre>Comparing the current beam archive to archive\n\nChecking: SG.beer.can.in.h5 against archive/SG.beer.can.in.h5\nChecking: interp_ex.h5 against archive/interp_ex.h5\nChecking: jpeg.image.in.h5 against archive/jpeg.image.in.h5\nChecking: laser.image.in.h5 against archive/laser.image.in.h5\nChecking: KEdist.beer.can.in.h5 against archive/KEdist.beer.can.in.h5\nChecking: deformable.in.h5 against archive/deformable.in.h5\nChecking: rad_new_format.uniform.in.h5 against archive/rad_new_format.uniform.in.h5\nChecking: rad.uniform.in.h5 against archive/rad.uniform.in.h5\nChecking: multi.gaussian.in.h5 against archive/multi.gaussian.in.h5\nChecking: xy.prod.in.h5 against archive/xy.prod.in.h5\nChecking: maxwell_boltzmann.beer.can.in.h5 against archive/maxwell_boltzmann.beer.can.in.h5\nChecking: uniform_speckle.in.h5 against archive/uniform_speckle.in.h5\nChecking: fermi_dirac_3step_barrier_photocathode.in.h5 against archive/fermi_dirac_3step_barrier_photocathode.in.h5\nChecking: rad.gaussian.in.h5 against archive/rad.gaussian.in.h5\nChecking: x.y.uniform.in.h5 against archive/x.y.uniform.in.h5\nChecking: x.uniform.y.file.t.gaussian.in.h5 against archive/x.uniform.y.file.t.gaussian.in.h5\nChecking: rad.trunc.gaussian.in.h5 against archive/rad.trunc.gaussian.in.h5\nChecking: beer.can.in.h5 against archive/beer.can.in.h5\nChecking: t.crystals.in.h5 against archive/t.crystals.in.h5\nChecking: maxwell_boltzmann_KE.beer.can.in.h5 against archive/maxwell_boltzmann_KE.beer.can.in.h5\nChecking: tukey.beer.can.in.h5 against archive/tukey.beer.can.in.h5\nChecking: t-sech2.in.h5 against archive/t-sech2.in.h5\nChecking: rad.file.in.h5 against archive/rad.file.in.h5\nChecking: gaussian.in.h5 against archive/gaussian.in.h5\nChecking: dcm.image.in.h5 against archive/dcm.image.in.h5\nChecking: t.file.in.h5 against archive/t.file.in.h5\nChecking: product.gaussian.in.h5 against archive/product.gaussian.in.h5\n\nAll beams check to w/absolute tolerance of: 1e-11\nAll beams check to an w/relative tolerance of: 1e-12\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"regression_tests/example_beams/#compare-example-beams-across-versions","title":"Compare Example Beams Across Versions\u00b6","text":"<p>Generate Current Devel Example Beams</p>"},{"location":"regression_tests/example_beams/#generate-archive","title":"Generate Archive\u00b6","text":""},{"location":"regression_tests/example_beams/#compare-archive-to-a-previous-archive","title":"Compare Archive To A Previous Archive\u00b6","text":""},{"location":"regression_tests/example_dists/","title":"Example dists","text":"In\u00a0[1]: Copied! <pre>from distgen import Generator\nimport numpy as np\nfrom distgen.parsing import parse_quantity\n</pre> from distgen import Generator import numpy as np from distgen.parsing import parse_quantity In\u00a0[2]: Copied! <pre>def test_uniform_rad():\n    \n    D=Generator('../examples/data/rad.uniform.in.yaml',verbose=0)\n    D['r_dist:min_r']=0\n    D.run()\n\n    max_r = D._input['r_dist']['max_r'].to('m').magnitude\n\n    assert np.isclose(D.particles['mean_x'], 0)\n    assert np.isclose(D.particles['mean_y'], 0)\n    assert np.isclose(D.particles['sigma_x'], max_r/2)\n    assert np.isclose(D.particles['sigma_y'], max_r/2)\n    assert np.isclose( max(D.particles['r']) , max_r, rtol=1e-8, atol=1e-7)\n\n    D['r_dist:min_r']=1\n    min_r = D._input['r_dist']['min_r'].to('m').magnitude\n    D.run()\n\n    assert np.isclose(D.particles['mean_x'], 0)\n    assert np.isclose(D.particles['mean_y'], 0)\n    assert np.isclose( min(D.particles['r']) , min_r, rtol=1e-8, atol=1e-7)\n    assert np.isclose( max(D.particles['r']) , max_r, rtol=1e-8, atol=1e-7)\n    \ntest_uniform_rad()\n</pre> def test_uniform_rad():          D=Generator('../examples/data/rad.uniform.in.yaml',verbose=0)     D['r_dist:min_r']=0     D.run()      max_r = D._input['r_dist']['max_r'].to('m').magnitude      assert np.isclose(D.particles['mean_x'], 0)     assert np.isclose(D.particles['mean_y'], 0)     assert np.isclose(D.particles['sigma_x'], max_r/2)     assert np.isclose(D.particles['sigma_y'], max_r/2)     assert np.isclose( max(D.particles['r']) , max_r, rtol=1e-8, atol=1e-7)      D['r_dist:min_r']=1     min_r = D._input['r_dist']['min_r'].to('m').magnitude     D.run()      assert np.isclose(D.particles['mean_x'], 0)     assert np.isclose(D.particles['mean_y'], 0)     assert np.isclose( min(D.particles['r']) , min_r, rtol=1e-8, atol=1e-7)     assert np.isclose( max(D.particles['r']) , max_r, rtol=1e-8, atol=1e-7)      test_uniform_rad() In\u00a0[3]: Copied! <pre>def test_radial_gaussian():\n\n    D=Generator('../examples/data/rad.gaussian.in.yaml',verbose=0)\n    sigma_xy = D._input['r_dist']['sigma_xy'].to('m').magnitude\n    D.run()\n\n    assert np.isclose(D.particles['mean_x'], 0)\n    assert np.isclose(D.particles['mean_y'], 0)\n    assert np.isclose(sigma_xy, D.particles['sigma_x'])\n    assert np.isclose(sigma_xy, D.particles['sigma_y'])\n\n    D=Generator('../examples/data/rad.trunc.gaussian.in.yaml',verbose=0)\n    D.run()\n    \n    assert np.isclose(D.particles['mean_x'], 0)\n    assert np.isclose(D.particles['mean_y'], 0)\n\n    max_r = D._input['r_dist']['truncation_radius'].to('m').magnitude    \n    assert np.isclose(max(D.particles['r']), max_r, rtol=1e-8, atol=1e-7)\n\ntest_radial_gaussian()\n</pre> def test_radial_gaussian():      D=Generator('../examples/data/rad.gaussian.in.yaml',verbose=0)     sigma_xy = D._input['r_dist']['sigma_xy'].to('m').magnitude     D.run()      assert np.isclose(D.particles['mean_x'], 0)     assert np.isclose(D.particles['mean_y'], 0)     assert np.isclose(sigma_xy, D.particles['sigma_x'])     assert np.isclose(sigma_xy, D.particles['sigma_y'])      D=Generator('../examples/data/rad.trunc.gaussian.in.yaml',verbose=0)     D.run()          assert np.isclose(D.particles['mean_x'], 0)     assert np.isclose(D.particles['mean_y'], 0)      max_r = D._input['r_dist']['truncation_radius'].to('m').magnitude         assert np.isclose(max(D.particles['r']), max_r, rtol=1e-8, atol=1e-7)  test_radial_gaussian()"},{"location":"regression_tests/parsing/","title":"Parsing","text":"In\u00a0[1]: Copied! <pre>%load_ext autoreload\n%autoreload 2\n%config InlineBackend.figure_format = 'retina'\n</pre> %load_ext autoreload %autoreload 2 %config InlineBackend.figure_format = 'retina' In\u00a0[2]: Copied! <pre>from distgen.parsing import is_floatable\n\ndef test_isfloatable():\n\n    assert not is_floatable('foobar') \n    assert not is_floatable([]) \n    assert not is_floatable({}) \n\n    assert is_floatable(1) \n    assert is_floatable('1234')\n    assert is_floatable(12350.0)\n\ntest_isfloatable()\n</pre> from distgen.parsing import is_floatable  def test_isfloatable():      assert not is_floatable('foobar')      assert not is_floatable([])      assert not is_floatable({})       assert is_floatable(1)      assert is_floatable('1234')     assert is_floatable(12350.0)  test_isfloatable() In\u00a0[3]: Copied! <pre>from distgen.parsing import is_unit\nfrom distgen.physical_constants import unit_registry\n\ndef test_is_unit():\n\n    # Strings with a value and unit return False\n    assert not is_unit('2 ps')   \n    assert not is_unit('1 ps')\n    assert not is_unit('1.0 ps')\n\n    # Strings with known units work, as will an actual Pint unit object\n    assert is_unit('ps')\n    assert is_unit(unit_registry.Unit('ps'))\n\ntest_is_unit()\n</pre> from distgen.parsing import is_unit from distgen.physical_constants import unit_registry  def test_is_unit():      # Strings with a value and unit return False     assert not is_unit('2 ps')        assert not is_unit('1 ps')     assert not is_unit('1.0 ps')      # Strings with known units work, as will an actual Pint unit object     assert is_unit('ps')     assert is_unit(unit_registry.Unit('ps'))  test_is_unit() In\u00a0[4]: Copied! <pre>from distgen.parsing import is_quantizable\n\ndef test_is_quantizable():\n\n    assert not is_quantizable(10.0)\n    assert not is_quantizable('10.0')\n    assert not is_quantizable({'value': 120.1})\n    assert not is_quantizable({'units': 120.1})\n\n    Q_ = unit_registry.Quantity\n    assert is_quantizable(Q_(10, 'ps'))\n    assert is_quantizable('10 ps')\n    assert is_quantizable({'value': 120.1, 'units':'mm'})\n\ntest_is_quantizable()\n</pre> from distgen.parsing import is_quantizable  def test_is_quantizable():      assert not is_quantizable(10.0)     assert not is_quantizable('10.0')     assert not is_quantizable({'value': 120.1})     assert not is_quantizable({'units': 120.1})      Q_ = unit_registry.Quantity     assert is_quantizable(Q_(10, 'ps'))     assert is_quantizable('10 ps')     assert is_quantizable({'value': 120.1, 'units':'mm'})  test_is_quantizable() In\u00a0[5]: Copied! <pre>from distgen.parsing import dict_to_quantity\n\ndef test_dict_to_quantity():\n\n    q1 = dict_to_quantity({'value': 102.1, 'units': 'eV'})\n    q2 = unit_registry.Quantity(102.1, 'eV')\n\n    assert q1==q2\n\ntest_dict_to_quantity()\n</pre> from distgen.parsing import dict_to_quantity  def test_dict_to_quantity():      q1 = dict_to_quantity({'value': 102.1, 'units': 'eV'})     q2 = unit_registry.Quantity(102.1, 'eV')      assert q1==q2  test_dict_to_quantity() In\u00a0[6]: Copied! <pre>from distgen.parsing import parse_quantity\n\ndef test_parse_quantity():\n\n    q1 = unit_registry.Quantity(102.1, 'eV')\n    q2 = parse_quantity('102.1 eV')\n    q3 = parse_quantity({'value': 102.1, 'units': 'eV'})\n\n    assert q1 == q2\n    assert q2 == q3\n    \ntest_parse_quantity()\n</pre> from distgen.parsing import parse_quantity  def test_parse_quantity():      q1 = unit_registry.Quantity(102.1, 'eV')     q2 = parse_quantity('102.1 eV')     q3 = parse_quantity({'value': 102.1, 'units': 'eV'})      assert q1 == q2     assert q2 == q3      test_parse_quantity() In\u00a0[7]: Copied! <pre>from distgen.parsing import update_quantity\nfrom pint import DimensionalityError\n\ndef test_update_quantity():\n\n    qi = unit_registry.Quantity(102.1, 'eV')\n\n    try: \n        update_quantity(qi, '10 ps')\n        \n    except Exception as ex:\n        \n        if(not isinstance(ex, DimensionalityError)):\n            raise ValueError(\"Didn't catch dimensionality error\")\n\n    assert update_quantity(qi, 10) == unit_registry.Quantity(10, 'eV')\n    assert update_quantity(qi, '10 eV') == unit_registry.Quantity(10, 'eV')\n    assert update_quantity(qi, {'value':10, 'units':'eV'}) == unit_registry.Quantity(10, 'eV')\n\ntest_update_quantity()\n</pre> from distgen.parsing import update_quantity from pint import DimensionalityError  def test_update_quantity():      qi = unit_registry.Quantity(102.1, 'eV')      try:          update_quantity(qi, '10 ps')              except Exception as ex:                  if(not isinstance(ex, DimensionalityError)):             raise ValueError(\"Didn't catch dimensionality error\")      assert update_quantity(qi, 10) == unit_registry.Quantity(10, 'eV')     assert update_quantity(qi, '10 eV') == unit_registry.Quantity(10, 'eV')     assert update_quantity(qi, {'value':10, 'units':'eV'}) == unit_registry.Quantity(10, 'eV')  test_update_quantity() In\u00a0[8]: Copied! <pre>from distgen.parsing import update_quantity_in_dict\nfrom pint import DimensionalityError\n\ndef test_update_quantity_in_dict():\n\n    d = {'x':unit_registry.Quantity('10 ps')}\n    d2 = {'x':unit_registry.Quantity('12 ps')}\n\n    try: \n        update_quantity_in_dict('x', d, '10 mm')\n        \n    except Exception as ex:\n        \n        if(not isinstance(ex, DimensionalityError)):\n            raise ValueError(\"Didn't catch dimensionality error\")\n    \n    update_quantity_in_dict('x', d ,'12 ps')\n    assert d=={'x':unit_registry.Quantity('12 ps')}\n\n    update_quantity_in_dict('x', d , 13)\n    assert d=={'x':unit_registry.Quantity('13 ps')}\n\n    update_quantity_in_dict('x', d , unit_registry.Quantity('14 ps'))\n    assert d=={'x':unit_registry.Quantity('14 ps')}\n\n    update_quantity_in_dict('x', d, {'value':15, 'units':'ps'})\n\ntest_update_quantity_in_dict()\n</pre> from distgen.parsing import update_quantity_in_dict from pint import DimensionalityError  def test_update_quantity_in_dict():      d = {'x':unit_registry.Quantity('10 ps')}     d2 = {'x':unit_registry.Quantity('12 ps')}      try:          update_quantity_in_dict('x', d, '10 mm')              except Exception as ex:                  if(not isinstance(ex, DimensionalityError)):             raise ValueError(\"Didn't catch dimensionality error\")          update_quantity_in_dict('x', d ,'12 ps')     assert d=={'x':unit_registry.Quantity('12 ps')}      update_quantity_in_dict('x', d , 13)     assert d=={'x':unit_registry.Quantity('13 ps')}      update_quantity_in_dict('x', d , unit_registry.Quantity('14 ps'))     assert d=={'x':unit_registry.Quantity('14 ps')}      update_quantity_in_dict('x', d, {'value':15, 'units':'ps'})  test_update_quantity_in_dict() In\u00a0[9]: Copied! <pre>from distgen.parsing import list_to_dict\n\ndef test_list_to_dict():\n    l = ['x', unit_registry.Quantity(10, 's'), 10]\n    d = list_to_dict(l)\n    assert d == {0:'x', 1:unit_registry.Quantity(10, 's'), 2:10}\n\ntest_list_to_dict()\n</pre> from distgen.parsing import list_to_dict  def test_list_to_dict():     l = ['x', unit_registry.Quantity(10, 's'), 10]     d = list_to_dict(l)     assert d == {0:'x', 1:unit_registry.Quantity(10, 's'), 2:10}  test_list_to_dict() In\u00a0[10]: Copied! <pre>from distgen.parsing import convert_list_quantities\n\ndef test_convert_list_quantities():\n    l = ['10 ps', {'value': 12, 'units': 'ps'}]\n    convert_list_quantities(l)\n    assert l == [unit_registry.Quantity(10, 'ps'), unit_registry.Quantity(12, 'ps')]\n    \ntest_convert_list_quantities()\n</pre> from distgen.parsing import convert_list_quantities  def test_convert_list_quantities():     l = ['10 ps', {'value': 12, 'units': 'ps'}]     convert_list_quantities(l)     assert l == [unit_registry.Quantity(10, 'ps'), unit_registry.Quantity(12, 'ps')]      test_convert_list_quantities() In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"regression_tests/physical_constants/","title":"Physical Constant Tests","text":"In\u00a0[1]: Copied! <pre>from distgen.physical_constants import *\nimport scipy.constants\nfrom distgen.tools import check_abs_and_rel_tols\n</pre> from distgen.physical_constants import * import scipy.constants from distgen.tools import check_abs_and_rel_tols In\u00a0[2]: Copied! <pre>def test_basic_constants():\n    \n    # Speed of light \n    assert PHYSICAL_CONSTANTS['speed of light in vacuum'].magnitude == 299792458\n    assert str(PHYSICAL_CONSTANTS['speed of light in vacuum'].units) == 'meter / second'\n</pre> def test_basic_constants():          # Speed of light      assert PHYSICAL_CONSTANTS['speed of light in vacuum'].magnitude == 299792458     assert str(PHYSICAL_CONSTANTS['speed of light in vacuum'].units) == 'meter / second'       In\u00a0[3]: Copied! <pre>PHYSICAL_CONSTANTS['electron mass']\n</pre> PHYSICAL_CONSTANTS['electron mass'] Out[3]:  9.1093837015\u00d710<sup>-31</sup> kilogram  In\u00a0[4]: Copied! <pre>PHYSICAL_CONSTANTS.species('electron')\n</pre> PHYSICAL_CONSTANTS.species('electron') Out[4]: <pre>{'charge': &lt;Quantity(-1.60217663e-19, 'coulomb')&gt;,\n 'mass': &lt;Quantity(9.1093837e-31, 'kilogram')&gt;,\n 'mc2': &lt;Quantity(510998.95, 'electron_volt')&gt;,\n 'g_factor': &lt;Quantity(-2.0023193, 'dimensionless')&gt;}</pre> In\u00a0[5]: Copied! <pre>PHYSICAL_CONSTANTS\n</pre> PHYSICAL_CONSTANTS Out[5]: <pre>&lt;distgen.physical_constants.PhysicalConstants at 0x7fe6bf121b80&gt;</pre> In\u00a0[6]: Copied! <pre>def test_species_data():\n\n    # Electron\n    electron = PHYSICAL_CONSTANTS.species('electron')\n    assert electron['charge'].magnitude == -1.602176634e-19\n    assert electron['mass'].magnitude == 9.1093837015e-31\n    assert electron['mc2'].magnitude == 0.51099894999999995e6\n    assert electron['g_factor'].magnitude == -2.00231930436256\n\n    # Photon\n    photon = PHYSICAL_CONSTANTS.species('photon')\n    assert photon['charge'].magnitude == 0\n    assert photon['mass'].magnitude == 0\n    assert photon['mc2'].magnitude == 0\n    assert photon['g_factor'].magnitude == 0\n\n    # Positron\n    positron = PHYSICAL_CONSTANTS.species('positron')\n    assert positron['charge'].magnitude == +1.602176634e-19\n    assert positron['mass'].magnitude == 9.1093837015e-31\n    assert positron['mc2'].magnitude == 0.51099894999999995e6\n    assert positron['g_factor'].magnitude == +2.00231930436256\n\n    # Proton\n    proton = PHYSICAL_CONSTANTS.species('proton')\n    assert proton['charge'].magnitude == +1.602176634e-19\n    assert proton['mass'].magnitude == 1.67262192369e-27\n    assert proton['mc2'].magnitude == 938272088.16\n    assert proton['g_factor'].magnitude == 5.5856946893\n\n    # Muon\n    muon = PHYSICAL_CONSTANTS.species('muon')\n    assert muon['charge'].magnitude == -1.602176634e-19\n    assert muon['mass'].magnitude == 1.883531627e-28\n    assert muon['mc2'].magnitude == 105.6583755e6\n    assert muon['g_factor'].magnitude == -2.0023318418\n    \n    # Neutron\n    neutron = PHYSICAL_CONSTANTS.species('neutron')\n    assert neutron['charge'].magnitude == 0\n    assert neutron['mass'].magnitude == 1.67492749804e-27\n    assert neutron['mc2'].magnitude == 939.56542052e6\n    assert neutron['g_factor'].magnitude == -3.82608545\n\n    # Tau\n    tau = PHYSICAL_CONSTANTS.species('tau')\n    assert tau['charge'].magnitude == -1.602176634e-19\n    assert tau['mass'].magnitude == 3.16754e-27\n    assert tau['mc2'].magnitude == 1776820000.0\n    assert tau['g_factor'].magnitude == -2.00231930436256\n    \n\ntest_species_data()\n</pre> def test_species_data():      # Electron     electron = PHYSICAL_CONSTANTS.species('electron')     assert electron['charge'].magnitude == -1.602176634e-19     assert electron['mass'].magnitude == 9.1093837015e-31     assert electron['mc2'].magnitude == 0.51099894999999995e6     assert electron['g_factor'].magnitude == -2.00231930436256      # Photon     photon = PHYSICAL_CONSTANTS.species('photon')     assert photon['charge'].magnitude == 0     assert photon['mass'].magnitude == 0     assert photon['mc2'].magnitude == 0     assert photon['g_factor'].magnitude == 0      # Positron     positron = PHYSICAL_CONSTANTS.species('positron')     assert positron['charge'].magnitude == +1.602176634e-19     assert positron['mass'].magnitude == 9.1093837015e-31     assert positron['mc2'].magnitude == 0.51099894999999995e6     assert positron['g_factor'].magnitude == +2.00231930436256      # Proton     proton = PHYSICAL_CONSTANTS.species('proton')     assert proton['charge'].magnitude == +1.602176634e-19     assert proton['mass'].magnitude == 1.67262192369e-27     assert proton['mc2'].magnitude == 938272088.16     assert proton['g_factor'].magnitude == 5.5856946893      # Muon     muon = PHYSICAL_CONSTANTS.species('muon')     assert muon['charge'].magnitude == -1.602176634e-19     assert muon['mass'].magnitude == 1.883531627e-28     assert muon['mc2'].magnitude == 105.6583755e6     assert muon['g_factor'].magnitude == -2.0023318418          # Neutron     neutron = PHYSICAL_CONSTANTS.species('neutron')     assert neutron['charge'].magnitude == 0     assert neutron['mass'].magnitude == 1.67492749804e-27     assert neutron['mc2'].magnitude == 939.56542052e6     assert neutron['g_factor'].magnitude == -3.82608545      # Tau     tau = PHYSICAL_CONSTANTS.species('tau')     assert tau['charge'].magnitude == -1.602176634e-19     assert tau['mass'].magnitude == 3.16754e-27     assert tau['mc2'].magnitude == 1776820000.0     assert tau['g_factor'].magnitude == -2.00231930436256       test_species_data() In\u00a0[7]: Copied! <pre>PHYSICAL_CONSTANTS.species('tau')['mc2']\n</pre> PHYSICAL_CONSTANTS.species('tau')['mc2'] Out[7]:  1776820000.0 electron_volt  In\u00a0[\u00a0]: Copied! <pre>\n</pre>"},{"location":"regression_tests/physical_constants/#physical-constant-tests","title":"Physical Constant Tests\u00b6","text":""},{"location":"regression_tests/tools/","title":"Tools","text":"In\u00a0[1]: Copied! <pre>from distgen.tools import full_path\n\nimport os\n\ndef test_full_path(path):\n\n    os.environ['DISTGEN_EXAMPLES'] = os.path.abspath('../examples')\n    assert full_path(path) == os.environ['DISTGEN_EXAMPLES']\n\ntest_full_path('$DISTGEN_EXAMPLES')\ntest_full_path('../examples')\n</pre> from distgen.tools import full_path  import os  def test_full_path(path):      os.environ['DISTGEN_EXAMPLES'] = os.path.abspath('../examples')     assert full_path(path) == os.environ['DISTGEN_EXAMPLES']  test_full_path('$DISTGEN_EXAMPLES') test_full_path('../examples') In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>\n</pre>"}]}